
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Branch
 * 
 */
export type Branch = $Result.DefaultSelection<Prisma.$BranchPayload>
/**
 * Model Floor
 * 
 */
export type Floor = $Result.DefaultSelection<Prisma.$FloorPayload>
/**
 * Model Section
 * 
 */
export type Section = $Result.DefaultSelection<Prisma.$SectionPayload>
/**
 * Model Stall
 * 
 */
export type Stall = $Result.DefaultSelection<Prisma.$StallPayload>
/**
 * Model StallImage
 * 
 */
export type StallImage = $Result.DefaultSelection<Prisma.$StallImagePayload>
/**
 * Model Stallholder
 * 
 */
export type Stallholder = $Result.DefaultSelection<Prisma.$StallholderPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Application
 * 
 */
export type Application = $Result.DefaultSelection<Prisma.$ApplicationPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Compliance
 * 
 */
export type Compliance = $Result.DefaultSelection<Prisma.$CompliancePayload>
/**
 * Model Complaint
 * 
 */
export type Complaint = $Result.DefaultSelection<Prisma.$ComplaintPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Branches
 * const branches = await prisma.branch.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Branches
   * const branches = await prisma.branch.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.branch`: Exposes CRUD operations for the **Branch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Branches
    * const branches = await prisma.branch.findMany()
    * ```
    */
  get branch(): Prisma.BranchDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.floor`: Exposes CRUD operations for the **Floor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Floors
    * const floors = await prisma.floor.findMany()
    * ```
    */
  get floor(): Prisma.FloorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.section`: Exposes CRUD operations for the **Section** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sections
    * const sections = await prisma.section.findMany()
    * ```
    */
  get section(): Prisma.SectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stall`: Exposes CRUD operations for the **Stall** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stalls
    * const stalls = await prisma.stall.findMany()
    * ```
    */
  get stall(): Prisma.StallDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stallImage`: Exposes CRUD operations for the **StallImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StallImages
    * const stallImages = await prisma.stallImage.findMany()
    * ```
    */
  get stallImage(): Prisma.StallImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stallholder`: Exposes CRUD operations for the **Stallholder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stallholders
    * const stallholders = await prisma.stallholder.findMany()
    * ```
    */
  get stallholder(): Prisma.StallholderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.application`: Exposes CRUD operations for the **Application** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applications
    * const applications = await prisma.application.findMany()
    * ```
    */
  get application(): Prisma.ApplicationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.compliance`: Exposes CRUD operations for the **Compliance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Compliances
    * const compliances = await prisma.compliance.findMany()
    * ```
    */
  get compliance(): Prisma.ComplianceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaint`: Exposes CRUD operations for the **Complaint** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Complaints
    * const complaints = await prisma.complaint.findMany()
    * ```
    */
  get complaint(): Prisma.ComplaintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Branch: 'Branch',
    Floor: 'Floor',
    Section: 'Section',
    Stall: 'Stall',
    StallImage: 'StallImage',
    Stallholder: 'Stallholder',
    Employee: 'Employee',
    Application: 'Application',
    Payment: 'Payment',
    Compliance: 'Compliance',
    Complaint: 'Complaint',
    Vendor: 'Vendor',
    ActivityLog: 'ActivityLog',
    Subscription: 'Subscription'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "branch" | "floor" | "section" | "stall" | "stallImage" | "stallholder" | "employee" | "application" | "payment" | "compliance" | "complaint" | "vendor" | "activityLog" | "subscription"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Branch: {
        payload: Prisma.$BranchPayload<ExtArgs>
        fields: Prisma.BranchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BranchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BranchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findFirst: {
            args: Prisma.BranchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BranchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          findMany: {
            args: Prisma.BranchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>[]
          }
          create: {
            args: Prisma.BranchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          createMany: {
            args: Prisma.BranchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.BranchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          update: {
            args: Prisma.BranchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          deleteMany: {
            args: Prisma.BranchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BranchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BranchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BranchPayload>
          }
          aggregate: {
            args: Prisma.BranchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBranch>
          }
          groupBy: {
            args: Prisma.BranchGroupByArgs<ExtArgs>
            result: $Utils.Optional<BranchGroupByOutputType>[]
          }
          count: {
            args: Prisma.BranchCountArgs<ExtArgs>
            result: $Utils.Optional<BranchCountAggregateOutputType> | number
          }
        }
      }
      Floor: {
        payload: Prisma.$FloorPayload<ExtArgs>
        fields: Prisma.FloorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FloorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FloorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPayload>
          }
          findFirst: {
            args: Prisma.FloorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FloorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPayload>
          }
          findMany: {
            args: Prisma.FloorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPayload>[]
          }
          create: {
            args: Prisma.FloorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPayload>
          }
          createMany: {
            args: Prisma.FloorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FloorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPayload>
          }
          update: {
            args: Prisma.FloorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPayload>
          }
          deleteMany: {
            args: Prisma.FloorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FloorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FloorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPayload>
          }
          aggregate: {
            args: Prisma.FloorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFloor>
          }
          groupBy: {
            args: Prisma.FloorGroupByArgs<ExtArgs>
            result: $Utils.Optional<FloorGroupByOutputType>[]
          }
          count: {
            args: Prisma.FloorCountArgs<ExtArgs>
            result: $Utils.Optional<FloorCountAggregateOutputType> | number
          }
        }
      }
      Section: {
        payload: Prisma.$SectionPayload<ExtArgs>
        fields: Prisma.SectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findFirst: {
            args: Prisma.SectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          findMany: {
            args: Prisma.SectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>[]
          }
          create: {
            args: Prisma.SectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          createMany: {
            args: Prisma.SectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          update: {
            args: Prisma.SectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          deleteMany: {
            args: Prisma.SectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionPayload>
          }
          aggregate: {
            args: Prisma.SectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSection>
          }
          groupBy: {
            args: Prisma.SectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionCountArgs<ExtArgs>
            result: $Utils.Optional<SectionCountAggregateOutputType> | number
          }
        }
      }
      Stall: {
        payload: Prisma.$StallPayload<ExtArgs>
        fields: Prisma.StallFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StallFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StallFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallPayload>
          }
          findFirst: {
            args: Prisma.StallFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StallFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallPayload>
          }
          findMany: {
            args: Prisma.StallFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallPayload>[]
          }
          create: {
            args: Prisma.StallCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallPayload>
          }
          createMany: {
            args: Prisma.StallCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StallDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallPayload>
          }
          update: {
            args: Prisma.StallUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallPayload>
          }
          deleteMany: {
            args: Prisma.StallDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StallUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StallUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallPayload>
          }
          aggregate: {
            args: Prisma.StallAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStall>
          }
          groupBy: {
            args: Prisma.StallGroupByArgs<ExtArgs>
            result: $Utils.Optional<StallGroupByOutputType>[]
          }
          count: {
            args: Prisma.StallCountArgs<ExtArgs>
            result: $Utils.Optional<StallCountAggregateOutputType> | number
          }
        }
      }
      StallImage: {
        payload: Prisma.$StallImagePayload<ExtArgs>
        fields: Prisma.StallImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StallImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StallImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallImagePayload>
          }
          findFirst: {
            args: Prisma.StallImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StallImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallImagePayload>
          }
          findMany: {
            args: Prisma.StallImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallImagePayload>[]
          }
          create: {
            args: Prisma.StallImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallImagePayload>
          }
          createMany: {
            args: Prisma.StallImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StallImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallImagePayload>
          }
          update: {
            args: Prisma.StallImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallImagePayload>
          }
          deleteMany: {
            args: Prisma.StallImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StallImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StallImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallImagePayload>
          }
          aggregate: {
            args: Prisma.StallImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStallImage>
          }
          groupBy: {
            args: Prisma.StallImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<StallImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.StallImageCountArgs<ExtArgs>
            result: $Utils.Optional<StallImageCountAggregateOutputType> | number
          }
        }
      }
      Stallholder: {
        payload: Prisma.$StallholderPayload<ExtArgs>
        fields: Prisma.StallholderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StallholderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallholderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StallholderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallholderPayload>
          }
          findFirst: {
            args: Prisma.StallholderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallholderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StallholderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallholderPayload>
          }
          findMany: {
            args: Prisma.StallholderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallholderPayload>[]
          }
          create: {
            args: Prisma.StallholderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallholderPayload>
          }
          createMany: {
            args: Prisma.StallholderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StallholderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallholderPayload>
          }
          update: {
            args: Prisma.StallholderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallholderPayload>
          }
          deleteMany: {
            args: Prisma.StallholderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StallholderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StallholderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StallholderPayload>
          }
          aggregate: {
            args: Prisma.StallholderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStallholder>
          }
          groupBy: {
            args: Prisma.StallholderGroupByArgs<ExtArgs>
            result: $Utils.Optional<StallholderGroupByOutputType>[]
          }
          count: {
            args: Prisma.StallholderCountArgs<ExtArgs>
            result: $Utils.Optional<StallholderCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Application: {
        payload: Prisma.$ApplicationPayload<ExtArgs>
        fields: Prisma.ApplicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApplicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApplicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findFirst: {
            args: Prisma.ApplicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApplicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          findMany: {
            args: Prisma.ApplicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>[]
          }
          create: {
            args: Prisma.ApplicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          createMany: {
            args: Prisma.ApplicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ApplicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          update: {
            args: Prisma.ApplicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          deleteMany: {
            args: Prisma.ApplicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ApplicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ApplicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ApplicationPayload>
          }
          aggregate: {
            args: Prisma.ApplicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplication>
          }
          groupBy: {
            args: Prisma.ApplicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApplicationCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicationCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Compliance: {
        payload: Prisma.$CompliancePayload<ExtArgs>
        fields: Prisma.ComplianceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplianceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompliancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplianceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompliancePayload>
          }
          findFirst: {
            args: Prisma.ComplianceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompliancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplianceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompliancePayload>
          }
          findMany: {
            args: Prisma.ComplianceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompliancePayload>[]
          }
          create: {
            args: Prisma.ComplianceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompliancePayload>
          }
          createMany: {
            args: Prisma.ComplianceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComplianceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompliancePayload>
          }
          update: {
            args: Prisma.ComplianceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompliancePayload>
          }
          deleteMany: {
            args: Prisma.ComplianceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplianceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplianceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompliancePayload>
          }
          aggregate: {
            args: Prisma.ComplianceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompliance>
          }
          groupBy: {
            args: Prisma.ComplianceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplianceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplianceCountArgs<ExtArgs>
            result: $Utils.Optional<ComplianceCountAggregateOutputType> | number
          }
        }
      }
      Complaint: {
        payload: Prisma.$ComplaintPayload<ExtArgs>
        fields: Prisma.ComplaintFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplaintFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplaintFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findFirst: {
            args: Prisma.ComplaintFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplaintFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          findMany: {
            args: Prisma.ComplaintFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[]
          }
          create: {
            args: Prisma.ComplaintCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          createMany: {
            args: Prisma.ComplaintCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ComplaintDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          update: {
            args: Prisma.ComplaintUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          deleteMany: {
            args: Prisma.ComplaintDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplaintUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComplaintUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>
          }
          aggregate: {
            args: Prisma.ComplaintAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplaint>
          }
          groupBy: {
            args: Prisma.ComplaintGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplaintGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplaintCountArgs<ExtArgs>
            result: $Utils.Optional<ComplaintCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    branch?: BranchOmit
    floor?: FloorOmit
    section?: SectionOmit
    stall?: StallOmit
    stallImage?: StallImageOmit
    stallholder?: StallholderOmit
    employee?: EmployeeOmit
    application?: ApplicationOmit
    payment?: PaymentOmit
    compliance?: ComplianceOmit
    complaint?: ComplaintOmit
    vendor?: VendorOmit
    activityLog?: ActivityLogOmit
    subscription?: SubscriptionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BranchCountOutputType
   */

  export type BranchCountOutputType = {
    stalls: number
    employees: number
    floors: number
    sections: number
    stallholders: number
  }

  export type BranchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stalls?: boolean | BranchCountOutputTypeCountStallsArgs
    employees?: boolean | BranchCountOutputTypeCountEmployeesArgs
    floors?: boolean | BranchCountOutputTypeCountFloorsArgs
    sections?: boolean | BranchCountOutputTypeCountSectionsArgs
    stallholders?: boolean | BranchCountOutputTypeCountStallholdersArgs
  }

  // Custom InputTypes
  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BranchCountOutputType
     */
    select?: BranchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountStallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StallWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountFloorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FloorWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }

  /**
   * BranchCountOutputType without action
   */
  export type BranchCountOutputTypeCountStallholdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StallholderWhereInput
  }


  /**
   * Count Type FloorCountOutputType
   */

  export type FloorCountOutputType = {
    stalls: number
    sections: number
  }

  export type FloorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stalls?: boolean | FloorCountOutputTypeCountStallsArgs
    sections?: boolean | FloorCountOutputTypeCountSectionsArgs
  }

  // Custom InputTypes
  /**
   * FloorCountOutputType without action
   */
  export type FloorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorCountOutputType
     */
    select?: FloorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FloorCountOutputType without action
   */
  export type FloorCountOutputTypeCountStallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StallWhereInput
  }

  /**
   * FloorCountOutputType without action
   */
  export type FloorCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
  }


  /**
   * Count Type SectionCountOutputType
   */

  export type SectionCountOutputType = {
    stalls: number
  }

  export type SectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stalls?: boolean | SectionCountOutputTypeCountStallsArgs
  }

  // Custom InputTypes
  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionCountOutputType
     */
    select?: SectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectionCountOutputType without action
   */
  export type SectionCountOutputTypeCountStallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StallWhereInput
  }


  /**
   * Count Type StallCountOutputType
   */

  export type StallCountOutputType = {
    images: number
    payments: number
    compliances: number
    complaints: number
    vendors: number
  }

  export type StallCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | StallCountOutputTypeCountImagesArgs
    payments?: boolean | StallCountOutputTypeCountPaymentsArgs
    compliances?: boolean | StallCountOutputTypeCountCompliancesArgs
    complaints?: boolean | StallCountOutputTypeCountComplaintsArgs
    vendors?: boolean | StallCountOutputTypeCountVendorsArgs
  }

  // Custom InputTypes
  /**
   * StallCountOutputType without action
   */
  export type StallCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallCountOutputType
     */
    select?: StallCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StallCountOutputType without action
   */
  export type StallCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StallImageWhereInput
  }

  /**
   * StallCountOutputType without action
   */
  export type StallCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * StallCountOutputType without action
   */
  export type StallCountOutputTypeCountCompliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceWhereInput
  }

  /**
   * StallCountOutputType without action
   */
  export type StallCountOutputTypeCountComplaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
  }

  /**
   * StallCountOutputType without action
   */
  export type StallCountOutputTypeCountVendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
  }


  /**
   * Count Type StallholderCountOutputType
   */

  export type StallholderCountOutputType = {
    stalls: number
    payments: number
    applications: number
  }

  export type StallholderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stalls?: boolean | StallholderCountOutputTypeCountStallsArgs
    payments?: boolean | StallholderCountOutputTypeCountPaymentsArgs
    applications?: boolean | StallholderCountOutputTypeCountApplicationsArgs
  }

  // Custom InputTypes
  /**
   * StallholderCountOutputType without action
   */
  export type StallholderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallholderCountOutputType
     */
    select?: StallholderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StallholderCountOutputType without action
   */
  export type StallholderCountOutputTypeCountStallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StallWhereInput
  }

  /**
   * StallholderCountOutputType without action
   */
  export type StallholderCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * StallholderCountOutputType without action
   */
  export type StallholderCountOutputTypeCountApplicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    inspections: number
    collections: number
    activityLogs: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inspections?: boolean | EmployeeCountOutputTypeCountInspectionsArgs
    collections?: boolean | EmployeeCountOutputTypeCountCollectionsArgs
    activityLogs?: boolean | EmployeeCountOutputTypeCountActivityLogsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountInspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountCollectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Branch
   */

  export type AggregateBranch = {
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  export type BranchAvgAggregateOutputType = {
    branch_id: number | null
  }

  export type BranchSumAggregateOutputType = {
    branch_id: number | null
  }

  export type BranchMinAggregateOutputType = {
    branch_id: number | null
    branch_name: string | null
    location: string | null
    address: string | null
    contact_number: string | null
    email: string | null
    description: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BranchMaxAggregateOutputType = {
    branch_id: number | null
    branch_name: string | null
    location: string | null
    address: string | null
    contact_number: string | null
    email: string | null
    description: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BranchCountAggregateOutputType = {
    branch_id: number
    branch_name: number
    location: number
    address: number
    contact_number: number
    email: number
    description: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BranchAvgAggregateInputType = {
    branch_id?: true
  }

  export type BranchSumAggregateInputType = {
    branch_id?: true
  }

  export type BranchMinAggregateInputType = {
    branch_id?: true
    branch_name?: true
    location?: true
    address?: true
    contact_number?: true
    email?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type BranchMaxAggregateInputType = {
    branch_id?: true
    branch_name?: true
    location?: true
    address?: true
    contact_number?: true
    email?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type BranchCountAggregateInputType = {
    branch_id?: true
    branch_name?: true
    location?: true
    address?: true
    contact_number?: true
    email?: true
    description?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BranchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branch to aggregate.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Branches
    **/
    _count?: true | BranchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BranchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BranchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BranchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BranchMaxAggregateInputType
  }

  export type GetBranchAggregateType<T extends BranchAggregateArgs> = {
        [P in keyof T & keyof AggregateBranch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBranch[P]>
      : GetScalarType<T[P], AggregateBranch[P]>
  }




  export type BranchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BranchWhereInput
    orderBy?: BranchOrderByWithAggregationInput | BranchOrderByWithAggregationInput[]
    by: BranchScalarFieldEnum[] | BranchScalarFieldEnum
    having?: BranchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BranchCountAggregateInputType | true
    _avg?: BranchAvgAggregateInputType
    _sum?: BranchSumAggregateInputType
    _min?: BranchMinAggregateInputType
    _max?: BranchMaxAggregateInputType
  }

  export type BranchGroupByOutputType = {
    branch_id: number
    branch_name: string
    location: string | null
    address: string | null
    contact_number: string | null
    email: string | null
    description: string | null
    status: string
    created_at: Date
    updated_at: Date
    _count: BranchCountAggregateOutputType | null
    _avg: BranchAvgAggregateOutputType | null
    _sum: BranchSumAggregateOutputType | null
    _min: BranchMinAggregateOutputType | null
    _max: BranchMaxAggregateOutputType | null
  }

  type GetBranchGroupByPayload<T extends BranchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BranchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BranchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BranchGroupByOutputType[P]>
            : GetScalarType<T[P], BranchGroupByOutputType[P]>
        }
      >
    >


  export type BranchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    branch_id?: boolean
    branch_name?: boolean
    location?: boolean
    address?: boolean
    contact_number?: boolean
    email?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    stalls?: boolean | Branch$stallsArgs<ExtArgs>
    employees?: boolean | Branch$employeesArgs<ExtArgs>
    floors?: boolean | Branch$floorsArgs<ExtArgs>
    sections?: boolean | Branch$sectionsArgs<ExtArgs>
    stallholders?: boolean | Branch$stallholdersArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["branch"]>



  export type BranchSelectScalar = {
    branch_id?: boolean
    branch_name?: boolean
    location?: boolean
    address?: boolean
    contact_number?: boolean
    email?: boolean
    description?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BranchOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"branch_id" | "branch_name" | "location" | "address" | "contact_number" | "email" | "description" | "status" | "created_at" | "updated_at", ExtArgs["result"]["branch"]>
  export type BranchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stalls?: boolean | Branch$stallsArgs<ExtArgs>
    employees?: boolean | Branch$employeesArgs<ExtArgs>
    floors?: boolean | Branch$floorsArgs<ExtArgs>
    sections?: boolean | Branch$sectionsArgs<ExtArgs>
    stallholders?: boolean | Branch$stallholdersArgs<ExtArgs>
    _count?: boolean | BranchCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $BranchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Branch"
    objects: {
      stalls: Prisma.$StallPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      floors: Prisma.$FloorPayload<ExtArgs>[]
      sections: Prisma.$SectionPayload<ExtArgs>[]
      stallholders: Prisma.$StallholderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      branch_id: number
      branch_name: string
      location: string | null
      address: string | null
      contact_number: string | null
      email: string | null
      description: string | null
      status: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["branch"]>
    composites: {}
  }

  type BranchGetPayload<S extends boolean | null | undefined | BranchDefaultArgs> = $Result.GetResult<Prisma.$BranchPayload, S>

  type BranchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BranchFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BranchCountAggregateInputType | true
    }

  export interface BranchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Branch'], meta: { name: 'Branch' } }
    /**
     * Find zero or one Branch that matches the filter.
     * @param {BranchFindUniqueArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BranchFindUniqueArgs>(args: SelectSubset<T, BranchFindUniqueArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Branch that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BranchFindUniqueOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BranchFindUniqueOrThrowArgs>(args: SelectSubset<T, BranchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BranchFindFirstArgs>(args?: SelectSubset<T, BranchFindFirstArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Branch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindFirstOrThrowArgs} args - Arguments to find a Branch
     * @example
     * // Get one Branch
     * const branch = await prisma.branch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BranchFindFirstOrThrowArgs>(args?: SelectSubset<T, BranchFindFirstOrThrowArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Branches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Branches
     * const branches = await prisma.branch.findMany()
     * 
     * // Get first 10 Branches
     * const branches = await prisma.branch.findMany({ take: 10 })
     * 
     * // Only select the `branch_id`
     * const branchWithBranch_idOnly = await prisma.branch.findMany({ select: { branch_id: true } })
     * 
     */
    findMany<T extends BranchFindManyArgs>(args?: SelectSubset<T, BranchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Branch.
     * @param {BranchCreateArgs} args - Arguments to create a Branch.
     * @example
     * // Create one Branch
     * const Branch = await prisma.branch.create({
     *   data: {
     *     // ... data to create a Branch
     *   }
     * })
     * 
     */
    create<T extends BranchCreateArgs>(args: SelectSubset<T, BranchCreateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Branches.
     * @param {BranchCreateManyArgs} args - Arguments to create many Branches.
     * @example
     * // Create many Branches
     * const branch = await prisma.branch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BranchCreateManyArgs>(args?: SelectSubset<T, BranchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Branch.
     * @param {BranchDeleteArgs} args - Arguments to delete one Branch.
     * @example
     * // Delete one Branch
     * const Branch = await prisma.branch.delete({
     *   where: {
     *     // ... filter to delete one Branch
     *   }
     * })
     * 
     */
    delete<T extends BranchDeleteArgs>(args: SelectSubset<T, BranchDeleteArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Branch.
     * @param {BranchUpdateArgs} args - Arguments to update one Branch.
     * @example
     * // Update one Branch
     * const branch = await prisma.branch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BranchUpdateArgs>(args: SelectSubset<T, BranchUpdateArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Branches.
     * @param {BranchDeleteManyArgs} args - Arguments to filter Branches to delete.
     * @example
     * // Delete a few Branches
     * const { count } = await prisma.branch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BranchDeleteManyArgs>(args?: SelectSubset<T, BranchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Branches
     * const branch = await prisma.branch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BranchUpdateManyArgs>(args: SelectSubset<T, BranchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Branch.
     * @param {BranchUpsertArgs} args - Arguments to update or create a Branch.
     * @example
     * // Update or create a Branch
     * const branch = await prisma.branch.upsert({
     *   create: {
     *     // ... data to create a Branch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Branch we want to update
     *   }
     * })
     */
    upsert<T extends BranchUpsertArgs>(args: SelectSubset<T, BranchUpsertArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Branches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchCountArgs} args - Arguments to filter Branches to count.
     * @example
     * // Count the number of Branches
     * const count = await prisma.branch.count({
     *   where: {
     *     // ... the filter for the Branches we want to count
     *   }
     * })
    **/
    count<T extends BranchCountArgs>(
      args?: Subset<T, BranchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BranchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BranchAggregateArgs>(args: Subset<T, BranchAggregateArgs>): Prisma.PrismaPromise<GetBranchAggregateType<T>>

    /**
     * Group by Branch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BranchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BranchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BranchGroupByArgs['orderBy'] }
        : { orderBy?: BranchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BranchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBranchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Branch model
   */
  readonly fields: BranchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Branch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BranchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stalls<T extends Branch$stallsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$stallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Branch$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Branch$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    floors<T extends Branch$floorsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$floorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FloorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sections<T extends Branch$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Branch$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stallholders<T extends Branch$stallholdersArgs<ExtArgs> = {}>(args?: Subset<T, Branch$stallholdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Branch model
   */
  interface BranchFieldRefs {
    readonly branch_id: FieldRef<"Branch", 'Int'>
    readonly branch_name: FieldRef<"Branch", 'String'>
    readonly location: FieldRef<"Branch", 'String'>
    readonly address: FieldRef<"Branch", 'String'>
    readonly contact_number: FieldRef<"Branch", 'String'>
    readonly email: FieldRef<"Branch", 'String'>
    readonly description: FieldRef<"Branch", 'String'>
    readonly status: FieldRef<"Branch", 'String'>
    readonly created_at: FieldRef<"Branch", 'DateTime'>
    readonly updated_at: FieldRef<"Branch", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Branch findUnique
   */
  export type BranchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findUniqueOrThrow
   */
  export type BranchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch findFirst
   */
  export type BranchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findFirstOrThrow
   */
  export type BranchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branch to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Branches.
     */
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch findMany
   */
  export type BranchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter, which Branches to fetch.
     */
    where?: BranchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Branches to fetch.
     */
    orderBy?: BranchOrderByWithRelationInput | BranchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Branches.
     */
    cursor?: BranchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Branches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Branches.
     */
    skip?: number
    distinct?: BranchScalarFieldEnum | BranchScalarFieldEnum[]
  }

  /**
   * Branch create
   */
  export type BranchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to create a Branch.
     */
    data: XOR<BranchCreateInput, BranchUncheckedCreateInput>
  }

  /**
   * Branch createMany
   */
  export type BranchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Branches.
     */
    data: BranchCreateManyInput | BranchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Branch update
   */
  export type BranchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The data needed to update a Branch.
     */
    data: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
    /**
     * Choose, which Branch to update.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch updateMany
   */
  export type BranchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Branches.
     */
    data: XOR<BranchUpdateManyMutationInput, BranchUncheckedUpdateManyInput>
    /**
     * Filter which Branches to update
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to update.
     */
    limit?: number
  }

  /**
   * Branch upsert
   */
  export type BranchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * The filter to search for the Branch to update in case it exists.
     */
    where: BranchWhereUniqueInput
    /**
     * In case the Branch found by the `where` argument doesn't exist, create a new Branch with this data.
     */
    create: XOR<BranchCreateInput, BranchUncheckedCreateInput>
    /**
     * In case the Branch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BranchUpdateInput, BranchUncheckedUpdateInput>
  }

  /**
   * Branch delete
   */
  export type BranchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    /**
     * Filter which Branch to delete.
     */
    where: BranchWhereUniqueInput
  }

  /**
   * Branch deleteMany
   */
  export type BranchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Branches to delete
     */
    where?: BranchWhereInput
    /**
     * Limit how many Branches to delete.
     */
    limit?: number
  }

  /**
   * Branch.stalls
   */
  export type Branch$stallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    where?: StallWhereInput
    orderBy?: StallOrderByWithRelationInput | StallOrderByWithRelationInput[]
    cursor?: StallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StallScalarFieldEnum | StallScalarFieldEnum[]
  }

  /**
   * Branch.employees
   */
  export type Branch$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Branch.floors
   */
  export type Branch$floorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
    where?: FloorWhereInput
    orderBy?: FloorOrderByWithRelationInput | FloorOrderByWithRelationInput[]
    cursor?: FloorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FloorScalarFieldEnum | FloorScalarFieldEnum[]
  }

  /**
   * Branch.sections
   */
  export type Branch$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Branch.stallholders
   */
  export type Branch$stallholdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    where?: StallholderWhereInput
    orderBy?: StallholderOrderByWithRelationInput | StallholderOrderByWithRelationInput[]
    cursor?: StallholderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StallholderScalarFieldEnum | StallholderScalarFieldEnum[]
  }

  /**
   * Branch without action
   */
  export type BranchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
  }


  /**
   * Model Floor
   */

  export type AggregateFloor = {
    _count: FloorCountAggregateOutputType | null
    _avg: FloorAvgAggregateOutputType | null
    _sum: FloorSumAggregateOutputType | null
    _min: FloorMinAggregateOutputType | null
    _max: FloorMaxAggregateOutputType | null
  }

  export type FloorAvgAggregateOutputType = {
    floor_id: number | null
    branch_id: number | null
    floor_number: number | null
  }

  export type FloorSumAggregateOutputType = {
    floor_id: number | null
    branch_id: number | null
    floor_number: number | null
  }

  export type FloorMinAggregateOutputType = {
    floor_id: number | null
    branch_id: number | null
    floor_name: string | null
    floor_number: number | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FloorMaxAggregateOutputType = {
    floor_id: number | null
    branch_id: number | null
    floor_name: string | null
    floor_number: number | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type FloorCountAggregateOutputType = {
    floor_id: number
    branch_id: number
    floor_name: number
    floor_number: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type FloorAvgAggregateInputType = {
    floor_id?: true
    branch_id?: true
    floor_number?: true
  }

  export type FloorSumAggregateInputType = {
    floor_id?: true
    branch_id?: true
    floor_number?: true
  }

  export type FloorMinAggregateInputType = {
    floor_id?: true
    branch_id?: true
    floor_name?: true
    floor_number?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type FloorMaxAggregateInputType = {
    floor_id?: true
    branch_id?: true
    floor_name?: true
    floor_number?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type FloorCountAggregateInputType = {
    floor_id?: true
    branch_id?: true
    floor_name?: true
    floor_number?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type FloorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Floor to aggregate.
     */
    where?: FloorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Floors to fetch.
     */
    orderBy?: FloorOrderByWithRelationInput | FloorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FloorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Floors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Floors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Floors
    **/
    _count?: true | FloorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FloorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FloorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FloorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FloorMaxAggregateInputType
  }

  export type GetFloorAggregateType<T extends FloorAggregateArgs> = {
        [P in keyof T & keyof AggregateFloor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFloor[P]>
      : GetScalarType<T[P], AggregateFloor[P]>
  }




  export type FloorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FloorWhereInput
    orderBy?: FloorOrderByWithAggregationInput | FloorOrderByWithAggregationInput[]
    by: FloorScalarFieldEnum[] | FloorScalarFieldEnum
    having?: FloorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FloorCountAggregateInputType | true
    _avg?: FloorAvgAggregateInputType
    _sum?: FloorSumAggregateInputType
    _min?: FloorMinAggregateInputType
    _max?: FloorMaxAggregateInputType
  }

  export type FloorGroupByOutputType = {
    floor_id: number
    branch_id: number
    floor_name: string
    floor_number: number
    description: string | null
    created_at: Date
    updated_at: Date
    _count: FloorCountAggregateOutputType | null
    _avg: FloorAvgAggregateOutputType | null
    _sum: FloorSumAggregateOutputType | null
    _min: FloorMinAggregateOutputType | null
    _max: FloorMaxAggregateOutputType | null
  }

  type GetFloorGroupByPayload<T extends FloorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FloorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FloorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FloorGroupByOutputType[P]>
            : GetScalarType<T[P], FloorGroupByOutputType[P]>
        }
      >
    >


  export type FloorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    floor_id?: boolean
    branch_id?: boolean
    floor_name?: boolean
    floor_number?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    stalls?: boolean | Floor$stallsArgs<ExtArgs>
    sections?: boolean | Floor$sectionsArgs<ExtArgs>
    _count?: boolean | FloorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["floor"]>



  export type FloorSelectScalar = {
    floor_id?: boolean
    branch_id?: boolean
    floor_name?: boolean
    floor_number?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type FloorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"floor_id" | "branch_id" | "floor_name" | "floor_number" | "description" | "created_at" | "updated_at", ExtArgs["result"]["floor"]>
  export type FloorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    stalls?: boolean | Floor$stallsArgs<ExtArgs>
    sections?: boolean | Floor$sectionsArgs<ExtArgs>
    _count?: boolean | FloorCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $FloorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Floor"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      stalls: Prisma.$StallPayload<ExtArgs>[]
      sections: Prisma.$SectionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      floor_id: number
      branch_id: number
      floor_name: string
      floor_number: number
      description: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["floor"]>
    composites: {}
  }

  type FloorGetPayload<S extends boolean | null | undefined | FloorDefaultArgs> = $Result.GetResult<Prisma.$FloorPayload, S>

  type FloorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FloorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FloorCountAggregateInputType | true
    }

  export interface FloorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Floor'], meta: { name: 'Floor' } }
    /**
     * Find zero or one Floor that matches the filter.
     * @param {FloorFindUniqueArgs} args - Arguments to find a Floor
     * @example
     * // Get one Floor
     * const floor = await prisma.floor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FloorFindUniqueArgs>(args: SelectSubset<T, FloorFindUniqueArgs<ExtArgs>>): Prisma__FloorClient<$Result.GetResult<Prisma.$FloorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Floor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FloorFindUniqueOrThrowArgs} args - Arguments to find a Floor
     * @example
     * // Get one Floor
     * const floor = await prisma.floor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FloorFindUniqueOrThrowArgs>(args: SelectSubset<T, FloorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FloorClient<$Result.GetResult<Prisma.$FloorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Floor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorFindFirstArgs} args - Arguments to find a Floor
     * @example
     * // Get one Floor
     * const floor = await prisma.floor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FloorFindFirstArgs>(args?: SelectSubset<T, FloorFindFirstArgs<ExtArgs>>): Prisma__FloorClient<$Result.GetResult<Prisma.$FloorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Floor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorFindFirstOrThrowArgs} args - Arguments to find a Floor
     * @example
     * // Get one Floor
     * const floor = await prisma.floor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FloorFindFirstOrThrowArgs>(args?: SelectSubset<T, FloorFindFirstOrThrowArgs<ExtArgs>>): Prisma__FloorClient<$Result.GetResult<Prisma.$FloorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Floors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Floors
     * const floors = await prisma.floor.findMany()
     * 
     * // Get first 10 Floors
     * const floors = await prisma.floor.findMany({ take: 10 })
     * 
     * // Only select the `floor_id`
     * const floorWithFloor_idOnly = await prisma.floor.findMany({ select: { floor_id: true } })
     * 
     */
    findMany<T extends FloorFindManyArgs>(args?: SelectSubset<T, FloorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FloorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Floor.
     * @param {FloorCreateArgs} args - Arguments to create a Floor.
     * @example
     * // Create one Floor
     * const Floor = await prisma.floor.create({
     *   data: {
     *     // ... data to create a Floor
     *   }
     * })
     * 
     */
    create<T extends FloorCreateArgs>(args: SelectSubset<T, FloorCreateArgs<ExtArgs>>): Prisma__FloorClient<$Result.GetResult<Prisma.$FloorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Floors.
     * @param {FloorCreateManyArgs} args - Arguments to create many Floors.
     * @example
     * // Create many Floors
     * const floor = await prisma.floor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FloorCreateManyArgs>(args?: SelectSubset<T, FloorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Floor.
     * @param {FloorDeleteArgs} args - Arguments to delete one Floor.
     * @example
     * // Delete one Floor
     * const Floor = await prisma.floor.delete({
     *   where: {
     *     // ... filter to delete one Floor
     *   }
     * })
     * 
     */
    delete<T extends FloorDeleteArgs>(args: SelectSubset<T, FloorDeleteArgs<ExtArgs>>): Prisma__FloorClient<$Result.GetResult<Prisma.$FloorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Floor.
     * @param {FloorUpdateArgs} args - Arguments to update one Floor.
     * @example
     * // Update one Floor
     * const floor = await prisma.floor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FloorUpdateArgs>(args: SelectSubset<T, FloorUpdateArgs<ExtArgs>>): Prisma__FloorClient<$Result.GetResult<Prisma.$FloorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Floors.
     * @param {FloorDeleteManyArgs} args - Arguments to filter Floors to delete.
     * @example
     * // Delete a few Floors
     * const { count } = await prisma.floor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FloorDeleteManyArgs>(args?: SelectSubset<T, FloorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Floors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Floors
     * const floor = await prisma.floor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FloorUpdateManyArgs>(args: SelectSubset<T, FloorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Floor.
     * @param {FloorUpsertArgs} args - Arguments to update or create a Floor.
     * @example
     * // Update or create a Floor
     * const floor = await prisma.floor.upsert({
     *   create: {
     *     // ... data to create a Floor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Floor we want to update
     *   }
     * })
     */
    upsert<T extends FloorUpsertArgs>(args: SelectSubset<T, FloorUpsertArgs<ExtArgs>>): Prisma__FloorClient<$Result.GetResult<Prisma.$FloorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Floors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorCountArgs} args - Arguments to filter Floors to count.
     * @example
     * // Count the number of Floors
     * const count = await prisma.floor.count({
     *   where: {
     *     // ... the filter for the Floors we want to count
     *   }
     * })
    **/
    count<T extends FloorCountArgs>(
      args?: Subset<T, FloorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FloorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Floor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FloorAggregateArgs>(args: Subset<T, FloorAggregateArgs>): Prisma.PrismaPromise<GetFloorAggregateType<T>>

    /**
     * Group by Floor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FloorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FloorGroupByArgs['orderBy'] }
        : { orderBy?: FloorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FloorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFloorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Floor model
   */
  readonly fields: FloorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Floor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FloorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stalls<T extends Floor$stallsArgs<ExtArgs> = {}>(args?: Subset<T, Floor$stallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sections<T extends Floor$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, Floor$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Floor model
   */
  interface FloorFieldRefs {
    readonly floor_id: FieldRef<"Floor", 'Int'>
    readonly branch_id: FieldRef<"Floor", 'Int'>
    readonly floor_name: FieldRef<"Floor", 'String'>
    readonly floor_number: FieldRef<"Floor", 'Int'>
    readonly description: FieldRef<"Floor", 'String'>
    readonly created_at: FieldRef<"Floor", 'DateTime'>
    readonly updated_at: FieldRef<"Floor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Floor findUnique
   */
  export type FloorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
    /**
     * Filter, which Floor to fetch.
     */
    where: FloorWhereUniqueInput
  }

  /**
   * Floor findUniqueOrThrow
   */
  export type FloorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
    /**
     * Filter, which Floor to fetch.
     */
    where: FloorWhereUniqueInput
  }

  /**
   * Floor findFirst
   */
  export type FloorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
    /**
     * Filter, which Floor to fetch.
     */
    where?: FloorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Floors to fetch.
     */
    orderBy?: FloorOrderByWithRelationInput | FloorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Floors.
     */
    cursor?: FloorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Floors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Floors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Floors.
     */
    distinct?: FloorScalarFieldEnum | FloorScalarFieldEnum[]
  }

  /**
   * Floor findFirstOrThrow
   */
  export type FloorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
    /**
     * Filter, which Floor to fetch.
     */
    where?: FloorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Floors to fetch.
     */
    orderBy?: FloorOrderByWithRelationInput | FloorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Floors.
     */
    cursor?: FloorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Floors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Floors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Floors.
     */
    distinct?: FloorScalarFieldEnum | FloorScalarFieldEnum[]
  }

  /**
   * Floor findMany
   */
  export type FloorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
    /**
     * Filter, which Floors to fetch.
     */
    where?: FloorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Floors to fetch.
     */
    orderBy?: FloorOrderByWithRelationInput | FloorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Floors.
     */
    cursor?: FloorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Floors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Floors.
     */
    skip?: number
    distinct?: FloorScalarFieldEnum | FloorScalarFieldEnum[]
  }

  /**
   * Floor create
   */
  export type FloorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
    /**
     * The data needed to create a Floor.
     */
    data: XOR<FloorCreateInput, FloorUncheckedCreateInput>
  }

  /**
   * Floor createMany
   */
  export type FloorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Floors.
     */
    data: FloorCreateManyInput | FloorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Floor update
   */
  export type FloorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
    /**
     * The data needed to update a Floor.
     */
    data: XOR<FloorUpdateInput, FloorUncheckedUpdateInput>
    /**
     * Choose, which Floor to update.
     */
    where: FloorWhereUniqueInput
  }

  /**
   * Floor updateMany
   */
  export type FloorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Floors.
     */
    data: XOR<FloorUpdateManyMutationInput, FloorUncheckedUpdateManyInput>
    /**
     * Filter which Floors to update
     */
    where?: FloorWhereInput
    /**
     * Limit how many Floors to update.
     */
    limit?: number
  }

  /**
   * Floor upsert
   */
  export type FloorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
    /**
     * The filter to search for the Floor to update in case it exists.
     */
    where: FloorWhereUniqueInput
    /**
     * In case the Floor found by the `where` argument doesn't exist, create a new Floor with this data.
     */
    create: XOR<FloorCreateInput, FloorUncheckedCreateInput>
    /**
     * In case the Floor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FloorUpdateInput, FloorUncheckedUpdateInput>
  }

  /**
   * Floor delete
   */
  export type FloorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
    /**
     * Filter which Floor to delete.
     */
    where: FloorWhereUniqueInput
  }

  /**
   * Floor deleteMany
   */
  export type FloorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Floors to delete
     */
    where?: FloorWhereInput
    /**
     * Limit how many Floors to delete.
     */
    limit?: number
  }

  /**
   * Floor.stalls
   */
  export type Floor$stallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    where?: StallWhereInput
    orderBy?: StallOrderByWithRelationInput | StallOrderByWithRelationInput[]
    cursor?: StallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StallScalarFieldEnum | StallScalarFieldEnum[]
  }

  /**
   * Floor.sections
   */
  export type Floor$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    cursor?: SectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Floor without action
   */
  export type FloorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
  }


  /**
   * Model Section
   */

  export type AggregateSection = {
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  export type SectionAvgAggregateOutputType = {
    section_id: number | null
    branch_id: number | null
    floor_id: number | null
  }

  export type SectionSumAggregateOutputType = {
    section_id: number | null
    branch_id: number | null
    floor_id: number | null
  }

  export type SectionMinAggregateOutputType = {
    section_id: number | null
    branch_id: number | null
    floor_id: number | null
    section_name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SectionMaxAggregateOutputType = {
    section_id: number | null
    branch_id: number | null
    floor_id: number | null
    section_name: string | null
    description: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SectionCountAggregateOutputType = {
    section_id: number
    branch_id: number
    floor_id: number
    section_name: number
    description: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SectionAvgAggregateInputType = {
    section_id?: true
    branch_id?: true
    floor_id?: true
  }

  export type SectionSumAggregateInputType = {
    section_id?: true
    branch_id?: true
    floor_id?: true
  }

  export type SectionMinAggregateInputType = {
    section_id?: true
    branch_id?: true
    floor_id?: true
    section_name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type SectionMaxAggregateInputType = {
    section_id?: true
    branch_id?: true
    floor_id?: true
    section_name?: true
    description?: true
    created_at?: true
    updated_at?: true
  }

  export type SectionCountAggregateInputType = {
    section_id?: true
    branch_id?: true
    floor_id?: true
    section_name?: true
    description?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Section to aggregate.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sections
    **/
    _count?: true | SectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionMaxAggregateInputType
  }

  export type GetSectionAggregateType<T extends SectionAggregateArgs> = {
        [P in keyof T & keyof AggregateSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSection[P]>
      : GetScalarType<T[P], AggregateSection[P]>
  }




  export type SectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionWhereInput
    orderBy?: SectionOrderByWithAggregationInput | SectionOrderByWithAggregationInput[]
    by: SectionScalarFieldEnum[] | SectionScalarFieldEnum
    having?: SectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionCountAggregateInputType | true
    _avg?: SectionAvgAggregateInputType
    _sum?: SectionSumAggregateInputType
    _min?: SectionMinAggregateInputType
    _max?: SectionMaxAggregateInputType
  }

  export type SectionGroupByOutputType = {
    section_id: number
    branch_id: number
    floor_id: number | null
    section_name: string
    description: string | null
    created_at: Date
    updated_at: Date
    _count: SectionCountAggregateOutputType | null
    _avg: SectionAvgAggregateOutputType | null
    _sum: SectionSumAggregateOutputType | null
    _min: SectionMinAggregateOutputType | null
    _max: SectionMaxAggregateOutputType | null
  }

  type GetSectionGroupByPayload<T extends SectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionGroupByOutputType[P]>
            : GetScalarType<T[P], SectionGroupByOutputType[P]>
        }
      >
    >


  export type SectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    section_id?: boolean
    branch_id?: boolean
    floor_id?: boolean
    section_name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    floor?: boolean | Section$floorArgs<ExtArgs>
    stalls?: boolean | Section$stallsArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["section"]>



  export type SectionSelectScalar = {
    section_id?: boolean
    branch_id?: boolean
    floor_id?: boolean
    section_name?: boolean
    description?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"section_id" | "branch_id" | "floor_id" | "section_name" | "description" | "created_at" | "updated_at", ExtArgs["result"]["section"]>
  export type SectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    floor?: boolean | Section$floorArgs<ExtArgs>
    stalls?: boolean | Section$stallsArgs<ExtArgs>
    _count?: boolean | SectionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Section"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      floor: Prisma.$FloorPayload<ExtArgs> | null
      stalls: Prisma.$StallPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      section_id: number
      branch_id: number
      floor_id: number | null
      section_name: string
      description: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["section"]>
    composites: {}
  }

  type SectionGetPayload<S extends boolean | null | undefined | SectionDefaultArgs> = $Result.GetResult<Prisma.$SectionPayload, S>

  type SectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SectionCountAggregateInputType | true
    }

  export interface SectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Section'], meta: { name: 'Section' } }
    /**
     * Find zero or one Section that matches the filter.
     * @param {SectionFindUniqueArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionFindUniqueArgs>(args: SelectSubset<T, SectionFindUniqueArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Section that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SectionFindUniqueOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionFindFirstArgs>(args?: SelectSubset<T, SectionFindFirstArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Section that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindFirstOrThrowArgs} args - Arguments to find a Section
     * @example
     * // Get one Section
     * const section = await prisma.section.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sections
     * const sections = await prisma.section.findMany()
     * 
     * // Get first 10 Sections
     * const sections = await prisma.section.findMany({ take: 10 })
     * 
     * // Only select the `section_id`
     * const sectionWithSection_idOnly = await prisma.section.findMany({ select: { section_id: true } })
     * 
     */
    findMany<T extends SectionFindManyArgs>(args?: SelectSubset<T, SectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Section.
     * @param {SectionCreateArgs} args - Arguments to create a Section.
     * @example
     * // Create one Section
     * const Section = await prisma.section.create({
     *   data: {
     *     // ... data to create a Section
     *   }
     * })
     * 
     */
    create<T extends SectionCreateArgs>(args: SelectSubset<T, SectionCreateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sections.
     * @param {SectionCreateManyArgs} args - Arguments to create many Sections.
     * @example
     * // Create many Sections
     * const section = await prisma.section.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionCreateManyArgs>(args?: SelectSubset<T, SectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Section.
     * @param {SectionDeleteArgs} args - Arguments to delete one Section.
     * @example
     * // Delete one Section
     * const Section = await prisma.section.delete({
     *   where: {
     *     // ... filter to delete one Section
     *   }
     * })
     * 
     */
    delete<T extends SectionDeleteArgs>(args: SelectSubset<T, SectionDeleteArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Section.
     * @param {SectionUpdateArgs} args - Arguments to update one Section.
     * @example
     * // Update one Section
     * const section = await prisma.section.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionUpdateArgs>(args: SelectSubset<T, SectionUpdateArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sections.
     * @param {SectionDeleteManyArgs} args - Arguments to filter Sections to delete.
     * @example
     * // Delete a few Sections
     * const { count } = await prisma.section.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionDeleteManyArgs>(args?: SelectSubset<T, SectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sections
     * const section = await prisma.section.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionUpdateManyArgs>(args: SelectSubset<T, SectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Section.
     * @param {SectionUpsertArgs} args - Arguments to update or create a Section.
     * @example
     * // Update or create a Section
     * const section = await prisma.section.upsert({
     *   create: {
     *     // ... data to create a Section
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Section we want to update
     *   }
     * })
     */
    upsert<T extends SectionUpsertArgs>(args: SelectSubset<T, SectionUpsertArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionCountArgs} args - Arguments to filter Sections to count.
     * @example
     * // Count the number of Sections
     * const count = await prisma.section.count({
     *   where: {
     *     // ... the filter for the Sections we want to count
     *   }
     * })
    **/
    count<T extends SectionCountArgs>(
      args?: Subset<T, SectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionAggregateArgs>(args: Subset<T, SectionAggregateArgs>): Prisma.PrismaPromise<GetSectionAggregateType<T>>

    /**
     * Group by Section.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionGroupByArgs['orderBy'] }
        : { orderBy?: SectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Section model
   */
  readonly fields: SectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Section.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    floor<T extends Section$floorArgs<ExtArgs> = {}>(args?: Subset<T, Section$floorArgs<ExtArgs>>): Prisma__FloorClient<$Result.GetResult<Prisma.$FloorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stalls<T extends Section$stallsArgs<ExtArgs> = {}>(args?: Subset<T, Section$stallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Section model
   */
  interface SectionFieldRefs {
    readonly section_id: FieldRef<"Section", 'Int'>
    readonly branch_id: FieldRef<"Section", 'Int'>
    readonly floor_id: FieldRef<"Section", 'Int'>
    readonly section_name: FieldRef<"Section", 'String'>
    readonly description: FieldRef<"Section", 'String'>
    readonly created_at: FieldRef<"Section", 'DateTime'>
    readonly updated_at: FieldRef<"Section", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Section findUnique
   */
  export type SectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findUniqueOrThrow
   */
  export type SectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section findFirst
   */
  export type SectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findFirstOrThrow
   */
  export type SectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Section to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sections.
     */
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section findMany
   */
  export type SectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter, which Sections to fetch.
     */
    where?: SectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sections to fetch.
     */
    orderBy?: SectionOrderByWithRelationInput | SectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sections.
     */
    cursor?: SectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sections.
     */
    skip?: number
    distinct?: SectionScalarFieldEnum | SectionScalarFieldEnum[]
  }

  /**
   * Section create
   */
  export type SectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to create a Section.
     */
    data: XOR<SectionCreateInput, SectionUncheckedCreateInput>
  }

  /**
   * Section createMany
   */
  export type SectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sections.
     */
    data: SectionCreateManyInput | SectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Section update
   */
  export type SectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The data needed to update a Section.
     */
    data: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
    /**
     * Choose, which Section to update.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section updateMany
   */
  export type SectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sections.
     */
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyInput>
    /**
     * Filter which Sections to update
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to update.
     */
    limit?: number
  }

  /**
   * Section upsert
   */
  export type SectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * The filter to search for the Section to update in case it exists.
     */
    where: SectionWhereUniqueInput
    /**
     * In case the Section found by the `where` argument doesn't exist, create a new Section with this data.
     */
    create: XOR<SectionCreateInput, SectionUncheckedCreateInput>
    /**
     * In case the Section was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionUpdateInput, SectionUncheckedUpdateInput>
  }

  /**
   * Section delete
   */
  export type SectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    /**
     * Filter which Section to delete.
     */
    where: SectionWhereUniqueInput
  }

  /**
   * Section deleteMany
   */
  export type SectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sections to delete
     */
    where?: SectionWhereInput
    /**
     * Limit how many Sections to delete.
     */
    limit?: number
  }

  /**
   * Section.floor
   */
  export type Section$floorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
    where?: FloorWhereInput
  }

  /**
   * Section.stalls
   */
  export type Section$stallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    where?: StallWhereInput
    orderBy?: StallOrderByWithRelationInput | StallOrderByWithRelationInput[]
    cursor?: StallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StallScalarFieldEnum | StallScalarFieldEnum[]
  }

  /**
   * Section without action
   */
  export type SectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
  }


  /**
   * Model Stall
   */

  export type AggregateStall = {
    _count: StallCountAggregateOutputType | null
    _avg: StallAvgAggregateOutputType | null
    _sum: StallSumAggregateOutputType | null
    _min: StallMinAggregateOutputType | null
    _max: StallMaxAggregateOutputType | null
  }

  export type StallAvgAggregateOutputType = {
    stall_id: number | null
    area_sqm: Decimal | null
    floor_id: number | null
    section_id: number | null
    monthly_rent: Decimal | null
    rental_price: Decimal | null
    branch_id: number | null
    stallholder_id: number | null
    base_rate: Decimal | null
    rate_per_sqm: Decimal | null
  }

  export type StallSumAggregateOutputType = {
    stall_id: number | null
    area_sqm: Decimal | null
    floor_id: number | null
    section_id: number | null
    monthly_rent: Decimal | null
    rental_price: Decimal | null
    branch_id: number | null
    stallholder_id: number | null
    base_rate: Decimal | null
    rate_per_sqm: Decimal | null
  }

  export type StallMinAggregateOutputType = {
    stall_id: number | null
    stall_number: string | null
    stall_name: string | null
    stall_type: string | null
    stall_size: string | null
    stall_location: string | null
    size: string | null
    area_sqm: Decimal | null
    floor_id: number | null
    section_id: number | null
    monthly_rent: Decimal | null
    rental_price: Decimal | null
    status: string | null
    branch_id: number | null
    stallholder_id: number | null
    floor_level: string | null
    section: string | null
    description: string | null
    price_type: string | null
    is_available: boolean | null
    base_rate: Decimal | null
    rate_per_sqm: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StallMaxAggregateOutputType = {
    stall_id: number | null
    stall_number: string | null
    stall_name: string | null
    stall_type: string | null
    stall_size: string | null
    stall_location: string | null
    size: string | null
    area_sqm: Decimal | null
    floor_id: number | null
    section_id: number | null
    monthly_rent: Decimal | null
    rental_price: Decimal | null
    status: string | null
    branch_id: number | null
    stallholder_id: number | null
    floor_level: string | null
    section: string | null
    description: string | null
    price_type: string | null
    is_available: boolean | null
    base_rate: Decimal | null
    rate_per_sqm: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StallCountAggregateOutputType = {
    stall_id: number
    stall_number: number
    stall_name: number
    stall_type: number
    stall_size: number
    stall_location: number
    size: number
    area_sqm: number
    floor_id: number
    section_id: number
    monthly_rent: number
    rental_price: number
    status: number
    branch_id: number
    stallholder_id: number
    floor_level: number
    section: number
    description: number
    price_type: number
    is_available: number
    base_rate: number
    rate_per_sqm: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StallAvgAggregateInputType = {
    stall_id?: true
    area_sqm?: true
    floor_id?: true
    section_id?: true
    monthly_rent?: true
    rental_price?: true
    branch_id?: true
    stallholder_id?: true
    base_rate?: true
    rate_per_sqm?: true
  }

  export type StallSumAggregateInputType = {
    stall_id?: true
    area_sqm?: true
    floor_id?: true
    section_id?: true
    monthly_rent?: true
    rental_price?: true
    branch_id?: true
    stallholder_id?: true
    base_rate?: true
    rate_per_sqm?: true
  }

  export type StallMinAggregateInputType = {
    stall_id?: true
    stall_number?: true
    stall_name?: true
    stall_type?: true
    stall_size?: true
    stall_location?: true
    size?: true
    area_sqm?: true
    floor_id?: true
    section_id?: true
    monthly_rent?: true
    rental_price?: true
    status?: true
    branch_id?: true
    stallholder_id?: true
    floor_level?: true
    section?: true
    description?: true
    price_type?: true
    is_available?: true
    base_rate?: true
    rate_per_sqm?: true
    created_at?: true
    updated_at?: true
  }

  export type StallMaxAggregateInputType = {
    stall_id?: true
    stall_number?: true
    stall_name?: true
    stall_type?: true
    stall_size?: true
    stall_location?: true
    size?: true
    area_sqm?: true
    floor_id?: true
    section_id?: true
    monthly_rent?: true
    rental_price?: true
    status?: true
    branch_id?: true
    stallholder_id?: true
    floor_level?: true
    section?: true
    description?: true
    price_type?: true
    is_available?: true
    base_rate?: true
    rate_per_sqm?: true
    created_at?: true
    updated_at?: true
  }

  export type StallCountAggregateInputType = {
    stall_id?: true
    stall_number?: true
    stall_name?: true
    stall_type?: true
    stall_size?: true
    stall_location?: true
    size?: true
    area_sqm?: true
    floor_id?: true
    section_id?: true
    monthly_rent?: true
    rental_price?: true
    status?: true
    branch_id?: true
    stallholder_id?: true
    floor_level?: true
    section?: true
    description?: true
    price_type?: true
    is_available?: true
    base_rate?: true
    rate_per_sqm?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StallAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stall to aggregate.
     */
    where?: StallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stalls to fetch.
     */
    orderBy?: StallOrderByWithRelationInput | StallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stalls
    **/
    _count?: true | StallCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StallAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StallSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StallMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StallMaxAggregateInputType
  }

  export type GetStallAggregateType<T extends StallAggregateArgs> = {
        [P in keyof T & keyof AggregateStall]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStall[P]>
      : GetScalarType<T[P], AggregateStall[P]>
  }




  export type StallGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StallWhereInput
    orderBy?: StallOrderByWithAggregationInput | StallOrderByWithAggregationInput[]
    by: StallScalarFieldEnum[] | StallScalarFieldEnum
    having?: StallScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StallCountAggregateInputType | true
    _avg?: StallAvgAggregateInputType
    _sum?: StallSumAggregateInputType
    _min?: StallMinAggregateInputType
    _max?: StallMaxAggregateInputType
  }

  export type StallGroupByOutputType = {
    stall_id: number
    stall_number: string | null
    stall_name: string | null
    stall_type: string | null
    stall_size: string | null
    stall_location: string | null
    size: string | null
    area_sqm: Decimal | null
    floor_id: number | null
    section_id: number | null
    monthly_rent: Decimal | null
    rental_price: Decimal | null
    status: string
    branch_id: number
    stallholder_id: number | null
    floor_level: string | null
    section: string | null
    description: string | null
    price_type: string | null
    is_available: boolean
    base_rate: Decimal | null
    rate_per_sqm: Decimal | null
    created_at: Date
    updated_at: Date
    _count: StallCountAggregateOutputType | null
    _avg: StallAvgAggregateOutputType | null
    _sum: StallSumAggregateOutputType | null
    _min: StallMinAggregateOutputType | null
    _max: StallMaxAggregateOutputType | null
  }

  type GetStallGroupByPayload<T extends StallGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StallGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StallGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StallGroupByOutputType[P]>
            : GetScalarType<T[P], StallGroupByOutputType[P]>
        }
      >
    >


  export type StallSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stall_id?: boolean
    stall_number?: boolean
    stall_name?: boolean
    stall_type?: boolean
    stall_size?: boolean
    stall_location?: boolean
    size?: boolean
    area_sqm?: boolean
    floor_id?: boolean
    section_id?: boolean
    monthly_rent?: boolean
    rental_price?: boolean
    status?: boolean
    branch_id?: boolean
    stallholder_id?: boolean
    floor_level?: boolean
    section?: boolean
    description?: boolean
    price_type?: boolean
    is_available?: boolean
    base_rate?: boolean
    rate_per_sqm?: boolean
    created_at?: boolean
    updated_at?: boolean
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    floor?: boolean | Stall$floorArgs<ExtArgs>
    sectionRef?: boolean | Stall$sectionRefArgs<ExtArgs>
    stallholder?: boolean | Stall$stallholderArgs<ExtArgs>
    images?: boolean | Stall$imagesArgs<ExtArgs>
    payments?: boolean | Stall$paymentsArgs<ExtArgs>
    compliances?: boolean | Stall$compliancesArgs<ExtArgs>
    complaints?: boolean | Stall$complaintsArgs<ExtArgs>
    vendors?: boolean | Stall$vendorsArgs<ExtArgs>
    _count?: boolean | StallCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stall"]>



  export type StallSelectScalar = {
    stall_id?: boolean
    stall_number?: boolean
    stall_name?: boolean
    stall_type?: boolean
    stall_size?: boolean
    stall_location?: boolean
    size?: boolean
    area_sqm?: boolean
    floor_id?: boolean
    section_id?: boolean
    monthly_rent?: boolean
    rental_price?: boolean
    status?: boolean
    branch_id?: boolean
    stallholder_id?: boolean
    floor_level?: boolean
    section?: boolean
    description?: boolean
    price_type?: boolean
    is_available?: boolean
    base_rate?: boolean
    rate_per_sqm?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StallOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"stall_id" | "stall_number" | "stall_name" | "stall_type" | "stall_size" | "stall_location" | "size" | "area_sqm" | "floor_id" | "section_id" | "monthly_rent" | "rental_price" | "status" | "branch_id" | "stallholder_id" | "floor_level" | "section" | "description" | "price_type" | "is_available" | "base_rate" | "rate_per_sqm" | "created_at" | "updated_at", ExtArgs["result"]["stall"]>
  export type StallInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | BranchDefaultArgs<ExtArgs>
    floor?: boolean | Stall$floorArgs<ExtArgs>
    sectionRef?: boolean | Stall$sectionRefArgs<ExtArgs>
    stallholder?: boolean | Stall$stallholderArgs<ExtArgs>
    images?: boolean | Stall$imagesArgs<ExtArgs>
    payments?: boolean | Stall$paymentsArgs<ExtArgs>
    compliances?: boolean | Stall$compliancesArgs<ExtArgs>
    complaints?: boolean | Stall$complaintsArgs<ExtArgs>
    vendors?: boolean | Stall$vendorsArgs<ExtArgs>
    _count?: boolean | StallCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StallPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stall"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs>
      floor: Prisma.$FloorPayload<ExtArgs> | null
      sectionRef: Prisma.$SectionPayload<ExtArgs> | null
      stallholder: Prisma.$StallholderPayload<ExtArgs> | null
      images: Prisma.$StallImagePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      compliances: Prisma.$CompliancePayload<ExtArgs>[]
      complaints: Prisma.$ComplaintPayload<ExtArgs>[]
      vendors: Prisma.$VendorPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      stall_id: number
      stall_number: string | null
      stall_name: string | null
      stall_type: string | null
      stall_size: string | null
      stall_location: string | null
      size: string | null
      area_sqm: Prisma.Decimal | null
      floor_id: number | null
      section_id: number | null
      monthly_rent: Prisma.Decimal | null
      rental_price: Prisma.Decimal | null
      status: string
      branch_id: number
      stallholder_id: number | null
      floor_level: string | null
      section: string | null
      description: string | null
      price_type: string | null
      is_available: boolean
      base_rate: Prisma.Decimal | null
      rate_per_sqm: Prisma.Decimal | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["stall"]>
    composites: {}
  }

  type StallGetPayload<S extends boolean | null | undefined | StallDefaultArgs> = $Result.GetResult<Prisma.$StallPayload, S>

  type StallCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StallFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StallCountAggregateInputType | true
    }

  export interface StallDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stall'], meta: { name: 'Stall' } }
    /**
     * Find zero or one Stall that matches the filter.
     * @param {StallFindUniqueArgs} args - Arguments to find a Stall
     * @example
     * // Get one Stall
     * const stall = await prisma.stall.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StallFindUniqueArgs>(args: SelectSubset<T, StallFindUniqueArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stall that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StallFindUniqueOrThrowArgs} args - Arguments to find a Stall
     * @example
     * // Get one Stall
     * const stall = await prisma.stall.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StallFindUniqueOrThrowArgs>(args: SelectSubset<T, StallFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stall that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallFindFirstArgs} args - Arguments to find a Stall
     * @example
     * // Get one Stall
     * const stall = await prisma.stall.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StallFindFirstArgs>(args?: SelectSubset<T, StallFindFirstArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stall that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallFindFirstOrThrowArgs} args - Arguments to find a Stall
     * @example
     * // Get one Stall
     * const stall = await prisma.stall.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StallFindFirstOrThrowArgs>(args?: SelectSubset<T, StallFindFirstOrThrowArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stalls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stalls
     * const stalls = await prisma.stall.findMany()
     * 
     * // Get first 10 Stalls
     * const stalls = await prisma.stall.findMany({ take: 10 })
     * 
     * // Only select the `stall_id`
     * const stallWithStall_idOnly = await prisma.stall.findMany({ select: { stall_id: true } })
     * 
     */
    findMany<T extends StallFindManyArgs>(args?: SelectSubset<T, StallFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stall.
     * @param {StallCreateArgs} args - Arguments to create a Stall.
     * @example
     * // Create one Stall
     * const Stall = await prisma.stall.create({
     *   data: {
     *     // ... data to create a Stall
     *   }
     * })
     * 
     */
    create<T extends StallCreateArgs>(args: SelectSubset<T, StallCreateArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stalls.
     * @param {StallCreateManyArgs} args - Arguments to create many Stalls.
     * @example
     * // Create many Stalls
     * const stall = await prisma.stall.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StallCreateManyArgs>(args?: SelectSubset<T, StallCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stall.
     * @param {StallDeleteArgs} args - Arguments to delete one Stall.
     * @example
     * // Delete one Stall
     * const Stall = await prisma.stall.delete({
     *   where: {
     *     // ... filter to delete one Stall
     *   }
     * })
     * 
     */
    delete<T extends StallDeleteArgs>(args: SelectSubset<T, StallDeleteArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stall.
     * @param {StallUpdateArgs} args - Arguments to update one Stall.
     * @example
     * // Update one Stall
     * const stall = await prisma.stall.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StallUpdateArgs>(args: SelectSubset<T, StallUpdateArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stalls.
     * @param {StallDeleteManyArgs} args - Arguments to filter Stalls to delete.
     * @example
     * // Delete a few Stalls
     * const { count } = await prisma.stall.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StallDeleteManyArgs>(args?: SelectSubset<T, StallDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stalls
     * const stall = await prisma.stall.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StallUpdateManyArgs>(args: SelectSubset<T, StallUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stall.
     * @param {StallUpsertArgs} args - Arguments to update or create a Stall.
     * @example
     * // Update or create a Stall
     * const stall = await prisma.stall.upsert({
     *   create: {
     *     // ... data to create a Stall
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stall we want to update
     *   }
     * })
     */
    upsert<T extends StallUpsertArgs>(args: SelectSubset<T, StallUpsertArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stalls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallCountArgs} args - Arguments to filter Stalls to count.
     * @example
     * // Count the number of Stalls
     * const count = await prisma.stall.count({
     *   where: {
     *     // ... the filter for the Stalls we want to count
     *   }
     * })
    **/
    count<T extends StallCountArgs>(
      args?: Subset<T, StallCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StallCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StallAggregateArgs>(args: Subset<T, StallAggregateArgs>): Prisma.PrismaPromise<GetStallAggregateType<T>>

    /**
     * Group by Stall.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StallGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StallGroupByArgs['orderBy'] }
        : { orderBy?: StallGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StallGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStallGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stall model
   */
  readonly fields: StallFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stall.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StallClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends BranchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BranchDefaultArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    floor<T extends Stall$floorArgs<ExtArgs> = {}>(args?: Subset<T, Stall$floorArgs<ExtArgs>>): Prisma__FloorClient<$Result.GetResult<Prisma.$FloorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sectionRef<T extends Stall$sectionRefArgs<ExtArgs> = {}>(args?: Subset<T, Stall$sectionRefArgs<ExtArgs>>): Prisma__SectionClient<$Result.GetResult<Prisma.$SectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stallholder<T extends Stall$stallholderArgs<ExtArgs> = {}>(args?: Subset<T, Stall$stallholderArgs<ExtArgs>>): Prisma__StallholderClient<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    images<T extends Stall$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Stall$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StallImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Stall$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Stall$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    compliances<T extends Stall$compliancesArgs<ExtArgs> = {}>(args?: Subset<T, Stall$compliancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompliancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complaints<T extends Stall$complaintsArgs<ExtArgs> = {}>(args?: Subset<T, Stall$complaintsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendors<T extends Stall$vendorsArgs<ExtArgs> = {}>(args?: Subset<T, Stall$vendorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stall model
   */
  interface StallFieldRefs {
    readonly stall_id: FieldRef<"Stall", 'Int'>
    readonly stall_number: FieldRef<"Stall", 'String'>
    readonly stall_name: FieldRef<"Stall", 'String'>
    readonly stall_type: FieldRef<"Stall", 'String'>
    readonly stall_size: FieldRef<"Stall", 'String'>
    readonly stall_location: FieldRef<"Stall", 'String'>
    readonly size: FieldRef<"Stall", 'String'>
    readonly area_sqm: FieldRef<"Stall", 'Decimal'>
    readonly floor_id: FieldRef<"Stall", 'Int'>
    readonly section_id: FieldRef<"Stall", 'Int'>
    readonly monthly_rent: FieldRef<"Stall", 'Decimal'>
    readonly rental_price: FieldRef<"Stall", 'Decimal'>
    readonly status: FieldRef<"Stall", 'String'>
    readonly branch_id: FieldRef<"Stall", 'Int'>
    readonly stallholder_id: FieldRef<"Stall", 'Int'>
    readonly floor_level: FieldRef<"Stall", 'String'>
    readonly section: FieldRef<"Stall", 'String'>
    readonly description: FieldRef<"Stall", 'String'>
    readonly price_type: FieldRef<"Stall", 'String'>
    readonly is_available: FieldRef<"Stall", 'Boolean'>
    readonly base_rate: FieldRef<"Stall", 'Decimal'>
    readonly rate_per_sqm: FieldRef<"Stall", 'Decimal'>
    readonly created_at: FieldRef<"Stall", 'DateTime'>
    readonly updated_at: FieldRef<"Stall", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stall findUnique
   */
  export type StallFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    /**
     * Filter, which Stall to fetch.
     */
    where: StallWhereUniqueInput
  }

  /**
   * Stall findUniqueOrThrow
   */
  export type StallFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    /**
     * Filter, which Stall to fetch.
     */
    where: StallWhereUniqueInput
  }

  /**
   * Stall findFirst
   */
  export type StallFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    /**
     * Filter, which Stall to fetch.
     */
    where?: StallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stalls to fetch.
     */
    orderBy?: StallOrderByWithRelationInput | StallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stalls.
     */
    cursor?: StallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stalls.
     */
    distinct?: StallScalarFieldEnum | StallScalarFieldEnum[]
  }

  /**
   * Stall findFirstOrThrow
   */
  export type StallFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    /**
     * Filter, which Stall to fetch.
     */
    where?: StallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stalls to fetch.
     */
    orderBy?: StallOrderByWithRelationInput | StallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stalls.
     */
    cursor?: StallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stalls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stalls.
     */
    distinct?: StallScalarFieldEnum | StallScalarFieldEnum[]
  }

  /**
   * Stall findMany
   */
  export type StallFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    /**
     * Filter, which Stalls to fetch.
     */
    where?: StallWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stalls to fetch.
     */
    orderBy?: StallOrderByWithRelationInput | StallOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stalls.
     */
    cursor?: StallWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stalls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stalls.
     */
    skip?: number
    distinct?: StallScalarFieldEnum | StallScalarFieldEnum[]
  }

  /**
   * Stall create
   */
  export type StallCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    /**
     * The data needed to create a Stall.
     */
    data: XOR<StallCreateInput, StallUncheckedCreateInput>
  }

  /**
   * Stall createMany
   */
  export type StallCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stalls.
     */
    data: StallCreateManyInput | StallCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stall update
   */
  export type StallUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    /**
     * The data needed to update a Stall.
     */
    data: XOR<StallUpdateInput, StallUncheckedUpdateInput>
    /**
     * Choose, which Stall to update.
     */
    where: StallWhereUniqueInput
  }

  /**
   * Stall updateMany
   */
  export type StallUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stalls.
     */
    data: XOR<StallUpdateManyMutationInput, StallUncheckedUpdateManyInput>
    /**
     * Filter which Stalls to update
     */
    where?: StallWhereInput
    /**
     * Limit how many Stalls to update.
     */
    limit?: number
  }

  /**
   * Stall upsert
   */
  export type StallUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    /**
     * The filter to search for the Stall to update in case it exists.
     */
    where: StallWhereUniqueInput
    /**
     * In case the Stall found by the `where` argument doesn't exist, create a new Stall with this data.
     */
    create: XOR<StallCreateInput, StallUncheckedCreateInput>
    /**
     * In case the Stall was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StallUpdateInput, StallUncheckedUpdateInput>
  }

  /**
   * Stall delete
   */
  export type StallDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    /**
     * Filter which Stall to delete.
     */
    where: StallWhereUniqueInput
  }

  /**
   * Stall deleteMany
   */
  export type StallDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stalls to delete
     */
    where?: StallWhereInput
    /**
     * Limit how many Stalls to delete.
     */
    limit?: number
  }

  /**
   * Stall.floor
   */
  export type Stall$floorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Floor
     */
    select?: FloorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Floor
     */
    omit?: FloorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorInclude<ExtArgs> | null
    where?: FloorWhereInput
  }

  /**
   * Stall.sectionRef
   */
  export type Stall$sectionRefArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Section
     */
    select?: SectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Section
     */
    omit?: SectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionInclude<ExtArgs> | null
    where?: SectionWhereInput
  }

  /**
   * Stall.stallholder
   */
  export type Stall$stallholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    where?: StallholderWhereInput
  }

  /**
   * Stall.images
   */
  export type Stall$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallImage
     */
    select?: StallImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StallImage
     */
    omit?: StallImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallImageInclude<ExtArgs> | null
    where?: StallImageWhereInput
    orderBy?: StallImageOrderByWithRelationInput | StallImageOrderByWithRelationInput[]
    cursor?: StallImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StallImageScalarFieldEnum | StallImageScalarFieldEnum[]
  }

  /**
   * Stall.payments
   */
  export type Stall$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Stall.compliances
   */
  export type Stall$compliancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compliance
     */
    select?: ComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compliance
     */
    omit?: ComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceInclude<ExtArgs> | null
    where?: ComplianceWhereInput
    orderBy?: ComplianceOrderByWithRelationInput | ComplianceOrderByWithRelationInput[]
    cursor?: ComplianceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceScalarFieldEnum | ComplianceScalarFieldEnum[]
  }

  /**
   * Stall.complaints
   */
  export type Stall$complaintsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    cursor?: ComplaintWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Stall.vendors
   */
  export type Stall$vendorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    cursor?: VendorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Stall without action
   */
  export type StallDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
  }


  /**
   * Model StallImage
   */

  export type AggregateStallImage = {
    _count: StallImageCountAggregateOutputType | null
    _avg: StallImageAvgAggregateOutputType | null
    _sum: StallImageSumAggregateOutputType | null
    _min: StallImageMinAggregateOutputType | null
    _max: StallImageMaxAggregateOutputType | null
  }

  export type StallImageAvgAggregateOutputType = {
    image_id: number | null
    stall_id: number | null
  }

  export type StallImageSumAggregateOutputType = {
    image_id: number | null
    stall_id: number | null
  }

  export type StallImageMinAggregateOutputType = {
    image_id: number | null
    stall_id: number | null
    filename: string | null
    image_data: Bytes | null
    mime_type: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StallImageMaxAggregateOutputType = {
    image_id: number | null
    stall_id: number | null
    filename: string | null
    image_data: Bytes | null
    mime_type: string | null
    is_primary: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StallImageCountAggregateOutputType = {
    image_id: number
    stall_id: number
    filename: number
    image_data: number
    mime_type: number
    is_primary: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StallImageAvgAggregateInputType = {
    image_id?: true
    stall_id?: true
  }

  export type StallImageSumAggregateInputType = {
    image_id?: true
    stall_id?: true
  }

  export type StallImageMinAggregateInputType = {
    image_id?: true
    stall_id?: true
    filename?: true
    image_data?: true
    mime_type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type StallImageMaxAggregateInputType = {
    image_id?: true
    stall_id?: true
    filename?: true
    image_data?: true
    mime_type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
  }

  export type StallImageCountAggregateInputType = {
    image_id?: true
    stall_id?: true
    filename?: true
    image_data?: true
    mime_type?: true
    is_primary?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StallImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StallImage to aggregate.
     */
    where?: StallImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StallImages to fetch.
     */
    orderBy?: StallImageOrderByWithRelationInput | StallImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StallImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StallImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StallImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StallImages
    **/
    _count?: true | StallImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StallImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StallImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StallImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StallImageMaxAggregateInputType
  }

  export type GetStallImageAggregateType<T extends StallImageAggregateArgs> = {
        [P in keyof T & keyof AggregateStallImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStallImage[P]>
      : GetScalarType<T[P], AggregateStallImage[P]>
  }




  export type StallImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StallImageWhereInput
    orderBy?: StallImageOrderByWithAggregationInput | StallImageOrderByWithAggregationInput[]
    by: StallImageScalarFieldEnum[] | StallImageScalarFieldEnum
    having?: StallImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StallImageCountAggregateInputType | true
    _avg?: StallImageAvgAggregateInputType
    _sum?: StallImageSumAggregateInputType
    _min?: StallImageMinAggregateInputType
    _max?: StallImageMaxAggregateInputType
  }

  export type StallImageGroupByOutputType = {
    image_id: number
    stall_id: number
    filename: string | null
    image_data: Bytes | null
    mime_type: string | null
    is_primary: boolean
    created_at: Date
    updated_at: Date
    _count: StallImageCountAggregateOutputType | null
    _avg: StallImageAvgAggregateOutputType | null
    _sum: StallImageSumAggregateOutputType | null
    _min: StallImageMinAggregateOutputType | null
    _max: StallImageMaxAggregateOutputType | null
  }

  type GetStallImageGroupByPayload<T extends StallImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StallImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StallImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StallImageGroupByOutputType[P]>
            : GetScalarType<T[P], StallImageGroupByOutputType[P]>
        }
      >
    >


  export type StallImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    image_id?: boolean
    stall_id?: boolean
    filename?: boolean
    image_data?: boolean
    mime_type?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
    stall?: boolean | StallDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stallImage"]>



  export type StallImageSelectScalar = {
    image_id?: boolean
    stall_id?: boolean
    filename?: boolean
    image_data?: boolean
    mime_type?: boolean
    is_primary?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StallImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"image_id" | "stall_id" | "filename" | "image_data" | "mime_type" | "is_primary" | "created_at" | "updated_at", ExtArgs["result"]["stallImage"]>
  export type StallImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stall?: boolean | StallDefaultArgs<ExtArgs>
  }

  export type $StallImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StallImage"
    objects: {
      stall: Prisma.$StallPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      image_id: number
      stall_id: number
      filename: string | null
      image_data: Prisma.Bytes | null
      mime_type: string | null
      is_primary: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["stallImage"]>
    composites: {}
  }

  type StallImageGetPayload<S extends boolean | null | undefined | StallImageDefaultArgs> = $Result.GetResult<Prisma.$StallImagePayload, S>

  type StallImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StallImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StallImageCountAggregateInputType | true
    }

  export interface StallImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StallImage'], meta: { name: 'StallImage' } }
    /**
     * Find zero or one StallImage that matches the filter.
     * @param {StallImageFindUniqueArgs} args - Arguments to find a StallImage
     * @example
     * // Get one StallImage
     * const stallImage = await prisma.stallImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StallImageFindUniqueArgs>(args: SelectSubset<T, StallImageFindUniqueArgs<ExtArgs>>): Prisma__StallImageClient<$Result.GetResult<Prisma.$StallImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StallImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StallImageFindUniqueOrThrowArgs} args - Arguments to find a StallImage
     * @example
     * // Get one StallImage
     * const stallImage = await prisma.stallImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StallImageFindUniqueOrThrowArgs>(args: SelectSubset<T, StallImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StallImageClient<$Result.GetResult<Prisma.$StallImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StallImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallImageFindFirstArgs} args - Arguments to find a StallImage
     * @example
     * // Get one StallImage
     * const stallImage = await prisma.stallImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StallImageFindFirstArgs>(args?: SelectSubset<T, StallImageFindFirstArgs<ExtArgs>>): Prisma__StallImageClient<$Result.GetResult<Prisma.$StallImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StallImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallImageFindFirstOrThrowArgs} args - Arguments to find a StallImage
     * @example
     * // Get one StallImage
     * const stallImage = await prisma.stallImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StallImageFindFirstOrThrowArgs>(args?: SelectSubset<T, StallImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__StallImageClient<$Result.GetResult<Prisma.$StallImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StallImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StallImages
     * const stallImages = await prisma.stallImage.findMany()
     * 
     * // Get first 10 StallImages
     * const stallImages = await prisma.stallImage.findMany({ take: 10 })
     * 
     * // Only select the `image_id`
     * const stallImageWithImage_idOnly = await prisma.stallImage.findMany({ select: { image_id: true } })
     * 
     */
    findMany<T extends StallImageFindManyArgs>(args?: SelectSubset<T, StallImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StallImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StallImage.
     * @param {StallImageCreateArgs} args - Arguments to create a StallImage.
     * @example
     * // Create one StallImage
     * const StallImage = await prisma.stallImage.create({
     *   data: {
     *     // ... data to create a StallImage
     *   }
     * })
     * 
     */
    create<T extends StallImageCreateArgs>(args: SelectSubset<T, StallImageCreateArgs<ExtArgs>>): Prisma__StallImageClient<$Result.GetResult<Prisma.$StallImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StallImages.
     * @param {StallImageCreateManyArgs} args - Arguments to create many StallImages.
     * @example
     * // Create many StallImages
     * const stallImage = await prisma.stallImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StallImageCreateManyArgs>(args?: SelectSubset<T, StallImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StallImage.
     * @param {StallImageDeleteArgs} args - Arguments to delete one StallImage.
     * @example
     * // Delete one StallImage
     * const StallImage = await prisma.stallImage.delete({
     *   where: {
     *     // ... filter to delete one StallImage
     *   }
     * })
     * 
     */
    delete<T extends StallImageDeleteArgs>(args: SelectSubset<T, StallImageDeleteArgs<ExtArgs>>): Prisma__StallImageClient<$Result.GetResult<Prisma.$StallImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StallImage.
     * @param {StallImageUpdateArgs} args - Arguments to update one StallImage.
     * @example
     * // Update one StallImage
     * const stallImage = await prisma.stallImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StallImageUpdateArgs>(args: SelectSubset<T, StallImageUpdateArgs<ExtArgs>>): Prisma__StallImageClient<$Result.GetResult<Prisma.$StallImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StallImages.
     * @param {StallImageDeleteManyArgs} args - Arguments to filter StallImages to delete.
     * @example
     * // Delete a few StallImages
     * const { count } = await prisma.stallImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StallImageDeleteManyArgs>(args?: SelectSubset<T, StallImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StallImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StallImages
     * const stallImage = await prisma.stallImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StallImageUpdateManyArgs>(args: SelectSubset<T, StallImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StallImage.
     * @param {StallImageUpsertArgs} args - Arguments to update or create a StallImage.
     * @example
     * // Update or create a StallImage
     * const stallImage = await prisma.stallImage.upsert({
     *   create: {
     *     // ... data to create a StallImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StallImage we want to update
     *   }
     * })
     */
    upsert<T extends StallImageUpsertArgs>(args: SelectSubset<T, StallImageUpsertArgs<ExtArgs>>): Prisma__StallImageClient<$Result.GetResult<Prisma.$StallImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StallImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallImageCountArgs} args - Arguments to filter StallImages to count.
     * @example
     * // Count the number of StallImages
     * const count = await prisma.stallImage.count({
     *   where: {
     *     // ... the filter for the StallImages we want to count
     *   }
     * })
    **/
    count<T extends StallImageCountArgs>(
      args?: Subset<T, StallImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StallImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StallImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StallImageAggregateArgs>(args: Subset<T, StallImageAggregateArgs>): Prisma.PrismaPromise<GetStallImageAggregateType<T>>

    /**
     * Group by StallImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StallImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StallImageGroupByArgs['orderBy'] }
        : { orderBy?: StallImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StallImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStallImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StallImage model
   */
  readonly fields: StallImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StallImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StallImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stall<T extends StallDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StallDefaultArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StallImage model
   */
  interface StallImageFieldRefs {
    readonly image_id: FieldRef<"StallImage", 'Int'>
    readonly stall_id: FieldRef<"StallImage", 'Int'>
    readonly filename: FieldRef<"StallImage", 'String'>
    readonly image_data: FieldRef<"StallImage", 'Bytes'>
    readonly mime_type: FieldRef<"StallImage", 'String'>
    readonly is_primary: FieldRef<"StallImage", 'Boolean'>
    readonly created_at: FieldRef<"StallImage", 'DateTime'>
    readonly updated_at: FieldRef<"StallImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StallImage findUnique
   */
  export type StallImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallImage
     */
    select?: StallImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StallImage
     */
    omit?: StallImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallImageInclude<ExtArgs> | null
    /**
     * Filter, which StallImage to fetch.
     */
    where: StallImageWhereUniqueInput
  }

  /**
   * StallImage findUniqueOrThrow
   */
  export type StallImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallImage
     */
    select?: StallImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StallImage
     */
    omit?: StallImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallImageInclude<ExtArgs> | null
    /**
     * Filter, which StallImage to fetch.
     */
    where: StallImageWhereUniqueInput
  }

  /**
   * StallImage findFirst
   */
  export type StallImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallImage
     */
    select?: StallImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StallImage
     */
    omit?: StallImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallImageInclude<ExtArgs> | null
    /**
     * Filter, which StallImage to fetch.
     */
    where?: StallImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StallImages to fetch.
     */
    orderBy?: StallImageOrderByWithRelationInput | StallImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StallImages.
     */
    cursor?: StallImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StallImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StallImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StallImages.
     */
    distinct?: StallImageScalarFieldEnum | StallImageScalarFieldEnum[]
  }

  /**
   * StallImage findFirstOrThrow
   */
  export type StallImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallImage
     */
    select?: StallImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StallImage
     */
    omit?: StallImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallImageInclude<ExtArgs> | null
    /**
     * Filter, which StallImage to fetch.
     */
    where?: StallImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StallImages to fetch.
     */
    orderBy?: StallImageOrderByWithRelationInput | StallImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StallImages.
     */
    cursor?: StallImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StallImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StallImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StallImages.
     */
    distinct?: StallImageScalarFieldEnum | StallImageScalarFieldEnum[]
  }

  /**
   * StallImage findMany
   */
  export type StallImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallImage
     */
    select?: StallImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StallImage
     */
    omit?: StallImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallImageInclude<ExtArgs> | null
    /**
     * Filter, which StallImages to fetch.
     */
    where?: StallImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StallImages to fetch.
     */
    orderBy?: StallImageOrderByWithRelationInput | StallImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StallImages.
     */
    cursor?: StallImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StallImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StallImages.
     */
    skip?: number
    distinct?: StallImageScalarFieldEnum | StallImageScalarFieldEnum[]
  }

  /**
   * StallImage create
   */
  export type StallImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallImage
     */
    select?: StallImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StallImage
     */
    omit?: StallImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallImageInclude<ExtArgs> | null
    /**
     * The data needed to create a StallImage.
     */
    data: XOR<StallImageCreateInput, StallImageUncheckedCreateInput>
  }

  /**
   * StallImage createMany
   */
  export type StallImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StallImages.
     */
    data: StallImageCreateManyInput | StallImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StallImage update
   */
  export type StallImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallImage
     */
    select?: StallImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StallImage
     */
    omit?: StallImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallImageInclude<ExtArgs> | null
    /**
     * The data needed to update a StallImage.
     */
    data: XOR<StallImageUpdateInput, StallImageUncheckedUpdateInput>
    /**
     * Choose, which StallImage to update.
     */
    where: StallImageWhereUniqueInput
  }

  /**
   * StallImage updateMany
   */
  export type StallImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StallImages.
     */
    data: XOR<StallImageUpdateManyMutationInput, StallImageUncheckedUpdateManyInput>
    /**
     * Filter which StallImages to update
     */
    where?: StallImageWhereInput
    /**
     * Limit how many StallImages to update.
     */
    limit?: number
  }

  /**
   * StallImage upsert
   */
  export type StallImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallImage
     */
    select?: StallImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StallImage
     */
    omit?: StallImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallImageInclude<ExtArgs> | null
    /**
     * The filter to search for the StallImage to update in case it exists.
     */
    where: StallImageWhereUniqueInput
    /**
     * In case the StallImage found by the `where` argument doesn't exist, create a new StallImage with this data.
     */
    create: XOR<StallImageCreateInput, StallImageUncheckedCreateInput>
    /**
     * In case the StallImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StallImageUpdateInput, StallImageUncheckedUpdateInput>
  }

  /**
   * StallImage delete
   */
  export type StallImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallImage
     */
    select?: StallImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StallImage
     */
    omit?: StallImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallImageInclude<ExtArgs> | null
    /**
     * Filter which StallImage to delete.
     */
    where: StallImageWhereUniqueInput
  }

  /**
   * StallImage deleteMany
   */
  export type StallImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StallImages to delete
     */
    where?: StallImageWhereInput
    /**
     * Limit how many StallImages to delete.
     */
    limit?: number
  }

  /**
   * StallImage without action
   */
  export type StallImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StallImage
     */
    select?: StallImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StallImage
     */
    omit?: StallImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallImageInclude<ExtArgs> | null
  }


  /**
   * Model Stallholder
   */

  export type AggregateStallholder = {
    _count: StallholderCountAggregateOutputType | null
    _avg: StallholderAvgAggregateOutputType | null
    _sum: StallholderSumAggregateOutputType | null
    _min: StallholderMinAggregateOutputType | null
    _max: StallholderMaxAggregateOutputType | null
  }

  export type StallholderAvgAggregateOutputType = {
    stallholder_id: number | null
    branch_id: number | null
  }

  export type StallholderSumAggregateOutputType = {
    stallholder_id: number | null
    branch_id: number | null
  }

  export type StallholderMinAggregateOutputType = {
    stallholder_id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone_number: string | null
    address: string | null
    business_name: string | null
    business_type: string | null
    branch_id: number | null
    status: string | null
    password: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StallholderMaxAggregateOutputType = {
    stallholder_id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone_number: string | null
    address: string | null
    business_name: string | null
    business_type: string | null
    branch_id: number | null
    status: string | null
    password: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StallholderCountAggregateOutputType = {
    stallholder_id: number
    first_name: number
    last_name: number
    email: number
    phone_number: number
    address: number
    business_name: number
    business_type: number
    branch_id: number
    status: number
    password: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StallholderAvgAggregateInputType = {
    stallholder_id?: true
    branch_id?: true
  }

  export type StallholderSumAggregateInputType = {
    stallholder_id?: true
    branch_id?: true
  }

  export type StallholderMinAggregateInputType = {
    stallholder_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone_number?: true
    address?: true
    business_name?: true
    business_type?: true
    branch_id?: true
    status?: true
    password?: true
    created_at?: true
    updated_at?: true
  }

  export type StallholderMaxAggregateInputType = {
    stallholder_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone_number?: true
    address?: true
    business_name?: true
    business_type?: true
    branch_id?: true
    status?: true
    password?: true
    created_at?: true
    updated_at?: true
  }

  export type StallholderCountAggregateInputType = {
    stallholder_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone_number?: true
    address?: true
    business_name?: true
    business_type?: true
    branch_id?: true
    status?: true
    password?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StallholderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stallholder to aggregate.
     */
    where?: StallholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stallholders to fetch.
     */
    orderBy?: StallholderOrderByWithRelationInput | StallholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StallholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stallholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stallholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stallholders
    **/
    _count?: true | StallholderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StallholderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StallholderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StallholderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StallholderMaxAggregateInputType
  }

  export type GetStallholderAggregateType<T extends StallholderAggregateArgs> = {
        [P in keyof T & keyof AggregateStallholder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStallholder[P]>
      : GetScalarType<T[P], AggregateStallholder[P]>
  }




  export type StallholderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StallholderWhereInput
    orderBy?: StallholderOrderByWithAggregationInput | StallholderOrderByWithAggregationInput[]
    by: StallholderScalarFieldEnum[] | StallholderScalarFieldEnum
    having?: StallholderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StallholderCountAggregateInputType | true
    _avg?: StallholderAvgAggregateInputType
    _sum?: StallholderSumAggregateInputType
    _min?: StallholderMinAggregateInputType
    _max?: StallholderMaxAggregateInputType
  }

  export type StallholderGroupByOutputType = {
    stallholder_id: number
    first_name: string
    last_name: string
    email: string | null
    phone_number: string | null
    address: string | null
    business_name: string | null
    business_type: string | null
    branch_id: number | null
    status: string
    password: string | null
    created_at: Date
    updated_at: Date
    _count: StallholderCountAggregateOutputType | null
    _avg: StallholderAvgAggregateOutputType | null
    _sum: StallholderSumAggregateOutputType | null
    _min: StallholderMinAggregateOutputType | null
    _max: StallholderMaxAggregateOutputType | null
  }

  type GetStallholderGroupByPayload<T extends StallholderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StallholderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StallholderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StallholderGroupByOutputType[P]>
            : GetScalarType<T[P], StallholderGroupByOutputType[P]>
        }
      >
    >


  export type StallholderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    stallholder_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone_number?: boolean
    address?: boolean
    business_name?: boolean
    business_type?: boolean
    branch_id?: boolean
    status?: boolean
    password?: boolean
    created_at?: boolean
    updated_at?: boolean
    branch?: boolean | Stallholder$branchArgs<ExtArgs>
    stalls?: boolean | Stallholder$stallsArgs<ExtArgs>
    payments?: boolean | Stallholder$paymentsArgs<ExtArgs>
    applications?: boolean | Stallholder$applicationsArgs<ExtArgs>
    _count?: boolean | StallholderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stallholder"]>



  export type StallholderSelectScalar = {
    stallholder_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone_number?: boolean
    address?: boolean
    business_name?: boolean
    business_type?: boolean
    branch_id?: boolean
    status?: boolean
    password?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type StallholderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"stallholder_id" | "first_name" | "last_name" | "email" | "phone_number" | "address" | "business_name" | "business_type" | "branch_id" | "status" | "password" | "created_at" | "updated_at", ExtArgs["result"]["stallholder"]>
  export type StallholderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Stallholder$branchArgs<ExtArgs>
    stalls?: boolean | Stallholder$stallsArgs<ExtArgs>
    payments?: boolean | Stallholder$paymentsArgs<ExtArgs>
    applications?: boolean | Stallholder$applicationsArgs<ExtArgs>
    _count?: boolean | StallholderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StallholderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stallholder"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      stalls: Prisma.$StallPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      applications: Prisma.$ApplicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      stallholder_id: number
      first_name: string
      last_name: string
      email: string | null
      phone_number: string | null
      address: string | null
      business_name: string | null
      business_type: string | null
      branch_id: number | null
      status: string
      password: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["stallholder"]>
    composites: {}
  }

  type StallholderGetPayload<S extends boolean | null | undefined | StallholderDefaultArgs> = $Result.GetResult<Prisma.$StallholderPayload, S>

  type StallholderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StallholderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StallholderCountAggregateInputType | true
    }

  export interface StallholderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stallholder'], meta: { name: 'Stallholder' } }
    /**
     * Find zero or one Stallholder that matches the filter.
     * @param {StallholderFindUniqueArgs} args - Arguments to find a Stallholder
     * @example
     * // Get one Stallholder
     * const stallholder = await prisma.stallholder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StallholderFindUniqueArgs>(args: SelectSubset<T, StallholderFindUniqueArgs<ExtArgs>>): Prisma__StallholderClient<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stallholder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StallholderFindUniqueOrThrowArgs} args - Arguments to find a Stallholder
     * @example
     * // Get one Stallholder
     * const stallholder = await prisma.stallholder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StallholderFindUniqueOrThrowArgs>(args: SelectSubset<T, StallholderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StallholderClient<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stallholder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallholderFindFirstArgs} args - Arguments to find a Stallholder
     * @example
     * // Get one Stallholder
     * const stallholder = await prisma.stallholder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StallholderFindFirstArgs>(args?: SelectSubset<T, StallholderFindFirstArgs<ExtArgs>>): Prisma__StallholderClient<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stallholder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallholderFindFirstOrThrowArgs} args - Arguments to find a Stallholder
     * @example
     * // Get one Stallholder
     * const stallholder = await prisma.stallholder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StallholderFindFirstOrThrowArgs>(args?: SelectSubset<T, StallholderFindFirstOrThrowArgs<ExtArgs>>): Prisma__StallholderClient<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stallholders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallholderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stallholders
     * const stallholders = await prisma.stallholder.findMany()
     * 
     * // Get first 10 Stallholders
     * const stallholders = await prisma.stallholder.findMany({ take: 10 })
     * 
     * // Only select the `stallholder_id`
     * const stallholderWithStallholder_idOnly = await prisma.stallholder.findMany({ select: { stallholder_id: true } })
     * 
     */
    findMany<T extends StallholderFindManyArgs>(args?: SelectSubset<T, StallholderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stallholder.
     * @param {StallholderCreateArgs} args - Arguments to create a Stallholder.
     * @example
     * // Create one Stallholder
     * const Stallholder = await prisma.stallholder.create({
     *   data: {
     *     // ... data to create a Stallholder
     *   }
     * })
     * 
     */
    create<T extends StallholderCreateArgs>(args: SelectSubset<T, StallholderCreateArgs<ExtArgs>>): Prisma__StallholderClient<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stallholders.
     * @param {StallholderCreateManyArgs} args - Arguments to create many Stallholders.
     * @example
     * // Create many Stallholders
     * const stallholder = await prisma.stallholder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StallholderCreateManyArgs>(args?: SelectSubset<T, StallholderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stallholder.
     * @param {StallholderDeleteArgs} args - Arguments to delete one Stallholder.
     * @example
     * // Delete one Stallholder
     * const Stallholder = await prisma.stallholder.delete({
     *   where: {
     *     // ... filter to delete one Stallholder
     *   }
     * })
     * 
     */
    delete<T extends StallholderDeleteArgs>(args: SelectSubset<T, StallholderDeleteArgs<ExtArgs>>): Prisma__StallholderClient<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stallholder.
     * @param {StallholderUpdateArgs} args - Arguments to update one Stallholder.
     * @example
     * // Update one Stallholder
     * const stallholder = await prisma.stallholder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StallholderUpdateArgs>(args: SelectSubset<T, StallholderUpdateArgs<ExtArgs>>): Prisma__StallholderClient<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stallholders.
     * @param {StallholderDeleteManyArgs} args - Arguments to filter Stallholders to delete.
     * @example
     * // Delete a few Stallholders
     * const { count } = await prisma.stallholder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StallholderDeleteManyArgs>(args?: SelectSubset<T, StallholderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stallholders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallholderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stallholders
     * const stallholder = await prisma.stallholder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StallholderUpdateManyArgs>(args: SelectSubset<T, StallholderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stallholder.
     * @param {StallholderUpsertArgs} args - Arguments to update or create a Stallholder.
     * @example
     * // Update or create a Stallholder
     * const stallholder = await prisma.stallholder.upsert({
     *   create: {
     *     // ... data to create a Stallholder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stallholder we want to update
     *   }
     * })
     */
    upsert<T extends StallholderUpsertArgs>(args: SelectSubset<T, StallholderUpsertArgs<ExtArgs>>): Prisma__StallholderClient<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stallholders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallholderCountArgs} args - Arguments to filter Stallholders to count.
     * @example
     * // Count the number of Stallholders
     * const count = await prisma.stallholder.count({
     *   where: {
     *     // ... the filter for the Stallholders we want to count
     *   }
     * })
    **/
    count<T extends StallholderCountArgs>(
      args?: Subset<T, StallholderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StallholderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stallholder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallholderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StallholderAggregateArgs>(args: Subset<T, StallholderAggregateArgs>): Prisma.PrismaPromise<GetStallholderAggregateType<T>>

    /**
     * Group by Stallholder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StallholderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StallholderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StallholderGroupByArgs['orderBy'] }
        : { orderBy?: StallholderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StallholderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStallholderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stallholder model
   */
  readonly fields: StallholderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stallholder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StallholderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Stallholder$branchArgs<ExtArgs> = {}>(args?: Subset<T, Stallholder$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stalls<T extends Stallholder$stallsArgs<ExtArgs> = {}>(args?: Subset<T, Stallholder$stallsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Stallholder$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Stallholder$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    applications<T extends Stallholder$applicationsArgs<ExtArgs> = {}>(args?: Subset<T, Stallholder$applicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stallholder model
   */
  interface StallholderFieldRefs {
    readonly stallholder_id: FieldRef<"Stallholder", 'Int'>
    readonly first_name: FieldRef<"Stallholder", 'String'>
    readonly last_name: FieldRef<"Stallholder", 'String'>
    readonly email: FieldRef<"Stallholder", 'String'>
    readonly phone_number: FieldRef<"Stallholder", 'String'>
    readonly address: FieldRef<"Stallholder", 'String'>
    readonly business_name: FieldRef<"Stallholder", 'String'>
    readonly business_type: FieldRef<"Stallholder", 'String'>
    readonly branch_id: FieldRef<"Stallholder", 'Int'>
    readonly status: FieldRef<"Stallholder", 'String'>
    readonly password: FieldRef<"Stallholder", 'String'>
    readonly created_at: FieldRef<"Stallholder", 'DateTime'>
    readonly updated_at: FieldRef<"Stallholder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stallholder findUnique
   */
  export type StallholderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    /**
     * Filter, which Stallholder to fetch.
     */
    where: StallholderWhereUniqueInput
  }

  /**
   * Stallholder findUniqueOrThrow
   */
  export type StallholderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    /**
     * Filter, which Stallholder to fetch.
     */
    where: StallholderWhereUniqueInput
  }

  /**
   * Stallholder findFirst
   */
  export type StallholderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    /**
     * Filter, which Stallholder to fetch.
     */
    where?: StallholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stallholders to fetch.
     */
    orderBy?: StallholderOrderByWithRelationInput | StallholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stallholders.
     */
    cursor?: StallholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stallholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stallholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stallholders.
     */
    distinct?: StallholderScalarFieldEnum | StallholderScalarFieldEnum[]
  }

  /**
   * Stallholder findFirstOrThrow
   */
  export type StallholderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    /**
     * Filter, which Stallholder to fetch.
     */
    where?: StallholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stallholders to fetch.
     */
    orderBy?: StallholderOrderByWithRelationInput | StallholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stallholders.
     */
    cursor?: StallholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stallholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stallholders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stallholders.
     */
    distinct?: StallholderScalarFieldEnum | StallholderScalarFieldEnum[]
  }

  /**
   * Stallholder findMany
   */
  export type StallholderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    /**
     * Filter, which Stallholders to fetch.
     */
    where?: StallholderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stallholders to fetch.
     */
    orderBy?: StallholderOrderByWithRelationInput | StallholderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stallholders.
     */
    cursor?: StallholderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stallholders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stallholders.
     */
    skip?: number
    distinct?: StallholderScalarFieldEnum | StallholderScalarFieldEnum[]
  }

  /**
   * Stallholder create
   */
  export type StallholderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    /**
     * The data needed to create a Stallholder.
     */
    data: XOR<StallholderCreateInput, StallholderUncheckedCreateInput>
  }

  /**
   * Stallholder createMany
   */
  export type StallholderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stallholders.
     */
    data: StallholderCreateManyInput | StallholderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stallholder update
   */
  export type StallholderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    /**
     * The data needed to update a Stallholder.
     */
    data: XOR<StallholderUpdateInput, StallholderUncheckedUpdateInput>
    /**
     * Choose, which Stallholder to update.
     */
    where: StallholderWhereUniqueInput
  }

  /**
   * Stallholder updateMany
   */
  export type StallholderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stallholders.
     */
    data: XOR<StallholderUpdateManyMutationInput, StallholderUncheckedUpdateManyInput>
    /**
     * Filter which Stallholders to update
     */
    where?: StallholderWhereInput
    /**
     * Limit how many Stallholders to update.
     */
    limit?: number
  }

  /**
   * Stallholder upsert
   */
  export type StallholderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    /**
     * The filter to search for the Stallholder to update in case it exists.
     */
    where: StallholderWhereUniqueInput
    /**
     * In case the Stallholder found by the `where` argument doesn't exist, create a new Stallholder with this data.
     */
    create: XOR<StallholderCreateInput, StallholderUncheckedCreateInput>
    /**
     * In case the Stallholder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StallholderUpdateInput, StallholderUncheckedUpdateInput>
  }

  /**
   * Stallholder delete
   */
  export type StallholderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    /**
     * Filter which Stallholder to delete.
     */
    where: StallholderWhereUniqueInput
  }

  /**
   * Stallholder deleteMany
   */
  export type StallholderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stallholders to delete
     */
    where?: StallholderWhereInput
    /**
     * Limit how many Stallholders to delete.
     */
    limit?: number
  }

  /**
   * Stallholder.branch
   */
  export type Stallholder$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Stallholder.stalls
   */
  export type Stallholder$stallsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    where?: StallWhereInput
    orderBy?: StallOrderByWithRelationInput | StallOrderByWithRelationInput[]
    cursor?: StallWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StallScalarFieldEnum | StallScalarFieldEnum[]
  }

  /**
   * Stallholder.payments
   */
  export type Stallholder$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Stallholder.applications
   */
  export type Stallholder$applicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    cursor?: ApplicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Stallholder without action
   */
  export type StallholderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    employee_id: number | null
    branch_id: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    employee_id: number | null
    branch_id: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    employee_id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone_number: string | null
    position: string | null
    role: string | null
    branch_id: number | null
    password: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    employee_id: number | null
    first_name: string | null
    last_name: string | null
    email: string | null
    phone_number: string | null
    position: string | null
    role: string | null
    branch_id: number | null
    password: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    employee_id: number
    first_name: number
    last_name: number
    email: number
    phone_number: number
    position: number
    role: number
    branch_id: number
    password: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    employee_id?: true
    branch_id?: true
  }

  export type EmployeeSumAggregateInputType = {
    employee_id?: true
    branch_id?: true
  }

  export type EmployeeMinAggregateInputType = {
    employee_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone_number?: true
    position?: true
    role?: true
    branch_id?: true
    password?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type EmployeeMaxAggregateInputType = {
    employee_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone_number?: true
    position?: true
    role?: true
    branch_id?: true
    password?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type EmployeeCountAggregateInputType = {
    employee_id?: true
    first_name?: true
    last_name?: true
    email?: true
    phone_number?: true
    position?: true
    role?: true
    branch_id?: true
    password?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    employee_id: number
    first_name: string
    last_name: string
    email: string
    phone_number: string | null
    position: string | null
    role: string
    branch_id: number | null
    password: string
    status: string
    created_at: Date
    updated_at: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    employee_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone_number?: boolean
    position?: boolean
    role?: boolean
    branch_id?: boolean
    password?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    branch?: boolean | Employee$branchArgs<ExtArgs>
    inspections?: boolean | Employee$inspectionsArgs<ExtArgs>
    collections?: boolean | Employee$collectionsArgs<ExtArgs>
    activityLogs?: boolean | Employee$activityLogsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>



  export type EmployeeSelectScalar = {
    employee_id?: boolean
    first_name?: boolean
    last_name?: boolean
    email?: boolean
    phone_number?: boolean
    position?: boolean
    role?: boolean
    branch_id?: boolean
    password?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"employee_id" | "first_name" | "last_name" | "email" | "phone_number" | "position" | "role" | "branch_id" | "password" | "status" | "created_at" | "updated_at", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    branch?: boolean | Employee$branchArgs<ExtArgs>
    inspections?: boolean | Employee$inspectionsArgs<ExtArgs>
    collections?: boolean | Employee$collectionsArgs<ExtArgs>
    activityLogs?: boolean | Employee$activityLogsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      branch: Prisma.$BranchPayload<ExtArgs> | null
      inspections: Prisma.$CompliancePayload<ExtArgs>[]
      collections: Prisma.$PaymentPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      employee_id: number
      first_name: string
      last_name: string
      email: string
      phone_number: string | null
      position: string | null
      role: string
      branch_id: number | null
      password: string
      status: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `employee_id`
     * const employeeWithEmployee_idOnly = await prisma.employee.findMany({ select: { employee_id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    branch<T extends Employee$branchArgs<ExtArgs> = {}>(args?: Subset<T, Employee$branchArgs<ExtArgs>>): Prisma__BranchClient<$Result.GetResult<Prisma.$BranchPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    inspections<T extends Employee$inspectionsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$inspectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompliancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    collections<T extends Employee$collectionsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$collectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    activityLogs<T extends Employee$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly employee_id: FieldRef<"Employee", 'Int'>
    readonly first_name: FieldRef<"Employee", 'String'>
    readonly last_name: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly phone_number: FieldRef<"Employee", 'String'>
    readonly position: FieldRef<"Employee", 'String'>
    readonly role: FieldRef<"Employee", 'String'>
    readonly branch_id: FieldRef<"Employee", 'Int'>
    readonly password: FieldRef<"Employee", 'String'>
    readonly status: FieldRef<"Employee", 'String'>
    readonly created_at: FieldRef<"Employee", 'DateTime'>
    readonly updated_at: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.branch
   */
  export type Employee$branchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Branch
     */
    select?: BranchSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Branch
     */
    omit?: BranchOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BranchInclude<ExtArgs> | null
    where?: BranchWhereInput
  }

  /**
   * Employee.inspections
   */
  export type Employee$inspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compliance
     */
    select?: ComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compliance
     */
    omit?: ComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceInclude<ExtArgs> | null
    where?: ComplianceWhereInput
    orderBy?: ComplianceOrderByWithRelationInput | ComplianceOrderByWithRelationInput[]
    cursor?: ComplianceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceScalarFieldEnum | ComplianceScalarFieldEnum[]
  }

  /**
   * Employee.collections
   */
  export type Employee$collectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Employee.activityLogs
   */
  export type Employee$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Application
   */

  export type AggregateApplication = {
    _count: ApplicationCountAggregateOutputType | null
    _avg: ApplicationAvgAggregateOutputType | null
    _sum: ApplicationSumAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  export type ApplicationAvgAggregateOutputType = {
    application_id: number | null
    stall_id: number | null
    stallholder_id: number | null
  }

  export type ApplicationSumAggregateOutputType = {
    application_id: number | null
    stall_id: number | null
    stallholder_id: number | null
  }

  export type ApplicationMinAggregateOutputType = {
    application_id: number | null
    applicant_name: string | null
    applicant_email: string | null
    applicant_phone: string | null
    business_name: string | null
    business_type: string | null
    stall_id: number | null
    stallholder_id: number | null
    status: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ApplicationMaxAggregateOutputType = {
    application_id: number | null
    applicant_name: string | null
    applicant_email: string | null
    applicant_phone: string | null
    business_name: string | null
    business_type: string | null
    stall_id: number | null
    stallholder_id: number | null
    status: string | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ApplicationCountAggregateOutputType = {
    application_id: number
    applicant_name: number
    applicant_email: number
    applicant_phone: number
    business_name: number
    business_type: number
    stall_id: number
    stallholder_id: number
    status: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ApplicationAvgAggregateInputType = {
    application_id?: true
    stall_id?: true
    stallholder_id?: true
  }

  export type ApplicationSumAggregateInputType = {
    application_id?: true
    stall_id?: true
    stallholder_id?: true
  }

  export type ApplicationMinAggregateInputType = {
    application_id?: true
    applicant_name?: true
    applicant_email?: true
    applicant_phone?: true
    business_name?: true
    business_type?: true
    stall_id?: true
    stallholder_id?: true
    status?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type ApplicationMaxAggregateInputType = {
    application_id?: true
    applicant_name?: true
    applicant_email?: true
    applicant_phone?: true
    business_name?: true
    business_type?: true
    stall_id?: true
    stallholder_id?: true
    status?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type ApplicationCountAggregateInputType = {
    application_id?: true
    applicant_name?: true
    applicant_email?: true
    applicant_phone?: true
    business_name?: true
    business_type?: true
    stall_id?: true
    stallholder_id?: true
    status?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ApplicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Application to aggregate.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Applications
    **/
    _count?: true | ApplicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicationMaxAggregateInputType
  }

  export type GetApplicationAggregateType<T extends ApplicationAggregateArgs> = {
        [P in keyof T & keyof AggregateApplication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplication[P]>
      : GetScalarType<T[P], AggregateApplication[P]>
  }




  export type ApplicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ApplicationWhereInput
    orderBy?: ApplicationOrderByWithAggregationInput | ApplicationOrderByWithAggregationInput[]
    by: ApplicationScalarFieldEnum[] | ApplicationScalarFieldEnum
    having?: ApplicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicationCountAggregateInputType | true
    _avg?: ApplicationAvgAggregateInputType
    _sum?: ApplicationSumAggregateInputType
    _min?: ApplicationMinAggregateInputType
    _max?: ApplicationMaxAggregateInputType
  }

  export type ApplicationGroupByOutputType = {
    application_id: number
    applicant_name: string | null
    applicant_email: string | null
    applicant_phone: string | null
    business_name: string | null
    business_type: string | null
    stall_id: number | null
    stallholder_id: number | null
    status: string
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: ApplicationCountAggregateOutputType | null
    _avg: ApplicationAvgAggregateOutputType | null
    _sum: ApplicationSumAggregateOutputType | null
    _min: ApplicationMinAggregateOutputType | null
    _max: ApplicationMaxAggregateOutputType | null
  }

  type GetApplicationGroupByPayload<T extends ApplicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicationGroupByOutputType[P]>
        }
      >
    >


  export type ApplicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    application_id?: boolean
    applicant_name?: boolean
    applicant_email?: boolean
    applicant_phone?: boolean
    business_name?: boolean
    business_type?: boolean
    stall_id?: boolean
    stallholder_id?: boolean
    status?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    stallholder?: boolean | Application$stallholderArgs<ExtArgs>
  }, ExtArgs["result"]["application"]>



  export type ApplicationSelectScalar = {
    application_id?: boolean
    applicant_name?: boolean
    applicant_email?: boolean
    applicant_phone?: boolean
    business_name?: boolean
    business_type?: boolean
    stall_id?: boolean
    stallholder_id?: boolean
    status?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ApplicationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"application_id" | "applicant_name" | "applicant_email" | "applicant_phone" | "business_name" | "business_type" | "stall_id" | "stallholder_id" | "status" | "notes" | "created_at" | "updated_at", ExtArgs["result"]["application"]>
  export type ApplicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stallholder?: boolean | Application$stallholderArgs<ExtArgs>
  }

  export type $ApplicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Application"
    objects: {
      stallholder: Prisma.$StallholderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      application_id: number
      applicant_name: string | null
      applicant_email: string | null
      applicant_phone: string | null
      business_name: string | null
      business_type: string | null
      stall_id: number | null
      stallholder_id: number | null
      status: string
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["application"]>
    composites: {}
  }

  type ApplicationGetPayload<S extends boolean | null | undefined | ApplicationDefaultArgs> = $Result.GetResult<Prisma.$ApplicationPayload, S>

  type ApplicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ApplicationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicationCountAggregateInputType | true
    }

  export interface ApplicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Application'], meta: { name: 'Application' } }
    /**
     * Find zero or one Application that matches the filter.
     * @param {ApplicationFindUniqueArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApplicationFindUniqueArgs>(args: SelectSubset<T, ApplicationFindUniqueArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Application that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApplicationFindUniqueOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApplicationFindUniqueOrThrowArgs>(args: SelectSubset<T, ApplicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApplicationFindFirstArgs>(args?: SelectSubset<T, ApplicationFindFirstArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Application that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindFirstOrThrowArgs} args - Arguments to find a Application
     * @example
     * // Get one Application
     * const application = await prisma.application.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApplicationFindFirstOrThrowArgs>(args?: SelectSubset<T, ApplicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applications
     * const applications = await prisma.application.findMany()
     * 
     * // Get first 10 Applications
     * const applications = await prisma.application.findMany({ take: 10 })
     * 
     * // Only select the `application_id`
     * const applicationWithApplication_idOnly = await prisma.application.findMany({ select: { application_id: true } })
     * 
     */
    findMany<T extends ApplicationFindManyArgs>(args?: SelectSubset<T, ApplicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Application.
     * @param {ApplicationCreateArgs} args - Arguments to create a Application.
     * @example
     * // Create one Application
     * const Application = await prisma.application.create({
     *   data: {
     *     // ... data to create a Application
     *   }
     * })
     * 
     */
    create<T extends ApplicationCreateArgs>(args: SelectSubset<T, ApplicationCreateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applications.
     * @param {ApplicationCreateManyArgs} args - Arguments to create many Applications.
     * @example
     * // Create many Applications
     * const application = await prisma.application.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ApplicationCreateManyArgs>(args?: SelectSubset<T, ApplicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Application.
     * @param {ApplicationDeleteArgs} args - Arguments to delete one Application.
     * @example
     * // Delete one Application
     * const Application = await prisma.application.delete({
     *   where: {
     *     // ... filter to delete one Application
     *   }
     * })
     * 
     */
    delete<T extends ApplicationDeleteArgs>(args: SelectSubset<T, ApplicationDeleteArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Application.
     * @param {ApplicationUpdateArgs} args - Arguments to update one Application.
     * @example
     * // Update one Application
     * const application = await prisma.application.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ApplicationUpdateArgs>(args: SelectSubset<T, ApplicationUpdateArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applications.
     * @param {ApplicationDeleteManyArgs} args - Arguments to filter Applications to delete.
     * @example
     * // Delete a few Applications
     * const { count } = await prisma.application.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ApplicationDeleteManyArgs>(args?: SelectSubset<T, ApplicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applications
     * const application = await prisma.application.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ApplicationUpdateManyArgs>(args: SelectSubset<T, ApplicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Application.
     * @param {ApplicationUpsertArgs} args - Arguments to update or create a Application.
     * @example
     * // Update or create a Application
     * const application = await prisma.application.upsert({
     *   create: {
     *     // ... data to create a Application
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Application we want to update
     *   }
     * })
     */
    upsert<T extends ApplicationUpsertArgs>(args: SelectSubset<T, ApplicationUpsertArgs<ExtArgs>>): Prisma__ApplicationClient<$Result.GetResult<Prisma.$ApplicationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationCountArgs} args - Arguments to filter Applications to count.
     * @example
     * // Count the number of Applications
     * const count = await prisma.application.count({
     *   where: {
     *     // ... the filter for the Applications we want to count
     *   }
     * })
    **/
    count<T extends ApplicationCountArgs>(
      args?: Subset<T, ApplicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicationAggregateArgs>(args: Subset<T, ApplicationAggregateArgs>): Prisma.PrismaPromise<GetApplicationAggregateType<T>>

    /**
     * Group by Application.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApplicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApplicationGroupByArgs['orderBy'] }
        : { orderBy?: ApplicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApplicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Application model
   */
  readonly fields: ApplicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Application.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApplicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stallholder<T extends Application$stallholderArgs<ExtArgs> = {}>(args?: Subset<T, Application$stallholderArgs<ExtArgs>>): Prisma__StallholderClient<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Application model
   */
  interface ApplicationFieldRefs {
    readonly application_id: FieldRef<"Application", 'Int'>
    readonly applicant_name: FieldRef<"Application", 'String'>
    readonly applicant_email: FieldRef<"Application", 'String'>
    readonly applicant_phone: FieldRef<"Application", 'String'>
    readonly business_name: FieldRef<"Application", 'String'>
    readonly business_type: FieldRef<"Application", 'String'>
    readonly stall_id: FieldRef<"Application", 'Int'>
    readonly stallholder_id: FieldRef<"Application", 'Int'>
    readonly status: FieldRef<"Application", 'String'>
    readonly notes: FieldRef<"Application", 'String'>
    readonly created_at: FieldRef<"Application", 'DateTime'>
    readonly updated_at: FieldRef<"Application", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Application findUnique
   */
  export type ApplicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findUniqueOrThrow
   */
  export type ApplicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application findFirst
   */
  export type ApplicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findFirstOrThrow
   */
  export type ApplicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Application to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Applications.
     */
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application findMany
   */
  export type ApplicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter, which Applications to fetch.
     */
    where?: ApplicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Applications to fetch.
     */
    orderBy?: ApplicationOrderByWithRelationInput | ApplicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Applications.
     */
    cursor?: ApplicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Applications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Applications.
     */
    skip?: number
    distinct?: ApplicationScalarFieldEnum | ApplicationScalarFieldEnum[]
  }

  /**
   * Application create
   */
  export type ApplicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Application.
     */
    data: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
  }

  /**
   * Application createMany
   */
  export type ApplicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Applications.
     */
    data: ApplicationCreateManyInput | ApplicationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Application update
   */
  export type ApplicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Application.
     */
    data: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
    /**
     * Choose, which Application to update.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application updateMany
   */
  export type ApplicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Applications.
     */
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyInput>
    /**
     * Filter which Applications to update
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to update.
     */
    limit?: number
  }

  /**
   * Application upsert
   */
  export type ApplicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Application to update in case it exists.
     */
    where: ApplicationWhereUniqueInput
    /**
     * In case the Application found by the `where` argument doesn't exist, create a new Application with this data.
     */
    create: XOR<ApplicationCreateInput, ApplicationUncheckedCreateInput>
    /**
     * In case the Application was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApplicationUpdateInput, ApplicationUncheckedUpdateInput>
  }

  /**
   * Application delete
   */
  export type ApplicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
    /**
     * Filter which Application to delete.
     */
    where: ApplicationWhereUniqueInput
  }

  /**
   * Application deleteMany
   */
  export type ApplicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Applications to delete
     */
    where?: ApplicationWhereInput
    /**
     * Limit how many Applications to delete.
     */
    limit?: number
  }

  /**
   * Application.stallholder
   */
  export type Application$stallholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    where?: StallholderWhereInput
  }

  /**
   * Application without action
   */
  export type ApplicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Application
     */
    select?: ApplicationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Application
     */
    omit?: ApplicationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ApplicationInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    payment_id: number | null
    stall_id: number | null
    stallholder_id: number | null
    amount: Decimal | null
    collector_id: number | null
  }

  export type PaymentSumAggregateOutputType = {
    payment_id: number | null
    stall_id: number | null
    stallholder_id: number | null
    amount: Decimal | null
    collector_id: number | null
  }

  export type PaymentMinAggregateOutputType = {
    payment_id: number | null
    stall_id: number | null
    stallholder_id: number | null
    amount: Decimal | null
    payment_date: Date | null
    payment_type: string | null
    payment_method: string | null
    status: string | null
    reference_no: string | null
    collector_id: number | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    payment_id: number | null
    stall_id: number | null
    stallholder_id: number | null
    amount: Decimal | null
    payment_date: Date | null
    payment_type: string | null
    payment_method: string | null
    status: string | null
    reference_no: string | null
    collector_id: number | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    payment_id: number
    stall_id: number
    stallholder_id: number
    amount: number
    payment_date: number
    payment_type: number
    payment_method: number
    status: number
    reference_no: number
    collector_id: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    payment_id?: true
    stall_id?: true
    stallholder_id?: true
    amount?: true
    collector_id?: true
  }

  export type PaymentSumAggregateInputType = {
    payment_id?: true
    stall_id?: true
    stallholder_id?: true
    amount?: true
    collector_id?: true
  }

  export type PaymentMinAggregateInputType = {
    payment_id?: true
    stall_id?: true
    stallholder_id?: true
    amount?: true
    payment_date?: true
    payment_type?: true
    payment_method?: true
    status?: true
    reference_no?: true
    collector_id?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentMaxAggregateInputType = {
    payment_id?: true
    stall_id?: true
    stallholder_id?: true
    amount?: true
    payment_date?: true
    payment_type?: true
    payment_method?: true
    status?: true
    reference_no?: true
    collector_id?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentCountAggregateInputType = {
    payment_id?: true
    stall_id?: true
    stallholder_id?: true
    amount?: true
    payment_date?: true
    payment_type?: true
    payment_method?: true
    status?: true
    reference_no?: true
    collector_id?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    payment_id: number
    stall_id: number | null
    stallholder_id: number | null
    amount: Decimal
    payment_date: Date | null
    payment_type: string | null
    payment_method: string | null
    status: string
    reference_no: string | null
    collector_id: number | null
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    payment_id?: boolean
    stall_id?: boolean
    stallholder_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_type?: boolean
    payment_method?: boolean
    status?: boolean
    reference_no?: boolean
    collector_id?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    stall?: boolean | Payment$stallArgs<ExtArgs>
    stallholder?: boolean | Payment$stallholderArgs<ExtArgs>
    collector?: boolean | Payment$collectorArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>



  export type PaymentSelectScalar = {
    payment_id?: boolean
    stall_id?: boolean
    stallholder_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_type?: boolean
    payment_method?: boolean
    status?: boolean
    reference_no?: boolean
    collector_id?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"payment_id" | "stall_id" | "stallholder_id" | "amount" | "payment_date" | "payment_type" | "payment_method" | "status" | "reference_no" | "collector_id" | "notes" | "created_at" | "updated_at", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stall?: boolean | Payment$stallArgs<ExtArgs>
    stallholder?: boolean | Payment$stallholderArgs<ExtArgs>
    collector?: boolean | Payment$collectorArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      stall: Prisma.$StallPayload<ExtArgs> | null
      stallholder: Prisma.$StallholderPayload<ExtArgs> | null
      collector: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      payment_id: number
      stall_id: number | null
      stallholder_id: number | null
      amount: Prisma.Decimal
      payment_date: Date | null
      payment_type: string | null
      payment_method: string | null
      status: string
      reference_no: string | null
      collector_id: number | null
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `payment_id`
     * const paymentWithPayment_idOnly = await prisma.payment.findMany({ select: { payment_id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stall<T extends Payment$stallArgs<ExtArgs> = {}>(args?: Subset<T, Payment$stallArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    stallholder<T extends Payment$stallholderArgs<ExtArgs> = {}>(args?: Subset<T, Payment$stallholderArgs<ExtArgs>>): Prisma__StallholderClient<$Result.GetResult<Prisma.$StallholderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    collector<T extends Payment$collectorArgs<ExtArgs> = {}>(args?: Subset<T, Payment$collectorArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly payment_id: FieldRef<"Payment", 'Int'>
    readonly stall_id: FieldRef<"Payment", 'Int'>
    readonly stallholder_id: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly payment_date: FieldRef<"Payment", 'DateTime'>
    readonly payment_type: FieldRef<"Payment", 'String'>
    readonly payment_method: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly reference_no: FieldRef<"Payment", 'String'>
    readonly collector_id: FieldRef<"Payment", 'Int'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly created_at: FieldRef<"Payment", 'DateTime'>
    readonly updated_at: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.stall
   */
  export type Payment$stallArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    where?: StallWhereInput
  }

  /**
   * Payment.stallholder
   */
  export type Payment$stallholderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stallholder
     */
    select?: StallholderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stallholder
     */
    omit?: StallholderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallholderInclude<ExtArgs> | null
    where?: StallholderWhereInput
  }

  /**
   * Payment.collector
   */
  export type Payment$collectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Compliance
   */

  export type AggregateCompliance = {
    _count: ComplianceCountAggregateOutputType | null
    _avg: ComplianceAvgAggregateOutputType | null
    _sum: ComplianceSumAggregateOutputType | null
    _min: ComplianceMinAggregateOutputType | null
    _max: ComplianceMaxAggregateOutputType | null
  }

  export type ComplianceAvgAggregateOutputType = {
    compliance_id: number | null
    stall_id: number | null
    inspector_id: number | null
  }

  export type ComplianceSumAggregateOutputType = {
    compliance_id: number | null
    stall_id: number | null
    inspector_id: number | null
  }

  export type ComplianceMinAggregateOutputType = {
    compliance_id: number | null
    stall_id: number | null
    inspector_id: number | null
    compliance_type: string | null
    status: string | null
    inspection_date: Date | null
    remarks: string | null
    evidence: Bytes | null
    evidence_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ComplianceMaxAggregateOutputType = {
    compliance_id: number | null
    stall_id: number | null
    inspector_id: number | null
    compliance_type: string | null
    status: string | null
    inspection_date: Date | null
    remarks: string | null
    evidence: Bytes | null
    evidence_type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ComplianceCountAggregateOutputType = {
    compliance_id: number
    stall_id: number
    inspector_id: number
    compliance_type: number
    status: number
    inspection_date: number
    remarks: number
    evidence: number
    evidence_type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ComplianceAvgAggregateInputType = {
    compliance_id?: true
    stall_id?: true
    inspector_id?: true
  }

  export type ComplianceSumAggregateInputType = {
    compliance_id?: true
    stall_id?: true
    inspector_id?: true
  }

  export type ComplianceMinAggregateInputType = {
    compliance_id?: true
    stall_id?: true
    inspector_id?: true
    compliance_type?: true
    status?: true
    inspection_date?: true
    remarks?: true
    evidence?: true
    evidence_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ComplianceMaxAggregateInputType = {
    compliance_id?: true
    stall_id?: true
    inspector_id?: true
    compliance_type?: true
    status?: true
    inspection_date?: true
    remarks?: true
    evidence?: true
    evidence_type?: true
    created_at?: true
    updated_at?: true
  }

  export type ComplianceCountAggregateInputType = {
    compliance_id?: true
    stall_id?: true
    inspector_id?: true
    compliance_type?: true
    status?: true
    inspection_date?: true
    remarks?: true
    evidence?: true
    evidence_type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ComplianceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Compliance to aggregate.
     */
    where?: ComplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Compliances to fetch.
     */
    orderBy?: ComplianceOrderByWithRelationInput | ComplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Compliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Compliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Compliances
    **/
    _count?: true | ComplianceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplianceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplianceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplianceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplianceMaxAggregateInputType
  }

  export type GetComplianceAggregateType<T extends ComplianceAggregateArgs> = {
        [P in keyof T & keyof AggregateCompliance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompliance[P]>
      : GetScalarType<T[P], AggregateCompliance[P]>
  }




  export type ComplianceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceWhereInput
    orderBy?: ComplianceOrderByWithAggregationInput | ComplianceOrderByWithAggregationInput[]
    by: ComplianceScalarFieldEnum[] | ComplianceScalarFieldEnum
    having?: ComplianceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplianceCountAggregateInputType | true
    _avg?: ComplianceAvgAggregateInputType
    _sum?: ComplianceSumAggregateInputType
    _min?: ComplianceMinAggregateInputType
    _max?: ComplianceMaxAggregateInputType
  }

  export type ComplianceGroupByOutputType = {
    compliance_id: number
    stall_id: number
    inspector_id: number | null
    compliance_type: string | null
    status: string
    inspection_date: Date | null
    remarks: string | null
    evidence: Bytes | null
    evidence_type: string | null
    created_at: Date
    updated_at: Date
    _count: ComplianceCountAggregateOutputType | null
    _avg: ComplianceAvgAggregateOutputType | null
    _sum: ComplianceSumAggregateOutputType | null
    _min: ComplianceMinAggregateOutputType | null
    _max: ComplianceMaxAggregateOutputType | null
  }

  type GetComplianceGroupByPayload<T extends ComplianceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplianceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplianceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplianceGroupByOutputType[P]>
            : GetScalarType<T[P], ComplianceGroupByOutputType[P]>
        }
      >
    >


  export type ComplianceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    compliance_id?: boolean
    stall_id?: boolean
    inspector_id?: boolean
    compliance_type?: boolean
    status?: boolean
    inspection_date?: boolean
    remarks?: boolean
    evidence?: boolean
    evidence_type?: boolean
    created_at?: boolean
    updated_at?: boolean
    stall?: boolean | StallDefaultArgs<ExtArgs>
    inspector?: boolean | Compliance$inspectorArgs<ExtArgs>
  }, ExtArgs["result"]["compliance"]>



  export type ComplianceSelectScalar = {
    compliance_id?: boolean
    stall_id?: boolean
    inspector_id?: boolean
    compliance_type?: boolean
    status?: boolean
    inspection_date?: boolean
    remarks?: boolean
    evidence?: boolean
    evidence_type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ComplianceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"compliance_id" | "stall_id" | "inspector_id" | "compliance_type" | "status" | "inspection_date" | "remarks" | "evidence" | "evidence_type" | "created_at" | "updated_at", ExtArgs["result"]["compliance"]>
  export type ComplianceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stall?: boolean | StallDefaultArgs<ExtArgs>
    inspector?: boolean | Compliance$inspectorArgs<ExtArgs>
  }

  export type $CompliancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Compliance"
    objects: {
      stall: Prisma.$StallPayload<ExtArgs>
      inspector: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      compliance_id: number
      stall_id: number
      inspector_id: number | null
      compliance_type: string | null
      status: string
      inspection_date: Date | null
      remarks: string | null
      evidence: Prisma.Bytes | null
      evidence_type: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["compliance"]>
    composites: {}
  }

  type ComplianceGetPayload<S extends boolean | null | undefined | ComplianceDefaultArgs> = $Result.GetResult<Prisma.$CompliancePayload, S>

  type ComplianceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplianceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplianceCountAggregateInputType | true
    }

  export interface ComplianceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Compliance'], meta: { name: 'Compliance' } }
    /**
     * Find zero or one Compliance that matches the filter.
     * @param {ComplianceFindUniqueArgs} args - Arguments to find a Compliance
     * @example
     * // Get one Compliance
     * const compliance = await prisma.compliance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplianceFindUniqueArgs>(args: SelectSubset<T, ComplianceFindUniqueArgs<ExtArgs>>): Prisma__ComplianceClient<$Result.GetResult<Prisma.$CompliancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Compliance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplianceFindUniqueOrThrowArgs} args - Arguments to find a Compliance
     * @example
     * // Get one Compliance
     * const compliance = await prisma.compliance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplianceFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplianceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplianceClient<$Result.GetResult<Prisma.$CompliancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compliance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceFindFirstArgs} args - Arguments to find a Compliance
     * @example
     * // Get one Compliance
     * const compliance = await prisma.compliance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplianceFindFirstArgs>(args?: SelectSubset<T, ComplianceFindFirstArgs<ExtArgs>>): Prisma__ComplianceClient<$Result.GetResult<Prisma.$CompliancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Compliance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceFindFirstOrThrowArgs} args - Arguments to find a Compliance
     * @example
     * // Get one Compliance
     * const compliance = await prisma.compliance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplianceFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplianceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplianceClient<$Result.GetResult<Prisma.$CompliancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Compliances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Compliances
     * const compliances = await prisma.compliance.findMany()
     * 
     * // Get first 10 Compliances
     * const compliances = await prisma.compliance.findMany({ take: 10 })
     * 
     * // Only select the `compliance_id`
     * const complianceWithCompliance_idOnly = await prisma.compliance.findMany({ select: { compliance_id: true } })
     * 
     */
    findMany<T extends ComplianceFindManyArgs>(args?: SelectSubset<T, ComplianceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompliancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Compliance.
     * @param {ComplianceCreateArgs} args - Arguments to create a Compliance.
     * @example
     * // Create one Compliance
     * const Compliance = await prisma.compliance.create({
     *   data: {
     *     // ... data to create a Compliance
     *   }
     * })
     * 
     */
    create<T extends ComplianceCreateArgs>(args: SelectSubset<T, ComplianceCreateArgs<ExtArgs>>): Prisma__ComplianceClient<$Result.GetResult<Prisma.$CompliancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Compliances.
     * @param {ComplianceCreateManyArgs} args - Arguments to create many Compliances.
     * @example
     * // Create many Compliances
     * const compliance = await prisma.compliance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplianceCreateManyArgs>(args?: SelectSubset<T, ComplianceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Compliance.
     * @param {ComplianceDeleteArgs} args - Arguments to delete one Compliance.
     * @example
     * // Delete one Compliance
     * const Compliance = await prisma.compliance.delete({
     *   where: {
     *     // ... filter to delete one Compliance
     *   }
     * })
     * 
     */
    delete<T extends ComplianceDeleteArgs>(args: SelectSubset<T, ComplianceDeleteArgs<ExtArgs>>): Prisma__ComplianceClient<$Result.GetResult<Prisma.$CompliancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Compliance.
     * @param {ComplianceUpdateArgs} args - Arguments to update one Compliance.
     * @example
     * // Update one Compliance
     * const compliance = await prisma.compliance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplianceUpdateArgs>(args: SelectSubset<T, ComplianceUpdateArgs<ExtArgs>>): Prisma__ComplianceClient<$Result.GetResult<Prisma.$CompliancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Compliances.
     * @param {ComplianceDeleteManyArgs} args - Arguments to filter Compliances to delete.
     * @example
     * // Delete a few Compliances
     * const { count } = await prisma.compliance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplianceDeleteManyArgs>(args?: SelectSubset<T, ComplianceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Compliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Compliances
     * const compliance = await prisma.compliance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplianceUpdateManyArgs>(args: SelectSubset<T, ComplianceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Compliance.
     * @param {ComplianceUpsertArgs} args - Arguments to update or create a Compliance.
     * @example
     * // Update or create a Compliance
     * const compliance = await prisma.compliance.upsert({
     *   create: {
     *     // ... data to create a Compliance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Compliance we want to update
     *   }
     * })
     */
    upsert<T extends ComplianceUpsertArgs>(args: SelectSubset<T, ComplianceUpsertArgs<ExtArgs>>): Prisma__ComplianceClient<$Result.GetResult<Prisma.$CompliancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Compliances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceCountArgs} args - Arguments to filter Compliances to count.
     * @example
     * // Count the number of Compliances
     * const count = await prisma.compliance.count({
     *   where: {
     *     // ... the filter for the Compliances we want to count
     *   }
     * })
    **/
    count<T extends ComplianceCountArgs>(
      args?: Subset<T, ComplianceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplianceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Compliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplianceAggregateArgs>(args: Subset<T, ComplianceAggregateArgs>): Prisma.PrismaPromise<GetComplianceAggregateType<T>>

    /**
     * Group by Compliance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplianceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplianceGroupByArgs['orderBy'] }
        : { orderBy?: ComplianceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplianceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplianceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Compliance model
   */
  readonly fields: ComplianceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Compliance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplianceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stall<T extends StallDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StallDefaultArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inspector<T extends Compliance$inspectorArgs<ExtArgs> = {}>(args?: Subset<T, Compliance$inspectorArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Compliance model
   */
  interface ComplianceFieldRefs {
    readonly compliance_id: FieldRef<"Compliance", 'Int'>
    readonly stall_id: FieldRef<"Compliance", 'Int'>
    readonly inspector_id: FieldRef<"Compliance", 'Int'>
    readonly compliance_type: FieldRef<"Compliance", 'String'>
    readonly status: FieldRef<"Compliance", 'String'>
    readonly inspection_date: FieldRef<"Compliance", 'DateTime'>
    readonly remarks: FieldRef<"Compliance", 'String'>
    readonly evidence: FieldRef<"Compliance", 'Bytes'>
    readonly evidence_type: FieldRef<"Compliance", 'String'>
    readonly created_at: FieldRef<"Compliance", 'DateTime'>
    readonly updated_at: FieldRef<"Compliance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Compliance findUnique
   */
  export type ComplianceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compliance
     */
    select?: ComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compliance
     */
    omit?: ComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceInclude<ExtArgs> | null
    /**
     * Filter, which Compliance to fetch.
     */
    where: ComplianceWhereUniqueInput
  }

  /**
   * Compliance findUniqueOrThrow
   */
  export type ComplianceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compliance
     */
    select?: ComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compliance
     */
    omit?: ComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceInclude<ExtArgs> | null
    /**
     * Filter, which Compliance to fetch.
     */
    where: ComplianceWhereUniqueInput
  }

  /**
   * Compliance findFirst
   */
  export type ComplianceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compliance
     */
    select?: ComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compliance
     */
    omit?: ComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceInclude<ExtArgs> | null
    /**
     * Filter, which Compliance to fetch.
     */
    where?: ComplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Compliances to fetch.
     */
    orderBy?: ComplianceOrderByWithRelationInput | ComplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Compliances.
     */
    cursor?: ComplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Compliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Compliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Compliances.
     */
    distinct?: ComplianceScalarFieldEnum | ComplianceScalarFieldEnum[]
  }

  /**
   * Compliance findFirstOrThrow
   */
  export type ComplianceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compliance
     */
    select?: ComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compliance
     */
    omit?: ComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceInclude<ExtArgs> | null
    /**
     * Filter, which Compliance to fetch.
     */
    where?: ComplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Compliances to fetch.
     */
    orderBy?: ComplianceOrderByWithRelationInput | ComplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Compliances.
     */
    cursor?: ComplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Compliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Compliances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Compliances.
     */
    distinct?: ComplianceScalarFieldEnum | ComplianceScalarFieldEnum[]
  }

  /**
   * Compliance findMany
   */
  export type ComplianceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compliance
     */
    select?: ComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compliance
     */
    omit?: ComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceInclude<ExtArgs> | null
    /**
     * Filter, which Compliances to fetch.
     */
    where?: ComplianceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Compliances to fetch.
     */
    orderBy?: ComplianceOrderByWithRelationInput | ComplianceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Compliances.
     */
    cursor?: ComplianceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Compliances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Compliances.
     */
    skip?: number
    distinct?: ComplianceScalarFieldEnum | ComplianceScalarFieldEnum[]
  }

  /**
   * Compliance create
   */
  export type ComplianceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compliance
     */
    select?: ComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compliance
     */
    omit?: ComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceInclude<ExtArgs> | null
    /**
     * The data needed to create a Compliance.
     */
    data: XOR<ComplianceCreateInput, ComplianceUncheckedCreateInput>
  }

  /**
   * Compliance createMany
   */
  export type ComplianceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Compliances.
     */
    data: ComplianceCreateManyInput | ComplianceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Compliance update
   */
  export type ComplianceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compliance
     */
    select?: ComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compliance
     */
    omit?: ComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceInclude<ExtArgs> | null
    /**
     * The data needed to update a Compliance.
     */
    data: XOR<ComplianceUpdateInput, ComplianceUncheckedUpdateInput>
    /**
     * Choose, which Compliance to update.
     */
    where: ComplianceWhereUniqueInput
  }

  /**
   * Compliance updateMany
   */
  export type ComplianceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Compliances.
     */
    data: XOR<ComplianceUpdateManyMutationInput, ComplianceUncheckedUpdateManyInput>
    /**
     * Filter which Compliances to update
     */
    where?: ComplianceWhereInput
    /**
     * Limit how many Compliances to update.
     */
    limit?: number
  }

  /**
   * Compliance upsert
   */
  export type ComplianceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compliance
     */
    select?: ComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compliance
     */
    omit?: ComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceInclude<ExtArgs> | null
    /**
     * The filter to search for the Compliance to update in case it exists.
     */
    where: ComplianceWhereUniqueInput
    /**
     * In case the Compliance found by the `where` argument doesn't exist, create a new Compliance with this data.
     */
    create: XOR<ComplianceCreateInput, ComplianceUncheckedCreateInput>
    /**
     * In case the Compliance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplianceUpdateInput, ComplianceUncheckedUpdateInput>
  }

  /**
   * Compliance delete
   */
  export type ComplianceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compliance
     */
    select?: ComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compliance
     */
    omit?: ComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceInclude<ExtArgs> | null
    /**
     * Filter which Compliance to delete.
     */
    where: ComplianceWhereUniqueInput
  }

  /**
   * Compliance deleteMany
   */
  export type ComplianceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Compliances to delete
     */
    where?: ComplianceWhereInput
    /**
     * Limit how many Compliances to delete.
     */
    limit?: number
  }

  /**
   * Compliance.inspector
   */
  export type Compliance$inspectorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Compliance without action
   */
  export type ComplianceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Compliance
     */
    select?: ComplianceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Compliance
     */
    omit?: ComplianceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceInclude<ExtArgs> | null
  }


  /**
   * Model Complaint
   */

  export type AggregateComplaint = {
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  export type ComplaintAvgAggregateOutputType = {
    complaint_id: number | null
    stall_id: number | null
  }

  export type ComplaintSumAggregateOutputType = {
    complaint_id: number | null
    stall_id: number | null
  }

  export type ComplaintMinAggregateOutputType = {
    complaint_id: number | null
    stall_id: number | null
    complainant: string | null
    complaint_type: string | null
    description: string | null
    status: string | null
    resolution: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ComplaintMaxAggregateOutputType = {
    complaint_id: number | null
    stall_id: number | null
    complainant: string | null
    complaint_type: string | null
    description: string | null
    status: string | null
    resolution: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ComplaintCountAggregateOutputType = {
    complaint_id: number
    stall_id: number
    complainant: number
    complaint_type: number
    description: number
    status: number
    resolution: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ComplaintAvgAggregateInputType = {
    complaint_id?: true
    stall_id?: true
  }

  export type ComplaintSumAggregateInputType = {
    complaint_id?: true
    stall_id?: true
  }

  export type ComplaintMinAggregateInputType = {
    complaint_id?: true
    stall_id?: true
    complainant?: true
    complaint_type?: true
    description?: true
    status?: true
    resolution?: true
    created_at?: true
    updated_at?: true
  }

  export type ComplaintMaxAggregateInputType = {
    complaint_id?: true
    stall_id?: true
    complainant?: true
    complaint_type?: true
    description?: true
    status?: true
    resolution?: true
    created_at?: true
    updated_at?: true
  }

  export type ComplaintCountAggregateInputType = {
    complaint_id?: true
    stall_id?: true
    complainant?: true
    complaint_type?: true
    description?: true
    status?: true
    resolution?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ComplaintAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaint to aggregate.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Complaints
    **/
    _count?: true | ComplaintCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplaintAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplaintSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplaintMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplaintMaxAggregateInputType
  }

  export type GetComplaintAggregateType<T extends ComplaintAggregateArgs> = {
        [P in keyof T & keyof AggregateComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaint[P]>
      : GetScalarType<T[P], AggregateComplaint[P]>
  }




  export type ComplaintGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplaintWhereInput
    orderBy?: ComplaintOrderByWithAggregationInput | ComplaintOrderByWithAggregationInput[]
    by: ComplaintScalarFieldEnum[] | ComplaintScalarFieldEnum
    having?: ComplaintScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplaintCountAggregateInputType | true
    _avg?: ComplaintAvgAggregateInputType
    _sum?: ComplaintSumAggregateInputType
    _min?: ComplaintMinAggregateInputType
    _max?: ComplaintMaxAggregateInputType
  }

  export type ComplaintGroupByOutputType = {
    complaint_id: number
    stall_id: number | null
    complainant: string | null
    complaint_type: string | null
    description: string | null
    status: string
    resolution: string | null
    created_at: Date
    updated_at: Date
    _count: ComplaintCountAggregateOutputType | null
    _avg: ComplaintAvgAggregateOutputType | null
    _sum: ComplaintSumAggregateOutputType | null
    _min: ComplaintMinAggregateOutputType | null
    _max: ComplaintMaxAggregateOutputType | null
  }

  type GetComplaintGroupByPayload<T extends ComplaintGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplaintGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplaintGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
        }
      >
    >


  export type ComplaintSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    complaint_id?: boolean
    stall_id?: boolean
    complainant?: boolean
    complaint_type?: boolean
    description?: boolean
    status?: boolean
    resolution?: boolean
    created_at?: boolean
    updated_at?: boolean
    stall?: boolean | Complaint$stallArgs<ExtArgs>
  }, ExtArgs["result"]["complaint"]>



  export type ComplaintSelectScalar = {
    complaint_id?: boolean
    stall_id?: boolean
    complainant?: boolean
    complaint_type?: boolean
    description?: boolean
    status?: boolean
    resolution?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ComplaintOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"complaint_id" | "stall_id" | "complainant" | "complaint_type" | "description" | "status" | "resolution" | "created_at" | "updated_at", ExtArgs["result"]["complaint"]>
  export type ComplaintInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stall?: boolean | Complaint$stallArgs<ExtArgs>
  }

  export type $ComplaintPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Complaint"
    objects: {
      stall: Prisma.$StallPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      complaint_id: number
      stall_id: number | null
      complainant: string | null
      complaint_type: string | null
      description: string | null
      status: string
      resolution: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["complaint"]>
    composites: {}
  }

  type ComplaintGetPayload<S extends boolean | null | undefined | ComplaintDefaultArgs> = $Result.GetResult<Prisma.$ComplaintPayload, S>

  type ComplaintCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplaintFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplaintCountAggregateInputType | true
    }

  export interface ComplaintDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Complaint'], meta: { name: 'Complaint' } }
    /**
     * Find zero or one Complaint that matches the filter.
     * @param {ComplaintFindUniqueArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintFindUniqueArgs>(args: SelectSubset<T, ComplaintFindUniqueArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Complaint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplaintFindUniqueOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplaintFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintFindFirstArgs>(args?: SelectSubset<T, ComplaintFindFirstArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Complaint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplaintFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaint.findMany()
     * 
     * // Get first 10 Complaints
     * const complaints = await prisma.complaint.findMany({ take: 10 })
     * 
     * // Only select the `complaint_id`
     * const complaintWithComplaint_idOnly = await prisma.complaint.findMany({ select: { complaint_id: true } })
     * 
     */
    findMany<T extends ComplaintFindManyArgs>(args?: SelectSubset<T, ComplaintFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Complaint.
     * @param {ComplaintCreateArgs} args - Arguments to create a Complaint.
     * @example
     * // Create one Complaint
     * const Complaint = await prisma.complaint.create({
     *   data: {
     *     // ... data to create a Complaint
     *   }
     * })
     * 
     */
    create<T extends ComplaintCreateArgs>(args: SelectSubset<T, ComplaintCreateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Complaints.
     * @param {ComplaintCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplaintCreateManyArgs>(args?: SelectSubset<T, ComplaintCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Complaint.
     * @param {ComplaintDeleteArgs} args - Arguments to delete one Complaint.
     * @example
     * // Delete one Complaint
     * const Complaint = await prisma.complaint.delete({
     *   where: {
     *     // ... filter to delete one Complaint
     *   }
     * })
     * 
     */
    delete<T extends ComplaintDeleteArgs>(args: SelectSubset<T, ComplaintDeleteArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Complaint.
     * @param {ComplaintUpdateArgs} args - Arguments to update one Complaint.
     * @example
     * // Update one Complaint
     * const complaint = await prisma.complaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplaintUpdateArgs>(args: SelectSubset<T, ComplaintUpdateArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Complaints.
     * @param {ComplaintDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplaintDeleteManyArgs>(args?: SelectSubset<T, ComplaintDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaint = await prisma.complaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplaintUpdateManyArgs>(args: SelectSubset<T, ComplaintUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Complaint.
     * @param {ComplaintUpsertArgs} args - Arguments to update or create a Complaint.
     * @example
     * // Update or create a Complaint
     * const complaint = await prisma.complaint.upsert({
     *   create: {
     *     // ... data to create a Complaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaint we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintUpsertArgs>(args: SelectSubset<T, ComplaintUpsertArgs<ExtArgs>>): Prisma__ComplaintClient<$Result.GetResult<Prisma.$ComplaintPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaint.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
    **/
    count<T extends ComplaintCountArgs>(
      args?: Subset<T, ComplaintCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplaintAggregateArgs>(args: Subset<T, ComplaintAggregateArgs>): Prisma.PrismaPromise<GetComplaintAggregateType<T>>

    /**
     * Group by Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplaintGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplaintGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Complaint model
   */
  readonly fields: ComplaintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Complaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stall<T extends Complaint$stallArgs<ExtArgs> = {}>(args?: Subset<T, Complaint$stallArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Complaint model
   */
  interface ComplaintFieldRefs {
    readonly complaint_id: FieldRef<"Complaint", 'Int'>
    readonly stall_id: FieldRef<"Complaint", 'Int'>
    readonly complainant: FieldRef<"Complaint", 'String'>
    readonly complaint_type: FieldRef<"Complaint", 'String'>
    readonly description: FieldRef<"Complaint", 'String'>
    readonly status: FieldRef<"Complaint", 'String'>
    readonly resolution: FieldRef<"Complaint", 'String'>
    readonly created_at: FieldRef<"Complaint", 'DateTime'>
    readonly updated_at: FieldRef<"Complaint", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Complaint findUnique
   */
  export type ComplaintFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findUniqueOrThrow
   */
  export type ComplaintFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint findFirst
   */
  export type ComplaintFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findFirstOrThrow
   */
  export type ComplaintFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint findMany
   */
  export type ComplaintFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter, which Complaints to fetch.
     */
    where?: ComplaintWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Complaints to fetch.
     */
    orderBy?: ComplaintOrderByWithRelationInput | ComplaintOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Complaints.
     */
    cursor?: ComplaintWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Complaints.
     */
    skip?: number
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[]
  }

  /**
   * Complaint create
   */
  export type ComplaintCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to create a Complaint.
     */
    data: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
  }

  /**
   * Complaint createMany
   */
  export type ComplaintCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintCreateManyInput | ComplaintCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Complaint update
   */
  export type ComplaintUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The data needed to update a Complaint.
     */
    data: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
    /**
     * Choose, which Complaint to update.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint updateMany
   */
  export type ComplaintUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Complaints.
     */
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyInput>
    /**
     * Filter which Complaints to update
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to update.
     */
    limit?: number
  }

  /**
   * Complaint upsert
   */
  export type ComplaintUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * The filter to search for the Complaint to update in case it exists.
     */
    where: ComplaintWhereUniqueInput
    /**
     * In case the Complaint found by the `where` argument doesn't exist, create a new Complaint with this data.
     */
    create: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>
    /**
     * In case the Complaint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>
  }

  /**
   * Complaint delete
   */
  export type ComplaintDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
    /**
     * Filter which Complaint to delete.
     */
    where: ComplaintWhereUniqueInput
  }

  /**
   * Complaint deleteMany
   */
  export type ComplaintDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Complaints to delete
     */
    where?: ComplaintWhereInput
    /**
     * Limit how many Complaints to delete.
     */
    limit?: number
  }

  /**
   * Complaint.stall
   */
  export type Complaint$stallArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    where?: StallWhereInput
  }

  /**
   * Complaint without action
   */
  export type ComplaintDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorAvgAggregateOutputType = {
    vendor_id: number | null
    stall_id: number | null
  }

  export type VendorSumAggregateOutputType = {
    vendor_id: number | null
    stall_id: number | null
  }

  export type VendorMinAggregateOutputType = {
    vendor_id: number | null
    stall_id: number | null
    vendor_name: string | null
    contact_number: string | null
    email: string | null
    product_type: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    vendor_id: number | null
    stall_id: number | null
    vendor_name: string | null
    contact_number: string | null
    email: string | null
    product_type: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorCountAggregateOutputType = {
    vendor_id: number
    stall_id: number
    vendor_name: number
    contact_number: number
    email: number
    product_type: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VendorAvgAggregateInputType = {
    vendor_id?: true
    stall_id?: true
  }

  export type VendorSumAggregateInputType = {
    vendor_id?: true
    stall_id?: true
  }

  export type VendorMinAggregateInputType = {
    vendor_id?: true
    stall_id?: true
    vendor_name?: true
    contact_number?: true
    email?: true
    product_type?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorMaxAggregateInputType = {
    vendor_id?: true
    stall_id?: true
    vendor_name?: true
    contact_number?: true
    email?: true
    product_type?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorCountAggregateInputType = {
    vendor_id?: true
    stall_id?: true
    vendor_name?: true
    contact_number?: true
    email?: true
    product_type?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _avg?: VendorAvgAggregateInputType
    _sum?: VendorSumAggregateInputType
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    vendor_id: number
    stall_id: number | null
    vendor_name: string
    contact_number: string | null
    email: string | null
    product_type: string | null
    status: string
    created_at: Date
    updated_at: Date
    _count: VendorCountAggregateOutputType | null
    _avg: VendorAvgAggregateOutputType | null
    _sum: VendorSumAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    vendor_id?: boolean
    stall_id?: boolean
    vendor_name?: boolean
    contact_number?: boolean
    email?: boolean
    product_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    stall?: boolean | Vendor$stallArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>



  export type VendorSelectScalar = {
    vendor_id?: boolean
    stall_id?: boolean
    vendor_name?: boolean
    contact_number?: boolean
    email?: boolean
    product_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"vendor_id" | "stall_id" | "vendor_name" | "contact_number" | "email" | "product_type" | "status" | "created_at" | "updated_at", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stall?: boolean | Vendor$stallArgs<ExtArgs>
  }

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      stall: Prisma.$StallPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      vendor_id: number
      stall_id: number | null
      vendor_name: string
      contact_number: string | null
      email: string | null
      product_type: string | null
      status: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `vendor_id`
     * const vendorWithVendor_idOnly = await prisma.vendor.findMany({ select: { vendor_id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    stall<T extends Vendor$stallArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$stallArgs<ExtArgs>>): Prisma__StallClient<$Result.GetResult<Prisma.$StallPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly vendor_id: FieldRef<"Vendor", 'Int'>
    readonly stall_id: FieldRef<"Vendor", 'Int'>
    readonly vendor_name: FieldRef<"Vendor", 'String'>
    readonly contact_number: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly product_type: FieldRef<"Vendor", 'String'>
    readonly status: FieldRef<"Vendor", 'String'>
    readonly created_at: FieldRef<"Vendor", 'DateTime'>
    readonly updated_at: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor.stall
   */
  export type Vendor$stallArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stall
     */
    select?: StallSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stall
     */
    omit?: StallOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StallInclude<ExtArgs> | null
    where?: StallWhereInput
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogAvgAggregateOutputType = {
    log_id: number | null
    employee_id: number | null
    entity_id: number | null
  }

  export type ActivityLogSumAggregateOutputType = {
    log_id: number | null
    employee_id: number | null
    entity_id: number | null
  }

  export type ActivityLogMinAggregateOutputType = {
    log_id: number | null
    employee_id: number | null
    action: string | null
    description: string | null
    entity_type: string | null
    entity_id: number | null
    ip_address: string | null
    created_at: Date | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    log_id: number | null
    employee_id: number | null
    action: string | null
    description: string | null
    entity_type: string | null
    entity_id: number | null
    ip_address: string | null
    created_at: Date | null
  }

  export type ActivityLogCountAggregateOutputType = {
    log_id: number
    employee_id: number
    action: number
    description: number
    entity_type: number
    entity_id: number
    ip_address: number
    created_at: number
    _all: number
  }


  export type ActivityLogAvgAggregateInputType = {
    log_id?: true
    employee_id?: true
    entity_id?: true
  }

  export type ActivityLogSumAggregateInputType = {
    log_id?: true
    employee_id?: true
    entity_id?: true
  }

  export type ActivityLogMinAggregateInputType = {
    log_id?: true
    employee_id?: true
    action?: true
    description?: true
    entity_type?: true
    entity_id?: true
    ip_address?: true
    created_at?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    log_id?: true
    employee_id?: true
    action?: true
    description?: true
    entity_type?: true
    entity_id?: true
    ip_address?: true
    created_at?: true
  }

  export type ActivityLogCountAggregateInputType = {
    log_id?: true
    employee_id?: true
    action?: true
    description?: true
    entity_type?: true
    entity_id?: true
    ip_address?: true
    created_at?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ActivityLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ActivityLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _avg?: ActivityLogAvgAggregateInputType
    _sum?: ActivityLogSumAggregateInputType
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    log_id: number
    employee_id: number | null
    action: string
    description: string | null
    entity_type: string | null
    entity_id: number | null
    ip_address: string | null
    created_at: Date
    _count: ActivityLogCountAggregateOutputType | null
    _avg: ActivityLogAvgAggregateOutputType | null
    _sum: ActivityLogSumAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    log_id?: boolean
    employee_id?: boolean
    action?: boolean
    description?: boolean
    entity_type?: boolean
    entity_id?: boolean
    ip_address?: boolean
    created_at?: boolean
    employee?: boolean | ActivityLog$employeeArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>



  export type ActivityLogSelectScalar = {
    log_id?: boolean
    employee_id?: boolean
    action?: boolean
    description?: boolean
    entity_type?: boolean
    entity_id?: boolean
    ip_address?: boolean
    created_at?: boolean
  }

  export type ActivityLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"log_id" | "employee_id" | "action" | "description" | "entity_type" | "entity_id" | "ip_address" | "created_at", ExtArgs["result"]["activityLog"]>
  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | ActivityLog$employeeArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      log_id: number
      employee_id: number | null
      action: string
      description: string | null
      entity_type: string | null
      entity_id: number | null
      ip_address: string | null
      created_at: Date
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `log_id`
     * const activityLogWithLog_idOnly = await prisma.activityLog.findMany({ select: { log_id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends ActivityLog$employeeArgs<ExtArgs> = {}>(args?: Subset<T, ActivityLog$employeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */
  interface ActivityLogFieldRefs {
    readonly log_id: FieldRef<"ActivityLog", 'Int'>
    readonly employee_id: FieldRef<"ActivityLog", 'Int'>
    readonly action: FieldRef<"ActivityLog", 'String'>
    readonly description: FieldRef<"ActivityLog", 'String'>
    readonly entity_type: FieldRef<"ActivityLog", 'String'>
    readonly entity_id: FieldRef<"ActivityLog", 'Int'>
    readonly ip_address: FieldRef<"ActivityLog", 'String'>
    readonly created_at: FieldRef<"ActivityLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to update.
     */
    limit?: number
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
    /**
     * Limit how many ActivityLogs to delete.
     */
    limit?: number
  }

  /**
   * ActivityLog.employee
   */
  export type ActivityLog$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ActivityLog
     */
    omit?: ActivityLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    subscription_id: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    subscription_id: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    subscription_id: number | null
    name: string | null
    email: string | null
    subscription_type: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    subscription_id: number | null
    name: string | null
    email: string | null
    subscription_type: string | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    subscription_id: number
    name: number
    email: number
    subscription_type: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    subscription_id?: true
  }

  export type SubscriptionSumAggregateInputType = {
    subscription_id?: true
  }

  export type SubscriptionMinAggregateInputType = {
    subscription_id?: true
    name?: true
    email?: true
    subscription_type?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    subscription_id?: true
    name?: true
    email?: true
    subscription_type?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionCountAggregateInputType = {
    subscription_id?: true
    name?: true
    email?: true
    subscription_type?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    subscription_id: number
    name: string
    email: string
    subscription_type: string | null
    status: string
    created_at: Date
    updated_at: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    subscription_id?: boolean
    name?: boolean
    email?: boolean
    subscription_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["subscription"]>



  export type SubscriptionSelectScalar = {
    subscription_id?: boolean
    name?: boolean
    email?: boolean
    subscription_type?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"subscription_id" | "name" | "email" | "subscription_type" | "status" | "created_at" | "updated_at", ExtArgs["result"]["subscription"]>

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      subscription_id: number
      name: string
      email: string
      subscription_type: string | null
      status: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `subscription_id`
     * const subscriptionWithSubscription_idOnly = await prisma.subscription.findMany({ select: { subscription_id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly subscription_id: FieldRef<"Subscription", 'Int'>
    readonly name: FieldRef<"Subscription", 'String'>
    readonly email: FieldRef<"Subscription", 'String'>
    readonly subscription_type: FieldRef<"Subscription", 'String'>
    readonly status: FieldRef<"Subscription", 'String'>
    readonly created_at: FieldRef<"Subscription", 'DateTime'>
    readonly updated_at: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const BranchScalarFieldEnum: {
    branch_id: 'branch_id',
    branch_name: 'branch_name',
    location: 'location',
    address: 'address',
    contact_number: 'contact_number',
    email: 'email',
    description: 'description',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BranchScalarFieldEnum = (typeof BranchScalarFieldEnum)[keyof typeof BranchScalarFieldEnum]


  export const FloorScalarFieldEnum: {
    floor_id: 'floor_id',
    branch_id: 'branch_id',
    floor_name: 'floor_name',
    floor_number: 'floor_number',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type FloorScalarFieldEnum = (typeof FloorScalarFieldEnum)[keyof typeof FloorScalarFieldEnum]


  export const SectionScalarFieldEnum: {
    section_id: 'section_id',
    branch_id: 'branch_id',
    floor_id: 'floor_id',
    section_name: 'section_name',
    description: 'description',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SectionScalarFieldEnum = (typeof SectionScalarFieldEnum)[keyof typeof SectionScalarFieldEnum]


  export const StallScalarFieldEnum: {
    stall_id: 'stall_id',
    stall_number: 'stall_number',
    stall_name: 'stall_name',
    stall_type: 'stall_type',
    stall_size: 'stall_size',
    stall_location: 'stall_location',
    size: 'size',
    area_sqm: 'area_sqm',
    floor_id: 'floor_id',
    section_id: 'section_id',
    monthly_rent: 'monthly_rent',
    rental_price: 'rental_price',
    status: 'status',
    branch_id: 'branch_id',
    stallholder_id: 'stallholder_id',
    floor_level: 'floor_level',
    section: 'section',
    description: 'description',
    price_type: 'price_type',
    is_available: 'is_available',
    base_rate: 'base_rate',
    rate_per_sqm: 'rate_per_sqm',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StallScalarFieldEnum = (typeof StallScalarFieldEnum)[keyof typeof StallScalarFieldEnum]


  export const StallImageScalarFieldEnum: {
    image_id: 'image_id',
    stall_id: 'stall_id',
    filename: 'filename',
    image_data: 'image_data',
    mime_type: 'mime_type',
    is_primary: 'is_primary',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StallImageScalarFieldEnum = (typeof StallImageScalarFieldEnum)[keyof typeof StallImageScalarFieldEnum]


  export const StallholderScalarFieldEnum: {
    stallholder_id: 'stallholder_id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    phone_number: 'phone_number',
    address: 'address',
    business_name: 'business_name',
    business_type: 'business_type',
    branch_id: 'branch_id',
    status: 'status',
    password: 'password',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StallholderScalarFieldEnum = (typeof StallholderScalarFieldEnum)[keyof typeof StallholderScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    employee_id: 'employee_id',
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    phone_number: 'phone_number',
    position: 'position',
    role: 'role',
    branch_id: 'branch_id',
    password: 'password',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const ApplicationScalarFieldEnum: {
    application_id: 'application_id',
    applicant_name: 'applicant_name',
    applicant_email: 'applicant_email',
    applicant_phone: 'applicant_phone',
    business_name: 'business_name',
    business_type: 'business_type',
    stall_id: 'stall_id',
    stallholder_id: 'stallholder_id',
    status: 'status',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ApplicationScalarFieldEnum = (typeof ApplicationScalarFieldEnum)[keyof typeof ApplicationScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    payment_id: 'payment_id',
    stall_id: 'stall_id',
    stallholder_id: 'stallholder_id',
    amount: 'amount',
    payment_date: 'payment_date',
    payment_type: 'payment_type',
    payment_method: 'payment_method',
    status: 'status',
    reference_no: 'reference_no',
    collector_id: 'collector_id',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ComplianceScalarFieldEnum: {
    compliance_id: 'compliance_id',
    stall_id: 'stall_id',
    inspector_id: 'inspector_id',
    compliance_type: 'compliance_type',
    status: 'status',
    inspection_date: 'inspection_date',
    remarks: 'remarks',
    evidence: 'evidence',
    evidence_type: 'evidence_type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ComplianceScalarFieldEnum = (typeof ComplianceScalarFieldEnum)[keyof typeof ComplianceScalarFieldEnum]


  export const ComplaintScalarFieldEnum: {
    complaint_id: 'complaint_id',
    stall_id: 'stall_id',
    complainant: 'complainant',
    complaint_type: 'complaint_type',
    description: 'description',
    status: 'status',
    resolution: 'resolution',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ComplaintScalarFieldEnum = (typeof ComplaintScalarFieldEnum)[keyof typeof ComplaintScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    vendor_id: 'vendor_id',
    stall_id: 'stall_id',
    vendor_name: 'vendor_name',
    contact_number: 'contact_number',
    email: 'email',
    product_type: 'product_type',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    log_id: 'log_id',
    employee_id: 'employee_id',
    action: 'action',
    description: 'description',
    entity_type: 'entity_type',
    entity_id: 'entity_id',
    ip_address: 'ip_address',
    created_at: 'created_at'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    subscription_id: 'subscription_id',
    name: 'name',
    email: 'email',
    subscription_type: 'subscription_type',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const BranchOrderByRelevanceFieldEnum: {
    branch_name: 'branch_name',
    location: 'location',
    address: 'address',
    contact_number: 'contact_number',
    email: 'email',
    description: 'description',
    status: 'status'
  };

  export type BranchOrderByRelevanceFieldEnum = (typeof BranchOrderByRelevanceFieldEnum)[keyof typeof BranchOrderByRelevanceFieldEnum]


  export const FloorOrderByRelevanceFieldEnum: {
    floor_name: 'floor_name',
    description: 'description'
  };

  export type FloorOrderByRelevanceFieldEnum = (typeof FloorOrderByRelevanceFieldEnum)[keyof typeof FloorOrderByRelevanceFieldEnum]


  export const SectionOrderByRelevanceFieldEnum: {
    section_name: 'section_name',
    description: 'description'
  };

  export type SectionOrderByRelevanceFieldEnum = (typeof SectionOrderByRelevanceFieldEnum)[keyof typeof SectionOrderByRelevanceFieldEnum]


  export const StallOrderByRelevanceFieldEnum: {
    stall_number: 'stall_number',
    stall_name: 'stall_name',
    stall_type: 'stall_type',
    stall_size: 'stall_size',
    stall_location: 'stall_location',
    size: 'size',
    status: 'status',
    floor_level: 'floor_level',
    section: 'section',
    description: 'description',
    price_type: 'price_type'
  };

  export type StallOrderByRelevanceFieldEnum = (typeof StallOrderByRelevanceFieldEnum)[keyof typeof StallOrderByRelevanceFieldEnum]


  export const StallImageOrderByRelevanceFieldEnum: {
    filename: 'filename',
    mime_type: 'mime_type'
  };

  export type StallImageOrderByRelevanceFieldEnum = (typeof StallImageOrderByRelevanceFieldEnum)[keyof typeof StallImageOrderByRelevanceFieldEnum]


  export const StallholderOrderByRelevanceFieldEnum: {
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    phone_number: 'phone_number',
    address: 'address',
    business_name: 'business_name',
    business_type: 'business_type',
    status: 'status',
    password: 'password'
  };

  export type StallholderOrderByRelevanceFieldEnum = (typeof StallholderOrderByRelevanceFieldEnum)[keyof typeof StallholderOrderByRelevanceFieldEnum]


  export const EmployeeOrderByRelevanceFieldEnum: {
    first_name: 'first_name',
    last_name: 'last_name',
    email: 'email',
    phone_number: 'phone_number',
    position: 'position',
    role: 'role',
    password: 'password',
    status: 'status'
  };

  export type EmployeeOrderByRelevanceFieldEnum = (typeof EmployeeOrderByRelevanceFieldEnum)[keyof typeof EmployeeOrderByRelevanceFieldEnum]


  export const ApplicationOrderByRelevanceFieldEnum: {
    applicant_name: 'applicant_name',
    applicant_email: 'applicant_email',
    applicant_phone: 'applicant_phone',
    business_name: 'business_name',
    business_type: 'business_type',
    status: 'status',
    notes: 'notes'
  };

  export type ApplicationOrderByRelevanceFieldEnum = (typeof ApplicationOrderByRelevanceFieldEnum)[keyof typeof ApplicationOrderByRelevanceFieldEnum]


  export const PaymentOrderByRelevanceFieldEnum: {
    payment_type: 'payment_type',
    payment_method: 'payment_method',
    status: 'status',
    reference_no: 'reference_no',
    notes: 'notes'
  };

  export type PaymentOrderByRelevanceFieldEnum = (typeof PaymentOrderByRelevanceFieldEnum)[keyof typeof PaymentOrderByRelevanceFieldEnum]


  export const ComplianceOrderByRelevanceFieldEnum: {
    compliance_type: 'compliance_type',
    status: 'status',
    remarks: 'remarks',
    evidence_type: 'evidence_type'
  };

  export type ComplianceOrderByRelevanceFieldEnum = (typeof ComplianceOrderByRelevanceFieldEnum)[keyof typeof ComplianceOrderByRelevanceFieldEnum]


  export const ComplaintOrderByRelevanceFieldEnum: {
    complainant: 'complainant',
    complaint_type: 'complaint_type',
    description: 'description',
    status: 'status',
    resolution: 'resolution'
  };

  export type ComplaintOrderByRelevanceFieldEnum = (typeof ComplaintOrderByRelevanceFieldEnum)[keyof typeof ComplaintOrderByRelevanceFieldEnum]


  export const VendorOrderByRelevanceFieldEnum: {
    vendor_name: 'vendor_name',
    contact_number: 'contact_number',
    email: 'email',
    product_type: 'product_type',
    status: 'status'
  };

  export type VendorOrderByRelevanceFieldEnum = (typeof VendorOrderByRelevanceFieldEnum)[keyof typeof VendorOrderByRelevanceFieldEnum]


  export const ActivityLogOrderByRelevanceFieldEnum: {
    action: 'action',
    description: 'description',
    entity_type: 'entity_type',
    ip_address: 'ip_address'
  };

  export type ActivityLogOrderByRelevanceFieldEnum = (typeof ActivityLogOrderByRelevanceFieldEnum)[keyof typeof ActivityLogOrderByRelevanceFieldEnum]


  export const SubscriptionOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    subscription_type: 'subscription_type',
    status: 'status'
  };

  export type SubscriptionOrderByRelevanceFieldEnum = (typeof SubscriptionOrderByRelevanceFieldEnum)[keyof typeof SubscriptionOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type BranchWhereInput = {
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    branch_id?: IntFilter<"Branch"> | number
    branch_name?: StringFilter<"Branch"> | string
    location?: StringNullableFilter<"Branch"> | string | null
    address?: StringNullableFilter<"Branch"> | string | null
    contact_number?: StringNullableFilter<"Branch"> | string | null
    email?: StringNullableFilter<"Branch"> | string | null
    description?: StringNullableFilter<"Branch"> | string | null
    status?: StringFilter<"Branch"> | string
    created_at?: DateTimeFilter<"Branch"> | Date | string
    updated_at?: DateTimeFilter<"Branch"> | Date | string
    stalls?: StallListRelationFilter
    employees?: EmployeeListRelationFilter
    floors?: FloorListRelationFilter
    sections?: SectionListRelationFilter
    stallholders?: StallholderListRelationFilter
  }

  export type BranchOrderByWithRelationInput = {
    branch_id?: SortOrder
    branch_name?: SortOrder
    location?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contact_number?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stalls?: StallOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    floors?: FloorOrderByRelationAggregateInput
    sections?: SectionOrderByRelationAggregateInput
    stallholders?: StallholderOrderByRelationAggregateInput
    _relevance?: BranchOrderByRelevanceInput
  }

  export type BranchWhereUniqueInput = Prisma.AtLeast<{
    branch_id?: number
    AND?: BranchWhereInput | BranchWhereInput[]
    OR?: BranchWhereInput[]
    NOT?: BranchWhereInput | BranchWhereInput[]
    branch_name?: StringFilter<"Branch"> | string
    location?: StringNullableFilter<"Branch"> | string | null
    address?: StringNullableFilter<"Branch"> | string | null
    contact_number?: StringNullableFilter<"Branch"> | string | null
    email?: StringNullableFilter<"Branch"> | string | null
    description?: StringNullableFilter<"Branch"> | string | null
    status?: StringFilter<"Branch"> | string
    created_at?: DateTimeFilter<"Branch"> | Date | string
    updated_at?: DateTimeFilter<"Branch"> | Date | string
    stalls?: StallListRelationFilter
    employees?: EmployeeListRelationFilter
    floors?: FloorListRelationFilter
    sections?: SectionListRelationFilter
    stallholders?: StallholderListRelationFilter
  }, "branch_id">

  export type BranchOrderByWithAggregationInput = {
    branch_id?: SortOrder
    branch_name?: SortOrder
    location?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    contact_number?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BranchCountOrderByAggregateInput
    _avg?: BranchAvgOrderByAggregateInput
    _max?: BranchMaxOrderByAggregateInput
    _min?: BranchMinOrderByAggregateInput
    _sum?: BranchSumOrderByAggregateInput
  }

  export type BranchScalarWhereWithAggregatesInput = {
    AND?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    OR?: BranchScalarWhereWithAggregatesInput[]
    NOT?: BranchScalarWhereWithAggregatesInput | BranchScalarWhereWithAggregatesInput[]
    branch_id?: IntWithAggregatesFilter<"Branch"> | number
    branch_name?: StringWithAggregatesFilter<"Branch"> | string
    location?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    address?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    contact_number?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    email?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    description?: StringNullableWithAggregatesFilter<"Branch"> | string | null
    status?: StringWithAggregatesFilter<"Branch"> | string
    created_at?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Branch"> | Date | string
  }

  export type FloorWhereInput = {
    AND?: FloorWhereInput | FloorWhereInput[]
    OR?: FloorWhereInput[]
    NOT?: FloorWhereInput | FloorWhereInput[]
    floor_id?: IntFilter<"Floor"> | number
    branch_id?: IntFilter<"Floor"> | number
    floor_name?: StringFilter<"Floor"> | string
    floor_number?: IntFilter<"Floor"> | number
    description?: StringNullableFilter<"Floor"> | string | null
    created_at?: DateTimeFilter<"Floor"> | Date | string
    updated_at?: DateTimeFilter<"Floor"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    stalls?: StallListRelationFilter
    sections?: SectionListRelationFilter
  }

  export type FloorOrderByWithRelationInput = {
    floor_id?: SortOrder
    branch_id?: SortOrder
    floor_name?: SortOrder
    floor_number?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    branch?: BranchOrderByWithRelationInput
    stalls?: StallOrderByRelationAggregateInput
    sections?: SectionOrderByRelationAggregateInput
    _relevance?: FloorOrderByRelevanceInput
  }

  export type FloorWhereUniqueInput = Prisma.AtLeast<{
    floor_id?: number
    AND?: FloorWhereInput | FloorWhereInput[]
    OR?: FloorWhereInput[]
    NOT?: FloorWhereInput | FloorWhereInput[]
    branch_id?: IntFilter<"Floor"> | number
    floor_name?: StringFilter<"Floor"> | string
    floor_number?: IntFilter<"Floor"> | number
    description?: StringNullableFilter<"Floor"> | string | null
    created_at?: DateTimeFilter<"Floor"> | Date | string
    updated_at?: DateTimeFilter<"Floor"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    stalls?: StallListRelationFilter
    sections?: SectionListRelationFilter
  }, "floor_id">

  export type FloorOrderByWithAggregationInput = {
    floor_id?: SortOrder
    branch_id?: SortOrder
    floor_name?: SortOrder
    floor_number?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: FloorCountOrderByAggregateInput
    _avg?: FloorAvgOrderByAggregateInput
    _max?: FloorMaxOrderByAggregateInput
    _min?: FloorMinOrderByAggregateInput
    _sum?: FloorSumOrderByAggregateInput
  }

  export type FloorScalarWhereWithAggregatesInput = {
    AND?: FloorScalarWhereWithAggregatesInput | FloorScalarWhereWithAggregatesInput[]
    OR?: FloorScalarWhereWithAggregatesInput[]
    NOT?: FloorScalarWhereWithAggregatesInput | FloorScalarWhereWithAggregatesInput[]
    floor_id?: IntWithAggregatesFilter<"Floor"> | number
    branch_id?: IntWithAggregatesFilter<"Floor"> | number
    floor_name?: StringWithAggregatesFilter<"Floor"> | string
    floor_number?: IntWithAggregatesFilter<"Floor"> | number
    description?: StringNullableWithAggregatesFilter<"Floor"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Floor"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Floor"> | Date | string
  }

  export type SectionWhereInput = {
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    section_id?: IntFilter<"Section"> | number
    branch_id?: IntFilter<"Section"> | number
    floor_id?: IntNullableFilter<"Section"> | number | null
    section_name?: StringFilter<"Section"> | string
    description?: StringNullableFilter<"Section"> | string | null
    created_at?: DateTimeFilter<"Section"> | Date | string
    updated_at?: DateTimeFilter<"Section"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    floor?: XOR<FloorNullableScalarRelationFilter, FloorWhereInput> | null
    stalls?: StallListRelationFilter
  }

  export type SectionOrderByWithRelationInput = {
    section_id?: SortOrder
    branch_id?: SortOrder
    floor_id?: SortOrderInput | SortOrder
    section_name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    branch?: BranchOrderByWithRelationInput
    floor?: FloorOrderByWithRelationInput
    stalls?: StallOrderByRelationAggregateInput
    _relevance?: SectionOrderByRelevanceInput
  }

  export type SectionWhereUniqueInput = Prisma.AtLeast<{
    section_id?: number
    AND?: SectionWhereInput | SectionWhereInput[]
    OR?: SectionWhereInput[]
    NOT?: SectionWhereInput | SectionWhereInput[]
    branch_id?: IntFilter<"Section"> | number
    floor_id?: IntNullableFilter<"Section"> | number | null
    section_name?: StringFilter<"Section"> | string
    description?: StringNullableFilter<"Section"> | string | null
    created_at?: DateTimeFilter<"Section"> | Date | string
    updated_at?: DateTimeFilter<"Section"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    floor?: XOR<FloorNullableScalarRelationFilter, FloorWhereInput> | null
    stalls?: StallListRelationFilter
  }, "section_id">

  export type SectionOrderByWithAggregationInput = {
    section_id?: SortOrder
    branch_id?: SortOrder
    floor_id?: SortOrderInput | SortOrder
    section_name?: SortOrder
    description?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SectionCountOrderByAggregateInput
    _avg?: SectionAvgOrderByAggregateInput
    _max?: SectionMaxOrderByAggregateInput
    _min?: SectionMinOrderByAggregateInput
    _sum?: SectionSumOrderByAggregateInput
  }

  export type SectionScalarWhereWithAggregatesInput = {
    AND?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    OR?: SectionScalarWhereWithAggregatesInput[]
    NOT?: SectionScalarWhereWithAggregatesInput | SectionScalarWhereWithAggregatesInput[]
    section_id?: IntWithAggregatesFilter<"Section"> | number
    branch_id?: IntWithAggregatesFilter<"Section"> | number
    floor_id?: IntNullableWithAggregatesFilter<"Section"> | number | null
    section_name?: StringWithAggregatesFilter<"Section"> | string
    description?: StringNullableWithAggregatesFilter<"Section"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Section"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Section"> | Date | string
  }

  export type StallWhereInput = {
    AND?: StallWhereInput | StallWhereInput[]
    OR?: StallWhereInput[]
    NOT?: StallWhereInput | StallWhereInput[]
    stall_id?: IntFilter<"Stall"> | number
    stall_number?: StringNullableFilter<"Stall"> | string | null
    stall_name?: StringNullableFilter<"Stall"> | string | null
    stall_type?: StringNullableFilter<"Stall"> | string | null
    stall_size?: StringNullableFilter<"Stall"> | string | null
    stall_location?: StringNullableFilter<"Stall"> | string | null
    size?: StringNullableFilter<"Stall"> | string | null
    area_sqm?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    floor_id?: IntNullableFilter<"Stall"> | number | null
    section_id?: IntNullableFilter<"Stall"> | number | null
    monthly_rent?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    rental_price?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"Stall"> | string
    branch_id?: IntFilter<"Stall"> | number
    stallholder_id?: IntNullableFilter<"Stall"> | number | null
    floor_level?: StringNullableFilter<"Stall"> | string | null
    section?: StringNullableFilter<"Stall"> | string | null
    description?: StringNullableFilter<"Stall"> | string | null
    price_type?: StringNullableFilter<"Stall"> | string | null
    is_available?: BoolFilter<"Stall"> | boolean
    base_rate?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"Stall"> | Date | string
    updated_at?: DateTimeFilter<"Stall"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    floor?: XOR<FloorNullableScalarRelationFilter, FloorWhereInput> | null
    sectionRef?: XOR<SectionNullableScalarRelationFilter, SectionWhereInput> | null
    stallholder?: XOR<StallholderNullableScalarRelationFilter, StallholderWhereInput> | null
    images?: StallImageListRelationFilter
    payments?: PaymentListRelationFilter
    compliances?: ComplianceListRelationFilter
    complaints?: ComplaintListRelationFilter
    vendors?: VendorListRelationFilter
  }

  export type StallOrderByWithRelationInput = {
    stall_id?: SortOrder
    stall_number?: SortOrderInput | SortOrder
    stall_name?: SortOrderInput | SortOrder
    stall_type?: SortOrderInput | SortOrder
    stall_size?: SortOrderInput | SortOrder
    stall_location?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    area_sqm?: SortOrderInput | SortOrder
    floor_id?: SortOrderInput | SortOrder
    section_id?: SortOrderInput | SortOrder
    monthly_rent?: SortOrderInput | SortOrder
    rental_price?: SortOrderInput | SortOrder
    status?: SortOrder
    branch_id?: SortOrder
    stallholder_id?: SortOrderInput | SortOrder
    floor_level?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    price_type?: SortOrderInput | SortOrder
    is_available?: SortOrder
    base_rate?: SortOrderInput | SortOrder
    rate_per_sqm?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    branch?: BranchOrderByWithRelationInput
    floor?: FloorOrderByWithRelationInput
    sectionRef?: SectionOrderByWithRelationInput
    stallholder?: StallholderOrderByWithRelationInput
    images?: StallImageOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    compliances?: ComplianceOrderByRelationAggregateInput
    complaints?: ComplaintOrderByRelationAggregateInput
    vendors?: VendorOrderByRelationAggregateInput
    _relevance?: StallOrderByRelevanceInput
  }

  export type StallWhereUniqueInput = Prisma.AtLeast<{
    stall_id?: number
    AND?: StallWhereInput | StallWhereInput[]
    OR?: StallWhereInput[]
    NOT?: StallWhereInput | StallWhereInput[]
    stall_number?: StringNullableFilter<"Stall"> | string | null
    stall_name?: StringNullableFilter<"Stall"> | string | null
    stall_type?: StringNullableFilter<"Stall"> | string | null
    stall_size?: StringNullableFilter<"Stall"> | string | null
    stall_location?: StringNullableFilter<"Stall"> | string | null
    size?: StringNullableFilter<"Stall"> | string | null
    area_sqm?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    floor_id?: IntNullableFilter<"Stall"> | number | null
    section_id?: IntNullableFilter<"Stall"> | number | null
    monthly_rent?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    rental_price?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"Stall"> | string
    branch_id?: IntFilter<"Stall"> | number
    stallholder_id?: IntNullableFilter<"Stall"> | number | null
    floor_level?: StringNullableFilter<"Stall"> | string | null
    section?: StringNullableFilter<"Stall"> | string | null
    description?: StringNullableFilter<"Stall"> | string | null
    price_type?: StringNullableFilter<"Stall"> | string | null
    is_available?: BoolFilter<"Stall"> | boolean
    base_rate?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"Stall"> | Date | string
    updated_at?: DateTimeFilter<"Stall"> | Date | string
    branch?: XOR<BranchScalarRelationFilter, BranchWhereInput>
    floor?: XOR<FloorNullableScalarRelationFilter, FloorWhereInput> | null
    sectionRef?: XOR<SectionNullableScalarRelationFilter, SectionWhereInput> | null
    stallholder?: XOR<StallholderNullableScalarRelationFilter, StallholderWhereInput> | null
    images?: StallImageListRelationFilter
    payments?: PaymentListRelationFilter
    compliances?: ComplianceListRelationFilter
    complaints?: ComplaintListRelationFilter
    vendors?: VendorListRelationFilter
  }, "stall_id">

  export type StallOrderByWithAggregationInput = {
    stall_id?: SortOrder
    stall_number?: SortOrderInput | SortOrder
    stall_name?: SortOrderInput | SortOrder
    stall_type?: SortOrderInput | SortOrder
    stall_size?: SortOrderInput | SortOrder
    stall_location?: SortOrderInput | SortOrder
    size?: SortOrderInput | SortOrder
    area_sqm?: SortOrderInput | SortOrder
    floor_id?: SortOrderInput | SortOrder
    section_id?: SortOrderInput | SortOrder
    monthly_rent?: SortOrderInput | SortOrder
    rental_price?: SortOrderInput | SortOrder
    status?: SortOrder
    branch_id?: SortOrder
    stallholder_id?: SortOrderInput | SortOrder
    floor_level?: SortOrderInput | SortOrder
    section?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    price_type?: SortOrderInput | SortOrder
    is_available?: SortOrder
    base_rate?: SortOrderInput | SortOrder
    rate_per_sqm?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StallCountOrderByAggregateInput
    _avg?: StallAvgOrderByAggregateInput
    _max?: StallMaxOrderByAggregateInput
    _min?: StallMinOrderByAggregateInput
    _sum?: StallSumOrderByAggregateInput
  }

  export type StallScalarWhereWithAggregatesInput = {
    AND?: StallScalarWhereWithAggregatesInput | StallScalarWhereWithAggregatesInput[]
    OR?: StallScalarWhereWithAggregatesInput[]
    NOT?: StallScalarWhereWithAggregatesInput | StallScalarWhereWithAggregatesInput[]
    stall_id?: IntWithAggregatesFilter<"Stall"> | number
    stall_number?: StringNullableWithAggregatesFilter<"Stall"> | string | null
    stall_name?: StringNullableWithAggregatesFilter<"Stall"> | string | null
    stall_type?: StringNullableWithAggregatesFilter<"Stall"> | string | null
    stall_size?: StringNullableWithAggregatesFilter<"Stall"> | string | null
    stall_location?: StringNullableWithAggregatesFilter<"Stall"> | string | null
    size?: StringNullableWithAggregatesFilter<"Stall"> | string | null
    area_sqm?: DecimalNullableWithAggregatesFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    floor_id?: IntNullableWithAggregatesFilter<"Stall"> | number | null
    section_id?: IntNullableWithAggregatesFilter<"Stall"> | number | null
    monthly_rent?: DecimalNullableWithAggregatesFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    rental_price?: DecimalNullableWithAggregatesFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    status?: StringWithAggregatesFilter<"Stall"> | string
    branch_id?: IntWithAggregatesFilter<"Stall"> | number
    stallholder_id?: IntNullableWithAggregatesFilter<"Stall"> | number | null
    floor_level?: StringNullableWithAggregatesFilter<"Stall"> | string | null
    section?: StringNullableWithAggregatesFilter<"Stall"> | string | null
    description?: StringNullableWithAggregatesFilter<"Stall"> | string | null
    price_type?: StringNullableWithAggregatesFilter<"Stall"> | string | null
    is_available?: BoolWithAggregatesFilter<"Stall"> | boolean
    base_rate?: DecimalNullableWithAggregatesFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: DecimalNullableWithAggregatesFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeWithAggregatesFilter<"Stall"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Stall"> | Date | string
  }

  export type StallImageWhereInput = {
    AND?: StallImageWhereInput | StallImageWhereInput[]
    OR?: StallImageWhereInput[]
    NOT?: StallImageWhereInput | StallImageWhereInput[]
    image_id?: IntFilter<"StallImage"> | number
    stall_id?: IntFilter<"StallImage"> | number
    filename?: StringNullableFilter<"StallImage"> | string | null
    image_data?: BytesNullableFilter<"StallImage"> | Bytes | null
    mime_type?: StringNullableFilter<"StallImage"> | string | null
    is_primary?: BoolFilter<"StallImage"> | boolean
    created_at?: DateTimeFilter<"StallImage"> | Date | string
    updated_at?: DateTimeFilter<"StallImage"> | Date | string
    stall?: XOR<StallScalarRelationFilter, StallWhereInput>
  }

  export type StallImageOrderByWithRelationInput = {
    image_id?: SortOrder
    stall_id?: SortOrder
    filename?: SortOrderInput | SortOrder
    image_data?: SortOrderInput | SortOrder
    mime_type?: SortOrderInput | SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stall?: StallOrderByWithRelationInput
    _relevance?: StallImageOrderByRelevanceInput
  }

  export type StallImageWhereUniqueInput = Prisma.AtLeast<{
    image_id?: number
    AND?: StallImageWhereInput | StallImageWhereInput[]
    OR?: StallImageWhereInput[]
    NOT?: StallImageWhereInput | StallImageWhereInput[]
    stall_id?: IntFilter<"StallImage"> | number
    filename?: StringNullableFilter<"StallImage"> | string | null
    image_data?: BytesNullableFilter<"StallImage"> | Bytes | null
    mime_type?: StringNullableFilter<"StallImage"> | string | null
    is_primary?: BoolFilter<"StallImage"> | boolean
    created_at?: DateTimeFilter<"StallImage"> | Date | string
    updated_at?: DateTimeFilter<"StallImage"> | Date | string
    stall?: XOR<StallScalarRelationFilter, StallWhereInput>
  }, "image_id">

  export type StallImageOrderByWithAggregationInput = {
    image_id?: SortOrder
    stall_id?: SortOrder
    filename?: SortOrderInput | SortOrder
    image_data?: SortOrderInput | SortOrder
    mime_type?: SortOrderInput | SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StallImageCountOrderByAggregateInput
    _avg?: StallImageAvgOrderByAggregateInput
    _max?: StallImageMaxOrderByAggregateInput
    _min?: StallImageMinOrderByAggregateInput
    _sum?: StallImageSumOrderByAggregateInput
  }

  export type StallImageScalarWhereWithAggregatesInput = {
    AND?: StallImageScalarWhereWithAggregatesInput | StallImageScalarWhereWithAggregatesInput[]
    OR?: StallImageScalarWhereWithAggregatesInput[]
    NOT?: StallImageScalarWhereWithAggregatesInput | StallImageScalarWhereWithAggregatesInput[]
    image_id?: IntWithAggregatesFilter<"StallImage"> | number
    stall_id?: IntWithAggregatesFilter<"StallImage"> | number
    filename?: StringNullableWithAggregatesFilter<"StallImage"> | string | null
    image_data?: BytesNullableWithAggregatesFilter<"StallImage"> | Bytes | null
    mime_type?: StringNullableWithAggregatesFilter<"StallImage"> | string | null
    is_primary?: BoolWithAggregatesFilter<"StallImage"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"StallImage"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"StallImage"> | Date | string
  }

  export type StallholderWhereInput = {
    AND?: StallholderWhereInput | StallholderWhereInput[]
    OR?: StallholderWhereInput[]
    NOT?: StallholderWhereInput | StallholderWhereInput[]
    stallholder_id?: IntFilter<"Stallholder"> | number
    first_name?: StringFilter<"Stallholder"> | string
    last_name?: StringFilter<"Stallholder"> | string
    email?: StringNullableFilter<"Stallholder"> | string | null
    phone_number?: StringNullableFilter<"Stallholder"> | string | null
    address?: StringNullableFilter<"Stallholder"> | string | null
    business_name?: StringNullableFilter<"Stallholder"> | string | null
    business_type?: StringNullableFilter<"Stallholder"> | string | null
    branch_id?: IntNullableFilter<"Stallholder"> | number | null
    status?: StringFilter<"Stallholder"> | string
    password?: StringNullableFilter<"Stallholder"> | string | null
    created_at?: DateTimeFilter<"Stallholder"> | Date | string
    updated_at?: DateTimeFilter<"Stallholder"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    stalls?: StallListRelationFilter
    payments?: PaymentListRelationFilter
    applications?: ApplicationListRelationFilter
  }

  export type StallholderOrderByWithRelationInput = {
    stallholder_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    business_name?: SortOrderInput | SortOrder
    business_type?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    status?: SortOrder
    password?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    branch?: BranchOrderByWithRelationInput
    stalls?: StallOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    applications?: ApplicationOrderByRelationAggregateInput
    _relevance?: StallholderOrderByRelevanceInput
  }

  export type StallholderWhereUniqueInput = Prisma.AtLeast<{
    stallholder_id?: number
    AND?: StallholderWhereInput | StallholderWhereInput[]
    OR?: StallholderWhereInput[]
    NOT?: StallholderWhereInput | StallholderWhereInput[]
    first_name?: StringFilter<"Stallholder"> | string
    last_name?: StringFilter<"Stallholder"> | string
    email?: StringNullableFilter<"Stallholder"> | string | null
    phone_number?: StringNullableFilter<"Stallholder"> | string | null
    address?: StringNullableFilter<"Stallholder"> | string | null
    business_name?: StringNullableFilter<"Stallholder"> | string | null
    business_type?: StringNullableFilter<"Stallholder"> | string | null
    branch_id?: IntNullableFilter<"Stallholder"> | number | null
    status?: StringFilter<"Stallholder"> | string
    password?: StringNullableFilter<"Stallholder"> | string | null
    created_at?: DateTimeFilter<"Stallholder"> | Date | string
    updated_at?: DateTimeFilter<"Stallholder"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    stalls?: StallListRelationFilter
    payments?: PaymentListRelationFilter
    applications?: ApplicationListRelationFilter
  }, "stallholder_id">

  export type StallholderOrderByWithAggregationInput = {
    stallholder_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone_number?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    business_name?: SortOrderInput | SortOrder
    business_type?: SortOrderInput | SortOrder
    branch_id?: SortOrderInput | SortOrder
    status?: SortOrder
    password?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: StallholderCountOrderByAggregateInput
    _avg?: StallholderAvgOrderByAggregateInput
    _max?: StallholderMaxOrderByAggregateInput
    _min?: StallholderMinOrderByAggregateInput
    _sum?: StallholderSumOrderByAggregateInput
  }

  export type StallholderScalarWhereWithAggregatesInput = {
    AND?: StallholderScalarWhereWithAggregatesInput | StallholderScalarWhereWithAggregatesInput[]
    OR?: StallholderScalarWhereWithAggregatesInput[]
    NOT?: StallholderScalarWhereWithAggregatesInput | StallholderScalarWhereWithAggregatesInput[]
    stallholder_id?: IntWithAggregatesFilter<"Stallholder"> | number
    first_name?: StringWithAggregatesFilter<"Stallholder"> | string
    last_name?: StringWithAggregatesFilter<"Stallholder"> | string
    email?: StringNullableWithAggregatesFilter<"Stallholder"> | string | null
    phone_number?: StringNullableWithAggregatesFilter<"Stallholder"> | string | null
    address?: StringNullableWithAggregatesFilter<"Stallholder"> | string | null
    business_name?: StringNullableWithAggregatesFilter<"Stallholder"> | string | null
    business_type?: StringNullableWithAggregatesFilter<"Stallholder"> | string | null
    branch_id?: IntNullableWithAggregatesFilter<"Stallholder"> | number | null
    status?: StringWithAggregatesFilter<"Stallholder"> | string
    password?: StringNullableWithAggregatesFilter<"Stallholder"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Stallholder"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Stallholder"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    employee_id?: IntFilter<"Employee"> | number
    first_name?: StringFilter<"Employee"> | string
    last_name?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    phone_number?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    role?: StringFilter<"Employee"> | string
    branch_id?: IntNullableFilter<"Employee"> | number | null
    password?: StringFilter<"Employee"> | string
    status?: StringFilter<"Employee"> | string
    created_at?: DateTimeFilter<"Employee"> | Date | string
    updated_at?: DateTimeFilter<"Employee"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    inspections?: ComplianceListRelationFilter
    collections?: PaymentListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    employee_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    role?: SortOrder
    branch_id?: SortOrderInput | SortOrder
    password?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    branch?: BranchOrderByWithRelationInput
    inspections?: ComplianceOrderByRelationAggregateInput
    collections?: PaymentOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
    _relevance?: EmployeeOrderByRelevanceInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    employee_id?: number
    email?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    first_name?: StringFilter<"Employee"> | string
    last_name?: StringFilter<"Employee"> | string
    phone_number?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    role?: StringFilter<"Employee"> | string
    branch_id?: IntNullableFilter<"Employee"> | number | null
    password?: StringFilter<"Employee"> | string
    status?: StringFilter<"Employee"> | string
    created_at?: DateTimeFilter<"Employee"> | Date | string
    updated_at?: DateTimeFilter<"Employee"> | Date | string
    branch?: XOR<BranchNullableScalarRelationFilter, BranchWhereInput> | null
    inspections?: ComplianceListRelationFilter
    collections?: PaymentListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
  }, "employee_id" | "email">

  export type EmployeeOrderByWithAggregationInput = {
    employee_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrderInput | SortOrder
    position?: SortOrderInput | SortOrder
    role?: SortOrder
    branch_id?: SortOrderInput | SortOrder
    password?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    employee_id?: IntWithAggregatesFilter<"Employee"> | number
    first_name?: StringWithAggregatesFilter<"Employee"> | string
    last_name?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringWithAggregatesFilter<"Employee"> | string
    phone_number?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    position?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    role?: StringWithAggregatesFilter<"Employee"> | string
    branch_id?: IntNullableWithAggregatesFilter<"Employee"> | number | null
    password?: StringWithAggregatesFilter<"Employee"> | string
    status?: StringWithAggregatesFilter<"Employee"> | string
    created_at?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type ApplicationWhereInput = {
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    application_id?: IntFilter<"Application"> | number
    applicant_name?: StringNullableFilter<"Application"> | string | null
    applicant_email?: StringNullableFilter<"Application"> | string | null
    applicant_phone?: StringNullableFilter<"Application"> | string | null
    business_name?: StringNullableFilter<"Application"> | string | null
    business_type?: StringNullableFilter<"Application"> | string | null
    stall_id?: IntNullableFilter<"Application"> | number | null
    stallholder_id?: IntNullableFilter<"Application"> | number | null
    status?: StringFilter<"Application"> | string
    notes?: StringNullableFilter<"Application"> | string | null
    created_at?: DateTimeFilter<"Application"> | Date | string
    updated_at?: DateTimeFilter<"Application"> | Date | string
    stallholder?: XOR<StallholderNullableScalarRelationFilter, StallholderWhereInput> | null
  }

  export type ApplicationOrderByWithRelationInput = {
    application_id?: SortOrder
    applicant_name?: SortOrderInput | SortOrder
    applicant_email?: SortOrderInput | SortOrder
    applicant_phone?: SortOrderInput | SortOrder
    business_name?: SortOrderInput | SortOrder
    business_type?: SortOrderInput | SortOrder
    stall_id?: SortOrderInput | SortOrder
    stallholder_id?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stallholder?: StallholderOrderByWithRelationInput
    _relevance?: ApplicationOrderByRelevanceInput
  }

  export type ApplicationWhereUniqueInput = Prisma.AtLeast<{
    application_id?: number
    AND?: ApplicationWhereInput | ApplicationWhereInput[]
    OR?: ApplicationWhereInput[]
    NOT?: ApplicationWhereInput | ApplicationWhereInput[]
    applicant_name?: StringNullableFilter<"Application"> | string | null
    applicant_email?: StringNullableFilter<"Application"> | string | null
    applicant_phone?: StringNullableFilter<"Application"> | string | null
    business_name?: StringNullableFilter<"Application"> | string | null
    business_type?: StringNullableFilter<"Application"> | string | null
    stall_id?: IntNullableFilter<"Application"> | number | null
    stallholder_id?: IntNullableFilter<"Application"> | number | null
    status?: StringFilter<"Application"> | string
    notes?: StringNullableFilter<"Application"> | string | null
    created_at?: DateTimeFilter<"Application"> | Date | string
    updated_at?: DateTimeFilter<"Application"> | Date | string
    stallholder?: XOR<StallholderNullableScalarRelationFilter, StallholderWhereInput> | null
  }, "application_id">

  export type ApplicationOrderByWithAggregationInput = {
    application_id?: SortOrder
    applicant_name?: SortOrderInput | SortOrder
    applicant_email?: SortOrderInput | SortOrder
    applicant_phone?: SortOrderInput | SortOrder
    business_name?: SortOrderInput | SortOrder
    business_type?: SortOrderInput | SortOrder
    stall_id?: SortOrderInput | SortOrder
    stallholder_id?: SortOrderInput | SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ApplicationCountOrderByAggregateInput
    _avg?: ApplicationAvgOrderByAggregateInput
    _max?: ApplicationMaxOrderByAggregateInput
    _min?: ApplicationMinOrderByAggregateInput
    _sum?: ApplicationSumOrderByAggregateInput
  }

  export type ApplicationScalarWhereWithAggregatesInput = {
    AND?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    OR?: ApplicationScalarWhereWithAggregatesInput[]
    NOT?: ApplicationScalarWhereWithAggregatesInput | ApplicationScalarWhereWithAggregatesInput[]
    application_id?: IntWithAggregatesFilter<"Application"> | number
    applicant_name?: StringNullableWithAggregatesFilter<"Application"> | string | null
    applicant_email?: StringNullableWithAggregatesFilter<"Application"> | string | null
    applicant_phone?: StringNullableWithAggregatesFilter<"Application"> | string | null
    business_name?: StringNullableWithAggregatesFilter<"Application"> | string | null
    business_type?: StringNullableWithAggregatesFilter<"Application"> | string | null
    stall_id?: IntNullableWithAggregatesFilter<"Application"> | number | null
    stallholder_id?: IntNullableWithAggregatesFilter<"Application"> | number | null
    status?: StringWithAggregatesFilter<"Application"> | string
    notes?: StringNullableWithAggregatesFilter<"Application"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Application"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Application"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    payment_id?: IntFilter<"Payment"> | number
    stall_id?: IntNullableFilter<"Payment"> | number | null
    stallholder_id?: IntNullableFilter<"Payment"> | number | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeNullableFilter<"Payment"> | Date | string | null
    payment_type?: StringNullableFilter<"Payment"> | string | null
    payment_method?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    reference_no?: StringNullableFilter<"Payment"> | string | null
    collector_id?: IntNullableFilter<"Payment"> | number | null
    notes?: StringNullableFilter<"Payment"> | string | null
    created_at?: DateTimeFilter<"Payment"> | Date | string
    updated_at?: DateTimeFilter<"Payment"> | Date | string
    stall?: XOR<StallNullableScalarRelationFilter, StallWhereInput> | null
    stallholder?: XOR<StallholderNullableScalarRelationFilter, StallholderWhereInput> | null
    collector?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    payment_id?: SortOrder
    stall_id?: SortOrderInput | SortOrder
    stallholder_id?: SortOrderInput | SortOrder
    amount?: SortOrder
    payment_date?: SortOrderInput | SortOrder
    payment_type?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    status?: SortOrder
    reference_no?: SortOrderInput | SortOrder
    collector_id?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stall?: StallOrderByWithRelationInput
    stallholder?: StallholderOrderByWithRelationInput
    collector?: EmployeeOrderByWithRelationInput
    _relevance?: PaymentOrderByRelevanceInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    payment_id?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    stall_id?: IntNullableFilter<"Payment"> | number | null
    stallholder_id?: IntNullableFilter<"Payment"> | number | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeNullableFilter<"Payment"> | Date | string | null
    payment_type?: StringNullableFilter<"Payment"> | string | null
    payment_method?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    reference_no?: StringNullableFilter<"Payment"> | string | null
    collector_id?: IntNullableFilter<"Payment"> | number | null
    notes?: StringNullableFilter<"Payment"> | string | null
    created_at?: DateTimeFilter<"Payment"> | Date | string
    updated_at?: DateTimeFilter<"Payment"> | Date | string
    stall?: XOR<StallNullableScalarRelationFilter, StallWhereInput> | null
    stallholder?: XOR<StallholderNullableScalarRelationFilter, StallholderWhereInput> | null
    collector?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }, "payment_id">

  export type PaymentOrderByWithAggregationInput = {
    payment_id?: SortOrder
    stall_id?: SortOrderInput | SortOrder
    stallholder_id?: SortOrderInput | SortOrder
    amount?: SortOrder
    payment_date?: SortOrderInput | SortOrder
    payment_type?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    status?: SortOrder
    reference_no?: SortOrderInput | SortOrder
    collector_id?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    payment_id?: IntWithAggregatesFilter<"Payment"> | number
    stall_id?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    stallholder_id?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    payment_type?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    payment_method?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    status?: StringWithAggregatesFilter<"Payment"> | string
    reference_no?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    collector_id?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type ComplianceWhereInput = {
    AND?: ComplianceWhereInput | ComplianceWhereInput[]
    OR?: ComplianceWhereInput[]
    NOT?: ComplianceWhereInput | ComplianceWhereInput[]
    compliance_id?: IntFilter<"Compliance"> | number
    stall_id?: IntFilter<"Compliance"> | number
    inspector_id?: IntNullableFilter<"Compliance"> | number | null
    compliance_type?: StringNullableFilter<"Compliance"> | string | null
    status?: StringFilter<"Compliance"> | string
    inspection_date?: DateTimeNullableFilter<"Compliance"> | Date | string | null
    remarks?: StringNullableFilter<"Compliance"> | string | null
    evidence?: BytesNullableFilter<"Compliance"> | Bytes | null
    evidence_type?: StringNullableFilter<"Compliance"> | string | null
    created_at?: DateTimeFilter<"Compliance"> | Date | string
    updated_at?: DateTimeFilter<"Compliance"> | Date | string
    stall?: XOR<StallScalarRelationFilter, StallWhereInput>
    inspector?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }

  export type ComplianceOrderByWithRelationInput = {
    compliance_id?: SortOrder
    stall_id?: SortOrder
    inspector_id?: SortOrderInput | SortOrder
    compliance_type?: SortOrderInput | SortOrder
    status?: SortOrder
    inspection_date?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    evidence_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stall?: StallOrderByWithRelationInput
    inspector?: EmployeeOrderByWithRelationInput
    _relevance?: ComplianceOrderByRelevanceInput
  }

  export type ComplianceWhereUniqueInput = Prisma.AtLeast<{
    compliance_id?: number
    AND?: ComplianceWhereInput | ComplianceWhereInput[]
    OR?: ComplianceWhereInput[]
    NOT?: ComplianceWhereInput | ComplianceWhereInput[]
    stall_id?: IntFilter<"Compliance"> | number
    inspector_id?: IntNullableFilter<"Compliance"> | number | null
    compliance_type?: StringNullableFilter<"Compliance"> | string | null
    status?: StringFilter<"Compliance"> | string
    inspection_date?: DateTimeNullableFilter<"Compliance"> | Date | string | null
    remarks?: StringNullableFilter<"Compliance"> | string | null
    evidence?: BytesNullableFilter<"Compliance"> | Bytes | null
    evidence_type?: StringNullableFilter<"Compliance"> | string | null
    created_at?: DateTimeFilter<"Compliance"> | Date | string
    updated_at?: DateTimeFilter<"Compliance"> | Date | string
    stall?: XOR<StallScalarRelationFilter, StallWhereInput>
    inspector?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }, "compliance_id">

  export type ComplianceOrderByWithAggregationInput = {
    compliance_id?: SortOrder
    stall_id?: SortOrder
    inspector_id?: SortOrderInput | SortOrder
    compliance_type?: SortOrderInput | SortOrder
    status?: SortOrder
    inspection_date?: SortOrderInput | SortOrder
    remarks?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    evidence_type?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ComplianceCountOrderByAggregateInput
    _avg?: ComplianceAvgOrderByAggregateInput
    _max?: ComplianceMaxOrderByAggregateInput
    _min?: ComplianceMinOrderByAggregateInput
    _sum?: ComplianceSumOrderByAggregateInput
  }

  export type ComplianceScalarWhereWithAggregatesInput = {
    AND?: ComplianceScalarWhereWithAggregatesInput | ComplianceScalarWhereWithAggregatesInput[]
    OR?: ComplianceScalarWhereWithAggregatesInput[]
    NOT?: ComplianceScalarWhereWithAggregatesInput | ComplianceScalarWhereWithAggregatesInput[]
    compliance_id?: IntWithAggregatesFilter<"Compliance"> | number
    stall_id?: IntWithAggregatesFilter<"Compliance"> | number
    inspector_id?: IntNullableWithAggregatesFilter<"Compliance"> | number | null
    compliance_type?: StringNullableWithAggregatesFilter<"Compliance"> | string | null
    status?: StringWithAggregatesFilter<"Compliance"> | string
    inspection_date?: DateTimeNullableWithAggregatesFilter<"Compliance"> | Date | string | null
    remarks?: StringNullableWithAggregatesFilter<"Compliance"> | string | null
    evidence?: BytesNullableWithAggregatesFilter<"Compliance"> | Bytes | null
    evidence_type?: StringNullableWithAggregatesFilter<"Compliance"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Compliance"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Compliance"> | Date | string
  }

  export type ComplaintWhereInput = {
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    complaint_id?: IntFilter<"Complaint"> | number
    stall_id?: IntNullableFilter<"Complaint"> | number | null
    complainant?: StringNullableFilter<"Complaint"> | string | null
    complaint_type?: StringNullableFilter<"Complaint"> | string | null
    description?: StringNullableFilter<"Complaint"> | string | null
    status?: StringFilter<"Complaint"> | string
    resolution?: StringNullableFilter<"Complaint"> | string | null
    created_at?: DateTimeFilter<"Complaint"> | Date | string
    updated_at?: DateTimeFilter<"Complaint"> | Date | string
    stall?: XOR<StallNullableScalarRelationFilter, StallWhereInput> | null
  }

  export type ComplaintOrderByWithRelationInput = {
    complaint_id?: SortOrder
    stall_id?: SortOrderInput | SortOrder
    complainant?: SortOrderInput | SortOrder
    complaint_type?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    resolution?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stall?: StallOrderByWithRelationInput
    _relevance?: ComplaintOrderByRelevanceInput
  }

  export type ComplaintWhereUniqueInput = Prisma.AtLeast<{
    complaint_id?: number
    AND?: ComplaintWhereInput | ComplaintWhereInput[]
    OR?: ComplaintWhereInput[]
    NOT?: ComplaintWhereInput | ComplaintWhereInput[]
    stall_id?: IntNullableFilter<"Complaint"> | number | null
    complainant?: StringNullableFilter<"Complaint"> | string | null
    complaint_type?: StringNullableFilter<"Complaint"> | string | null
    description?: StringNullableFilter<"Complaint"> | string | null
    status?: StringFilter<"Complaint"> | string
    resolution?: StringNullableFilter<"Complaint"> | string | null
    created_at?: DateTimeFilter<"Complaint"> | Date | string
    updated_at?: DateTimeFilter<"Complaint"> | Date | string
    stall?: XOR<StallNullableScalarRelationFilter, StallWhereInput> | null
  }, "complaint_id">

  export type ComplaintOrderByWithAggregationInput = {
    complaint_id?: SortOrder
    stall_id?: SortOrderInput | SortOrder
    complainant?: SortOrderInput | SortOrder
    complaint_type?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    resolution?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ComplaintCountOrderByAggregateInput
    _avg?: ComplaintAvgOrderByAggregateInput
    _max?: ComplaintMaxOrderByAggregateInput
    _min?: ComplaintMinOrderByAggregateInput
    _sum?: ComplaintSumOrderByAggregateInput
  }

  export type ComplaintScalarWhereWithAggregatesInput = {
    AND?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    OR?: ComplaintScalarWhereWithAggregatesInput[]
    NOT?: ComplaintScalarWhereWithAggregatesInput | ComplaintScalarWhereWithAggregatesInput[]
    complaint_id?: IntWithAggregatesFilter<"Complaint"> | number
    stall_id?: IntNullableWithAggregatesFilter<"Complaint"> | number | null
    complainant?: StringNullableWithAggregatesFilter<"Complaint"> | string | null
    complaint_type?: StringNullableWithAggregatesFilter<"Complaint"> | string | null
    description?: StringNullableWithAggregatesFilter<"Complaint"> | string | null
    status?: StringWithAggregatesFilter<"Complaint"> | string
    resolution?: StringNullableWithAggregatesFilter<"Complaint"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Complaint"> | Date | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    vendor_id?: IntFilter<"Vendor"> | number
    stall_id?: IntNullableFilter<"Vendor"> | number | null
    vendor_name?: StringFilter<"Vendor"> | string
    contact_number?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    product_type?: StringNullableFilter<"Vendor"> | string | null
    status?: StringFilter<"Vendor"> | string
    created_at?: DateTimeFilter<"Vendor"> | Date | string
    updated_at?: DateTimeFilter<"Vendor"> | Date | string
    stall?: XOR<StallNullableScalarRelationFilter, StallWhereInput> | null
  }

  export type VendorOrderByWithRelationInput = {
    vendor_id?: SortOrder
    stall_id?: SortOrderInput | SortOrder
    vendor_name?: SortOrder
    contact_number?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    product_type?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    stall?: StallOrderByWithRelationInput
    _relevance?: VendorOrderByRelevanceInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    vendor_id?: number
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    stall_id?: IntNullableFilter<"Vendor"> | number | null
    vendor_name?: StringFilter<"Vendor"> | string
    contact_number?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    product_type?: StringNullableFilter<"Vendor"> | string | null
    status?: StringFilter<"Vendor"> | string
    created_at?: DateTimeFilter<"Vendor"> | Date | string
    updated_at?: DateTimeFilter<"Vendor"> | Date | string
    stall?: XOR<StallNullableScalarRelationFilter, StallWhereInput> | null
  }, "vendor_id">

  export type VendorOrderByWithAggregationInput = {
    vendor_id?: SortOrder
    stall_id?: SortOrderInput | SortOrder
    vendor_name?: SortOrder
    contact_number?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    product_type?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _avg?: VendorAvgOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
    _sum?: VendorSumOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    vendor_id?: IntWithAggregatesFilter<"Vendor"> | number
    stall_id?: IntNullableWithAggregatesFilter<"Vendor"> | number | null
    vendor_name?: StringWithAggregatesFilter<"Vendor"> | string
    contact_number?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    product_type?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    status?: StringWithAggregatesFilter<"Vendor"> | string
    created_at?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    log_id?: IntFilter<"ActivityLog"> | number
    employee_id?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringFilter<"ActivityLog"> | string
    description?: StringNullableFilter<"ActivityLog"> | string | null
    entity_type?: StringNullableFilter<"ActivityLog"> | string | null
    entity_id?: IntNullableFilter<"ActivityLog"> | number | null
    ip_address?: StringNullableFilter<"ActivityLog"> | string | null
    created_at?: DateTimeFilter<"ActivityLog"> | Date | string
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }

  export type ActivityLogOrderByWithRelationInput = {
    log_id?: SortOrder
    employee_id?: SortOrderInput | SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    entity_type?: SortOrderInput | SortOrder
    entity_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    _relevance?: ActivityLogOrderByRelevanceInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    log_id?: number
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    employee_id?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringFilter<"ActivityLog"> | string
    description?: StringNullableFilter<"ActivityLog"> | string | null
    entity_type?: StringNullableFilter<"ActivityLog"> | string | null
    entity_id?: IntNullableFilter<"ActivityLog"> | number | null
    ip_address?: StringNullableFilter<"ActivityLog"> | string | null
    created_at?: DateTimeFilter<"ActivityLog"> | Date | string
    employee?: XOR<EmployeeNullableScalarRelationFilter, EmployeeWhereInput> | null
  }, "log_id">

  export type ActivityLogOrderByWithAggregationInput = {
    log_id?: SortOrder
    employee_id?: SortOrderInput | SortOrder
    action?: SortOrder
    description?: SortOrderInput | SortOrder
    entity_type?: SortOrderInput | SortOrder
    entity_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _avg?: ActivityLogAvgOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
    _sum?: ActivityLogSumOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    log_id?: IntWithAggregatesFilter<"ActivityLog"> | number
    employee_id?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    action?: StringWithAggregatesFilter<"ActivityLog"> | string
    description?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    entity_type?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    entity_id?: IntNullableWithAggregatesFilter<"ActivityLog"> | number | null
    ip_address?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    subscription_id?: IntFilter<"Subscription"> | number
    name?: StringFilter<"Subscription"> | string
    email?: StringFilter<"Subscription"> | string
    subscription_type?: StringNullableFilter<"Subscription"> | string | null
    status?: StringFilter<"Subscription"> | string
    created_at?: DateTimeFilter<"Subscription"> | Date | string
    updated_at?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type SubscriptionOrderByWithRelationInput = {
    subscription_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subscription_type?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _relevance?: SubscriptionOrderByRelevanceInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    subscription_id?: number
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    name?: StringFilter<"Subscription"> | string
    email?: StringFilter<"Subscription"> | string
    subscription_type?: StringNullableFilter<"Subscription"> | string | null
    status?: StringFilter<"Subscription"> | string
    created_at?: DateTimeFilter<"Subscription"> | Date | string
    updated_at?: DateTimeFilter<"Subscription"> | Date | string
  }, "subscription_id">

  export type SubscriptionOrderByWithAggregationInput = {
    subscription_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subscription_type?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    subscription_id?: IntWithAggregatesFilter<"Subscription"> | number
    name?: StringWithAggregatesFilter<"Subscription"> | string
    email?: StringWithAggregatesFilter<"Subscription"> | string
    subscription_type?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    status?: StringWithAggregatesFilter<"Subscription"> | string
    created_at?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type BranchCreateInput = {
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallCreateNestedManyWithoutBranchInput
    employees?: EmployeeCreateNestedManyWithoutBranchInput
    floors?: FloorCreateNestedManyWithoutBranchInput
    sections?: SectionCreateNestedManyWithoutBranchInput
    stallholders?: StallholderCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateInput = {
    branch_id?: number
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutBranchInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutBranchInput
    floors?: FloorUncheckedCreateNestedManyWithoutBranchInput
    sections?: SectionUncheckedCreateNestedManyWithoutBranchInput
    stallholders?: StallholderUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchUpdateInput = {
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUpdateManyWithoutBranchNestedInput
    employees?: EmployeeUpdateManyWithoutBranchNestedInput
    floors?: FloorUpdateManyWithoutBranchNestedInput
    sections?: SectionUpdateManyWithoutBranchNestedInput
    stallholders?: StallholderUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateInput = {
    branch_id?: IntFieldUpdateOperationsInput | number
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutBranchNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutBranchNestedInput
    floors?: FloorUncheckedUpdateManyWithoutBranchNestedInput
    sections?: SectionUncheckedUpdateManyWithoutBranchNestedInput
    stallholders?: StallholderUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type BranchCreateManyInput = {
    branch_id?: number
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BranchUpdateManyMutationInput = {
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BranchUncheckedUpdateManyInput = {
    branch_id?: IntFieldUpdateOperationsInput | number
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FloorCreateInput = {
    floor_name: string
    floor_number: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutFloorsInput
    stalls?: StallCreateNestedManyWithoutFloorInput
    sections?: SectionCreateNestedManyWithoutFloorInput
  }

  export type FloorUncheckedCreateInput = {
    floor_id?: number
    branch_id: number
    floor_name: string
    floor_number: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutFloorInput
    sections?: SectionUncheckedCreateNestedManyWithoutFloorInput
  }

  export type FloorUpdateInput = {
    floor_name?: StringFieldUpdateOperationsInput | string
    floor_number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutFloorsNestedInput
    stalls?: StallUpdateManyWithoutFloorNestedInput
    sections?: SectionUpdateManyWithoutFloorNestedInput
  }

  export type FloorUncheckedUpdateInput = {
    floor_id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    floor_name?: StringFieldUpdateOperationsInput | string
    floor_number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutFloorNestedInput
    sections?: SectionUncheckedUpdateManyWithoutFloorNestedInput
  }

  export type FloorCreateManyInput = {
    floor_id?: number
    branch_id: number
    floor_name: string
    floor_number: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FloorUpdateManyMutationInput = {
    floor_name?: StringFieldUpdateOperationsInput | string
    floor_number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FloorUncheckedUpdateManyInput = {
    floor_id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    floor_name?: StringFieldUpdateOperationsInput | string
    floor_number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionCreateInput = {
    section_name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutSectionsInput
    floor?: FloorCreateNestedOneWithoutSectionsInput
    stalls?: StallCreateNestedManyWithoutSectionRefInput
  }

  export type SectionUncheckedCreateInput = {
    section_id?: number
    branch_id: number
    floor_id?: number | null
    section_name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutSectionRefInput
  }

  export type SectionUpdateInput = {
    section_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSectionsNestedInput
    floor?: FloorUpdateOneWithoutSectionsNestedInput
    stalls?: StallUpdateManyWithoutSectionRefNestedInput
  }

  export type SectionUncheckedUpdateInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutSectionRefNestedInput
  }

  export type SectionCreateManyInput = {
    section_id?: number
    branch_id: number
    floor_id?: number | null
    section_name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SectionUpdateManyMutationInput = {
    section_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUncheckedUpdateManyInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallCreateInput = {
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutStallsInput
    floor?: FloorCreateNestedOneWithoutStallsInput
    sectionRef?: SectionCreateNestedOneWithoutStallsInput
    stallholder?: StallholderCreateNestedOneWithoutStallsInput
    images?: StallImageCreateNestedManyWithoutStallInput
    payments?: PaymentCreateNestedManyWithoutStallInput
    compliances?: ComplianceCreateNestedManyWithoutStallInput
    complaints?: ComplaintCreateNestedManyWithoutStallInput
    vendors?: VendorCreateNestedManyWithoutStallInput
  }

  export type StallUncheckedCreateInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    images?: StallImageUncheckedCreateNestedManyWithoutStallInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStallInput
    compliances?: ComplianceUncheckedCreateNestedManyWithoutStallInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutStallInput
    vendors?: VendorUncheckedCreateNestedManyWithoutStallInput
  }

  export type StallUpdateInput = {
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStallsNestedInput
    floor?: FloorUpdateOneWithoutStallsNestedInput
    sectionRef?: SectionUpdateOneWithoutStallsNestedInput
    stallholder?: StallholderUpdateOneWithoutStallsNestedInput
    images?: StallImageUpdateManyWithoutStallNestedInput
    payments?: PaymentUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUpdateManyWithoutStallNestedInput
    vendors?: VendorUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StallImageUncheckedUpdateManyWithoutStallNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUncheckedUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutStallNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutStallNestedInput
  }

  export type StallCreateManyInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StallUpdateManyMutationInput = {
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallUncheckedUpdateManyInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallImageCreateInput = {
    filename?: string | null
    image_data?: Bytes | null
    mime_type?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    stall: StallCreateNestedOneWithoutImagesInput
  }

  export type StallImageUncheckedCreateInput = {
    image_id?: number
    stall_id: number
    filename?: string | null
    image_data?: Bytes | null
    mime_type?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StallImageUpdateInput = {
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    image_data?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stall?: StallUpdateOneRequiredWithoutImagesNestedInput
  }

  export type StallImageUncheckedUpdateInput = {
    image_id?: IntFieldUpdateOperationsInput | number
    stall_id?: IntFieldUpdateOperationsInput | number
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    image_data?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallImageCreateManyInput = {
    image_id?: number
    stall_id: number
    filename?: string | null
    image_data?: Bytes | null
    mime_type?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StallImageUpdateManyMutationInput = {
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    image_data?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallImageUncheckedUpdateManyInput = {
    image_id?: IntFieldUpdateOperationsInput | number
    stall_id?: IntFieldUpdateOperationsInput | number
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    image_data?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallholderCreateInput = {
    first_name: string
    last_name: string
    email?: string | null
    phone_number?: string | null
    address?: string | null
    business_name?: string | null
    business_type?: string | null
    status?: string
    password?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch?: BranchCreateNestedOneWithoutStallholdersInput
    stalls?: StallCreateNestedManyWithoutStallholderInput
    payments?: PaymentCreateNestedManyWithoutStallholderInput
    applications?: ApplicationCreateNestedManyWithoutStallholderInput
  }

  export type StallholderUncheckedCreateInput = {
    stallholder_id?: number
    first_name: string
    last_name: string
    email?: string | null
    phone_number?: string | null
    address?: string | null
    business_name?: string | null
    business_type?: string | null
    branch_id?: number | null
    status?: string
    password?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutStallholderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStallholderInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutStallholderInput
  }

  export type StallholderUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutStallholdersNestedInput
    stalls?: StallUpdateManyWithoutStallholderNestedInput
    payments?: PaymentUpdateManyWithoutStallholderNestedInput
    applications?: ApplicationUpdateManyWithoutStallholderNestedInput
  }

  export type StallholderUncheckedUpdateInput = {
    stallholder_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutStallholderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStallholderNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutStallholderNestedInput
  }

  export type StallholderCreateManyInput = {
    stallholder_id?: number
    first_name: string
    last_name: string
    email?: string | null
    phone_number?: string | null
    address?: string | null
    business_name?: string | null
    business_type?: string | null
    branch_id?: number | null
    status?: string
    password?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StallholderUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallholderUncheckedUpdateManyInput = {
    stallholder_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    first_name: string
    last_name: string
    email: string
    phone_number?: string | null
    position?: string | null
    role?: string
    password: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    inspections?: ComplianceCreateNestedManyWithoutInspectorInput
    collections?: PaymentCreateNestedManyWithoutCollectorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    employee_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number?: string | null
    position?: string | null
    role?: string
    branch_id?: number | null
    password: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    inspections?: ComplianceUncheckedCreateNestedManyWithoutInspectorInput
    collections?: PaymentUncheckedCreateNestedManyWithoutCollectorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    inspections?: ComplianceUpdateManyWithoutInspectorNestedInput
    collections?: PaymentUpdateManyWithoutCollectorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inspections?: ComplianceUncheckedUpdateManyWithoutInspectorNestedInput
    collections?: PaymentUncheckedUpdateManyWithoutCollectorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    employee_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number?: string | null
    position?: string | null
    role?: string
    branch_id?: number | null
    password: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateInput = {
    applicant_name?: string | null
    applicant_email?: string | null
    applicant_phone?: string | null
    business_name?: string | null
    business_type?: string | null
    stall_id?: number | null
    status?: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stallholder?: StallholderCreateNestedOneWithoutApplicationsInput
  }

  export type ApplicationUncheckedCreateInput = {
    application_id?: number
    applicant_name?: string | null
    applicant_email?: string | null
    applicant_phone?: string | null
    business_name?: string | null
    business_type?: string | null
    stall_id?: number | null
    stallholder_id?: number | null
    status?: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ApplicationUpdateInput = {
    applicant_name?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_email?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stallholder?: StallholderUpdateOneWithoutApplicationsNestedInput
  }

  export type ApplicationUncheckedUpdateInput = {
    application_id?: IntFieldUpdateOperationsInput | number
    applicant_name?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_email?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationCreateManyInput = {
    application_id?: number
    applicant_name?: string | null
    applicant_email?: string | null
    applicant_phone?: string | null
    business_name?: string | null
    business_type?: string | null
    stall_id?: number | null
    stallholder_id?: number | null
    status?: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ApplicationUpdateManyMutationInput = {
    applicant_name?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_email?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateManyInput = {
    application_id?: IntFieldUpdateOperationsInput | number
    applicant_name?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_email?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_type?: string | null
    payment_method?: string | null
    status?: string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stall?: StallCreateNestedOneWithoutPaymentsInput
    stallholder?: StallholderCreateNestedOneWithoutPaymentsInput
    collector?: EmployeeCreateNestedOneWithoutCollectionsInput
  }

  export type PaymentUncheckedCreateInput = {
    payment_id?: number
    stall_id?: number | null
    stallholder_id?: number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_type?: string | null
    payment_method?: string | null
    status?: string
    reference_no?: string | null
    collector_id?: number | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentUpdateInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stall?: StallUpdateOneWithoutPaymentsNestedInput
    stallholder?: StallholderUpdateOneWithoutPaymentsNestedInput
    collector?: EmployeeUpdateOneWithoutCollectionsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    collector_id?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    payment_id?: number
    stall_id?: number | null
    stallholder_id?: number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_type?: string | null
    payment_method?: string | null
    status?: string
    reference_no?: string | null
    collector_id?: number | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    collector_id?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceCreateInput = {
    compliance_type?: string | null
    status?: string
    inspection_date?: Date | string | null
    remarks?: string | null
    evidence?: Bytes | null
    evidence_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stall: StallCreateNestedOneWithoutCompliancesInput
    inspector?: EmployeeCreateNestedOneWithoutInspectionsInput
  }

  export type ComplianceUncheckedCreateInput = {
    compliance_id?: number
    stall_id: number
    inspector_id?: number | null
    compliance_type?: string | null
    status?: string
    inspection_date?: Date | string | null
    remarks?: string | null
    evidence?: Bytes | null
    evidence_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplianceUpdateInput = {
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inspection_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    evidence_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stall?: StallUpdateOneRequiredWithoutCompliancesNestedInput
    inspector?: EmployeeUpdateOneWithoutInspectionsNestedInput
  }

  export type ComplianceUncheckedUpdateInput = {
    compliance_id?: IntFieldUpdateOperationsInput | number
    stall_id?: IntFieldUpdateOperationsInput | number
    inspector_id?: NullableIntFieldUpdateOperationsInput | number | null
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inspection_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    evidence_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceCreateManyInput = {
    compliance_id?: number
    stall_id: number
    inspector_id?: number | null
    compliance_type?: string | null
    status?: string
    inspection_date?: Date | string | null
    remarks?: string | null
    evidence?: Bytes | null
    evidence_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplianceUpdateManyMutationInput = {
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inspection_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    evidence_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceUncheckedUpdateManyInput = {
    compliance_id?: IntFieldUpdateOperationsInput | number
    stall_id?: IntFieldUpdateOperationsInput | number
    inspector_id?: NullableIntFieldUpdateOperationsInput | number | null
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inspection_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    evidence_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCreateInput = {
    complainant?: string | null
    complaint_type?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stall?: StallCreateNestedOneWithoutComplaintsInput
  }

  export type ComplaintUncheckedCreateInput = {
    complaint_id?: number
    stall_id?: number | null
    complainant?: string | null
    complaint_type?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintUpdateInput = {
    complainant?: NullableStringFieldUpdateOperationsInput | string | null
    complaint_type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stall?: StallUpdateOneWithoutComplaintsNestedInput
  }

  export type ComplaintUncheckedUpdateInput = {
    complaint_id?: IntFieldUpdateOperationsInput | number
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    complainant?: NullableStringFieldUpdateOperationsInput | string | null
    complaint_type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintCreateManyInput = {
    complaint_id?: number
    stall_id?: number | null
    complainant?: string | null
    complaint_type?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintUpdateManyMutationInput = {
    complainant?: NullableStringFieldUpdateOperationsInput | string | null
    complaint_type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateManyInput = {
    complaint_id?: IntFieldUpdateOperationsInput | number
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    complainant?: NullableStringFieldUpdateOperationsInput | string | null
    complaint_type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    vendor_name: string
    contact_number?: string | null
    email?: string | null
    product_type?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    stall?: StallCreateNestedOneWithoutVendorsInput
  }

  export type VendorUncheckedCreateInput = {
    vendor_id?: number
    stall_id?: number | null
    vendor_name: string
    contact_number?: string | null
    email?: string | null
    product_type?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorUpdateInput = {
    vendor_name?: StringFieldUpdateOperationsInput | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    product_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stall?: StallUpdateOneWithoutVendorsNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    vendor_name?: StringFieldUpdateOperationsInput | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    product_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateManyInput = {
    vendor_id?: number
    stall_id?: number | null
    vendor_name: string
    contact_number?: string | null
    email?: string | null
    product_type?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    vendor_name?: StringFieldUpdateOperationsInput | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    product_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    vendor_name?: StringFieldUpdateOperationsInput | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    product_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateInput = {
    action: string
    description?: string | null
    entity_type?: string | null
    entity_id?: number | null
    ip_address?: string | null
    created_at?: Date | string
    employee?: EmployeeCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    log_id?: number
    employee_id?: number | null
    action: string
    description?: string | null
    entity_type?: string | null
    entity_id?: number | null
    ip_address?: string | null
    created_at?: Date | string
  }

  export type ActivityLogUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogCreateManyInput = {
    log_id?: number
    employee_id?: number | null
    action: string
    description?: string | null
    entity_type?: string | null
    entity_id?: number | null
    ip_address?: string | null
    created_at?: Date | string
  }

  export type ActivityLogUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    employee_id?: NullableIntFieldUpdateOperationsInput | number | null
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    name: string
    email: string
    subscription_type?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUncheckedCreateInput = {
    subscription_id?: number
    name: string
    email: string
    subscription_type?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subscription_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateInput = {
    subscription_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subscription_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateManyInput = {
    subscription_id?: number
    name: string
    email: string
    subscription_type?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subscription_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    subscription_id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subscription_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StallListRelationFilter = {
    every?: StallWhereInput
    some?: StallWhereInput
    none?: StallWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type FloorListRelationFilter = {
    every?: FloorWhereInput
    some?: FloorWhereInput
    none?: FloorWhereInput
  }

  export type SectionListRelationFilter = {
    every?: SectionWhereInput
    some?: SectionWhereInput
    none?: SectionWhereInput
  }

  export type StallholderListRelationFilter = {
    every?: StallholderWhereInput
    some?: StallholderWhereInput
    none?: StallholderWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type StallOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FloorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StallholderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BranchOrderByRelevanceInput = {
    fields: BranchOrderByRelevanceFieldEnum | BranchOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type BranchCountOrderByAggregateInput = {
    branch_id?: SortOrder
    branch_name?: SortOrder
    location?: SortOrder
    address?: SortOrder
    contact_number?: SortOrder
    email?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BranchAvgOrderByAggregateInput = {
    branch_id?: SortOrder
  }

  export type BranchMaxOrderByAggregateInput = {
    branch_id?: SortOrder
    branch_name?: SortOrder
    location?: SortOrder
    address?: SortOrder
    contact_number?: SortOrder
    email?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BranchMinOrderByAggregateInput = {
    branch_id?: SortOrder
    branch_name?: SortOrder
    location?: SortOrder
    address?: SortOrder
    contact_number?: SortOrder
    email?: SortOrder
    description?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BranchSumOrderByAggregateInput = {
    branch_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BranchScalarRelationFilter = {
    is?: BranchWhereInput
    isNot?: BranchWhereInput
  }

  export type FloorOrderByRelevanceInput = {
    fields: FloorOrderByRelevanceFieldEnum | FloorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type FloorCountOrderByAggregateInput = {
    floor_id?: SortOrder
    branch_id?: SortOrder
    floor_name?: SortOrder
    floor_number?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FloorAvgOrderByAggregateInput = {
    floor_id?: SortOrder
    branch_id?: SortOrder
    floor_number?: SortOrder
  }

  export type FloorMaxOrderByAggregateInput = {
    floor_id?: SortOrder
    branch_id?: SortOrder
    floor_name?: SortOrder
    floor_number?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FloorMinOrderByAggregateInput = {
    floor_id?: SortOrder
    branch_id?: SortOrder
    floor_name?: SortOrder
    floor_number?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type FloorSumOrderByAggregateInput = {
    floor_id?: SortOrder
    branch_id?: SortOrder
    floor_number?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloorNullableScalarRelationFilter = {
    is?: FloorWhereInput | null
    isNot?: FloorWhereInput | null
  }

  export type SectionOrderByRelevanceInput = {
    fields: SectionOrderByRelevanceFieldEnum | SectionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SectionCountOrderByAggregateInput = {
    section_id?: SortOrder
    branch_id?: SortOrder
    floor_id?: SortOrder
    section_name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SectionAvgOrderByAggregateInput = {
    section_id?: SortOrder
    branch_id?: SortOrder
    floor_id?: SortOrder
  }

  export type SectionMaxOrderByAggregateInput = {
    section_id?: SortOrder
    branch_id?: SortOrder
    floor_id?: SortOrder
    section_name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SectionMinOrderByAggregateInput = {
    section_id?: SortOrder
    branch_id?: SortOrder
    floor_id?: SortOrder
    section_name?: SortOrder
    description?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SectionSumOrderByAggregateInput = {
    section_id?: SortOrder
    branch_id?: SortOrder
    floor_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type SectionNullableScalarRelationFilter = {
    is?: SectionWhereInput | null
    isNot?: SectionWhereInput | null
  }

  export type StallholderNullableScalarRelationFilter = {
    is?: StallholderWhereInput | null
    isNot?: StallholderWhereInput | null
  }

  export type StallImageListRelationFilter = {
    every?: StallImageWhereInput
    some?: StallImageWhereInput
    none?: StallImageWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ComplianceListRelationFilter = {
    every?: ComplianceWhereInput
    some?: ComplianceWhereInput
    none?: ComplianceWhereInput
  }

  export type ComplaintListRelationFilter = {
    every?: ComplaintWhereInput
    some?: ComplaintWhereInput
    none?: ComplaintWhereInput
  }

  export type VendorListRelationFilter = {
    every?: VendorWhereInput
    some?: VendorWhereInput
    none?: VendorWhereInput
  }

  export type StallImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplianceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplaintOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StallOrderByRelevanceInput = {
    fields: StallOrderByRelevanceFieldEnum | StallOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StallCountOrderByAggregateInput = {
    stall_id?: SortOrder
    stall_number?: SortOrder
    stall_name?: SortOrder
    stall_type?: SortOrder
    stall_size?: SortOrder
    stall_location?: SortOrder
    size?: SortOrder
    area_sqm?: SortOrder
    floor_id?: SortOrder
    section_id?: SortOrder
    monthly_rent?: SortOrder
    rental_price?: SortOrder
    status?: SortOrder
    branch_id?: SortOrder
    stallholder_id?: SortOrder
    floor_level?: SortOrder
    section?: SortOrder
    description?: SortOrder
    price_type?: SortOrder
    is_available?: SortOrder
    base_rate?: SortOrder
    rate_per_sqm?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StallAvgOrderByAggregateInput = {
    stall_id?: SortOrder
    area_sqm?: SortOrder
    floor_id?: SortOrder
    section_id?: SortOrder
    monthly_rent?: SortOrder
    rental_price?: SortOrder
    branch_id?: SortOrder
    stallholder_id?: SortOrder
    base_rate?: SortOrder
    rate_per_sqm?: SortOrder
  }

  export type StallMaxOrderByAggregateInput = {
    stall_id?: SortOrder
    stall_number?: SortOrder
    stall_name?: SortOrder
    stall_type?: SortOrder
    stall_size?: SortOrder
    stall_location?: SortOrder
    size?: SortOrder
    area_sqm?: SortOrder
    floor_id?: SortOrder
    section_id?: SortOrder
    monthly_rent?: SortOrder
    rental_price?: SortOrder
    status?: SortOrder
    branch_id?: SortOrder
    stallholder_id?: SortOrder
    floor_level?: SortOrder
    section?: SortOrder
    description?: SortOrder
    price_type?: SortOrder
    is_available?: SortOrder
    base_rate?: SortOrder
    rate_per_sqm?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StallMinOrderByAggregateInput = {
    stall_id?: SortOrder
    stall_number?: SortOrder
    stall_name?: SortOrder
    stall_type?: SortOrder
    stall_size?: SortOrder
    stall_location?: SortOrder
    size?: SortOrder
    area_sqm?: SortOrder
    floor_id?: SortOrder
    section_id?: SortOrder
    monthly_rent?: SortOrder
    rental_price?: SortOrder
    status?: SortOrder
    branch_id?: SortOrder
    stallholder_id?: SortOrder
    floor_level?: SortOrder
    section?: SortOrder
    description?: SortOrder
    price_type?: SortOrder
    is_available?: SortOrder
    base_rate?: SortOrder
    rate_per_sqm?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StallSumOrderByAggregateInput = {
    stall_id?: SortOrder
    area_sqm?: SortOrder
    floor_id?: SortOrder
    section_id?: SortOrder
    monthly_rent?: SortOrder
    rental_price?: SortOrder
    branch_id?: SortOrder
    stallholder_id?: SortOrder
    base_rate?: SortOrder
    rate_per_sqm?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | null
    notIn?: Bytes[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type StallScalarRelationFilter = {
    is?: StallWhereInput
    isNot?: StallWhereInput
  }

  export type StallImageOrderByRelevanceInput = {
    fields: StallImageOrderByRelevanceFieldEnum | StallImageOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StallImageCountOrderByAggregateInput = {
    image_id?: SortOrder
    stall_id?: SortOrder
    filename?: SortOrder
    image_data?: SortOrder
    mime_type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StallImageAvgOrderByAggregateInput = {
    image_id?: SortOrder
    stall_id?: SortOrder
  }

  export type StallImageMaxOrderByAggregateInput = {
    image_id?: SortOrder
    stall_id?: SortOrder
    filename?: SortOrder
    image_data?: SortOrder
    mime_type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StallImageMinOrderByAggregateInput = {
    image_id?: SortOrder
    stall_id?: SortOrder
    filename?: SortOrder
    image_data?: SortOrder
    mime_type?: SortOrder
    is_primary?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StallImageSumOrderByAggregateInput = {
    image_id?: SortOrder
    stall_id?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | null
    notIn?: Bytes[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type BranchNullableScalarRelationFilter = {
    is?: BranchWhereInput | null
    isNot?: BranchWhereInput | null
  }

  export type ApplicationListRelationFilter = {
    every?: ApplicationWhereInput
    some?: ApplicationWhereInput
    none?: ApplicationWhereInput
  }

  export type ApplicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StallholderOrderByRelevanceInput = {
    fields: StallholderOrderByRelevanceFieldEnum | StallholderOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type StallholderCountOrderByAggregateInput = {
    stallholder_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    address?: SortOrder
    business_name?: SortOrder
    business_type?: SortOrder
    branch_id?: SortOrder
    status?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StallholderAvgOrderByAggregateInput = {
    stallholder_id?: SortOrder
    branch_id?: SortOrder
  }

  export type StallholderMaxOrderByAggregateInput = {
    stallholder_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    address?: SortOrder
    business_name?: SortOrder
    business_type?: SortOrder
    branch_id?: SortOrder
    status?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StallholderMinOrderByAggregateInput = {
    stallholder_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    address?: SortOrder
    business_name?: SortOrder
    business_type?: SortOrder
    branch_id?: SortOrder
    status?: SortOrder
    password?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StallholderSumOrderByAggregateInput = {
    stallholder_id?: SortOrder
    branch_id?: SortOrder
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelevanceInput = {
    fields: EmployeeOrderByRelevanceFieldEnum | EmployeeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EmployeeCountOrderByAggregateInput = {
    employee_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    position?: SortOrder
    role?: SortOrder
    branch_id?: SortOrder
    password?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    employee_id?: SortOrder
    branch_id?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    employee_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    position?: SortOrder
    role?: SortOrder
    branch_id?: SortOrder
    password?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    employee_id?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    email?: SortOrder
    phone_number?: SortOrder
    position?: SortOrder
    role?: SortOrder
    branch_id?: SortOrder
    password?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    employee_id?: SortOrder
    branch_id?: SortOrder
  }

  export type ApplicationOrderByRelevanceInput = {
    fields: ApplicationOrderByRelevanceFieldEnum | ApplicationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ApplicationCountOrderByAggregateInput = {
    application_id?: SortOrder
    applicant_name?: SortOrder
    applicant_email?: SortOrder
    applicant_phone?: SortOrder
    business_name?: SortOrder
    business_type?: SortOrder
    stall_id?: SortOrder
    stallholder_id?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ApplicationAvgOrderByAggregateInput = {
    application_id?: SortOrder
    stall_id?: SortOrder
    stallholder_id?: SortOrder
  }

  export type ApplicationMaxOrderByAggregateInput = {
    application_id?: SortOrder
    applicant_name?: SortOrder
    applicant_email?: SortOrder
    applicant_phone?: SortOrder
    business_name?: SortOrder
    business_type?: SortOrder
    stall_id?: SortOrder
    stallholder_id?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ApplicationMinOrderByAggregateInput = {
    application_id?: SortOrder
    applicant_name?: SortOrder
    applicant_email?: SortOrder
    applicant_phone?: SortOrder
    business_name?: SortOrder
    business_type?: SortOrder
    stall_id?: SortOrder
    stallholder_id?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ApplicationSumOrderByAggregateInput = {
    application_id?: SortOrder
    stall_id?: SortOrder
    stallholder_id?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StallNullableScalarRelationFilter = {
    is?: StallWhereInput | null
    isNot?: StallWhereInput | null
  }

  export type EmployeeNullableScalarRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type PaymentOrderByRelevanceInput = {
    fields: PaymentOrderByRelevanceFieldEnum | PaymentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type PaymentCountOrderByAggregateInput = {
    payment_id?: SortOrder
    stall_id?: SortOrder
    stallholder_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_type?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    reference_no?: SortOrder
    collector_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    payment_id?: SortOrder
    stall_id?: SortOrder
    stallholder_id?: SortOrder
    amount?: SortOrder
    collector_id?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    payment_id?: SortOrder
    stall_id?: SortOrder
    stallholder_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_type?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    reference_no?: SortOrder
    collector_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    payment_id?: SortOrder
    stall_id?: SortOrder
    stallholder_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_type?: SortOrder
    payment_method?: SortOrder
    status?: SortOrder
    reference_no?: SortOrder
    collector_id?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    payment_id?: SortOrder
    stall_id?: SortOrder
    stallholder_id?: SortOrder
    amount?: SortOrder
    collector_id?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ComplianceOrderByRelevanceInput = {
    fields: ComplianceOrderByRelevanceFieldEnum | ComplianceOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComplianceCountOrderByAggregateInput = {
    compliance_id?: SortOrder
    stall_id?: SortOrder
    inspector_id?: SortOrder
    compliance_type?: SortOrder
    status?: SortOrder
    inspection_date?: SortOrder
    remarks?: SortOrder
    evidence?: SortOrder
    evidence_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ComplianceAvgOrderByAggregateInput = {
    compliance_id?: SortOrder
    stall_id?: SortOrder
    inspector_id?: SortOrder
  }

  export type ComplianceMaxOrderByAggregateInput = {
    compliance_id?: SortOrder
    stall_id?: SortOrder
    inspector_id?: SortOrder
    compliance_type?: SortOrder
    status?: SortOrder
    inspection_date?: SortOrder
    remarks?: SortOrder
    evidence?: SortOrder
    evidence_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ComplianceMinOrderByAggregateInput = {
    compliance_id?: SortOrder
    stall_id?: SortOrder
    inspector_id?: SortOrder
    compliance_type?: SortOrder
    status?: SortOrder
    inspection_date?: SortOrder
    remarks?: SortOrder
    evidence?: SortOrder
    evidence_type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ComplianceSumOrderByAggregateInput = {
    compliance_id?: SortOrder
    stall_id?: SortOrder
    inspector_id?: SortOrder
  }

  export type ComplaintOrderByRelevanceInput = {
    fields: ComplaintOrderByRelevanceFieldEnum | ComplaintOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ComplaintCountOrderByAggregateInput = {
    complaint_id?: SortOrder
    stall_id?: SortOrder
    complainant?: SortOrder
    complaint_type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ComplaintAvgOrderByAggregateInput = {
    complaint_id?: SortOrder
    stall_id?: SortOrder
  }

  export type ComplaintMaxOrderByAggregateInput = {
    complaint_id?: SortOrder
    stall_id?: SortOrder
    complainant?: SortOrder
    complaint_type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ComplaintMinOrderByAggregateInput = {
    complaint_id?: SortOrder
    stall_id?: SortOrder
    complainant?: SortOrder
    complaint_type?: SortOrder
    description?: SortOrder
    status?: SortOrder
    resolution?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ComplaintSumOrderByAggregateInput = {
    complaint_id?: SortOrder
    stall_id?: SortOrder
  }

  export type VendorOrderByRelevanceInput = {
    fields: VendorOrderByRelevanceFieldEnum | VendorOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type VendorCountOrderByAggregateInput = {
    vendor_id?: SortOrder
    stall_id?: SortOrder
    vendor_name?: SortOrder
    contact_number?: SortOrder
    email?: SortOrder
    product_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorAvgOrderByAggregateInput = {
    vendor_id?: SortOrder
    stall_id?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    vendor_id?: SortOrder
    stall_id?: SortOrder
    vendor_name?: SortOrder
    contact_number?: SortOrder
    email?: SortOrder
    product_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    vendor_id?: SortOrder
    stall_id?: SortOrder
    vendor_name?: SortOrder
    contact_number?: SortOrder
    email?: SortOrder
    product_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorSumOrderByAggregateInput = {
    vendor_id?: SortOrder
    stall_id?: SortOrder
  }

  export type ActivityLogOrderByRelevanceInput = {
    fields: ActivityLogOrderByRelevanceFieldEnum | ActivityLogOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ActivityLogCountOrderByAggregateInput = {
    log_id?: SortOrder
    employee_id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
  }

  export type ActivityLogAvgOrderByAggregateInput = {
    log_id?: SortOrder
    employee_id?: SortOrder
    entity_id?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    log_id?: SortOrder
    employee_id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    log_id?: SortOrder
    employee_id?: SortOrder
    action?: SortOrder
    description?: SortOrder
    entity_type?: SortOrder
    entity_id?: SortOrder
    ip_address?: SortOrder
    created_at?: SortOrder
  }

  export type ActivityLogSumOrderByAggregateInput = {
    log_id?: SortOrder
    employee_id?: SortOrder
    entity_id?: SortOrder
  }

  export type SubscriptionOrderByRelevanceInput = {
    fields: SubscriptionOrderByRelevanceFieldEnum | SubscriptionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SubscriptionCountOrderByAggregateInput = {
    subscription_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subscription_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    subscription_id?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    subscription_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subscription_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    subscription_id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subscription_type?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    subscription_id?: SortOrder
  }

  export type StallCreateNestedManyWithoutBranchInput = {
    create?: XOR<StallCreateWithoutBranchInput, StallUncheckedCreateWithoutBranchInput> | StallCreateWithoutBranchInput[] | StallUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StallCreateOrConnectWithoutBranchInput | StallCreateOrConnectWithoutBranchInput[]
    createMany?: StallCreateManyBranchInputEnvelope
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutBranchInput = {
    create?: XOR<EmployeeCreateWithoutBranchInput, EmployeeUncheckedCreateWithoutBranchInput> | EmployeeCreateWithoutBranchInput[] | EmployeeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutBranchInput | EmployeeCreateOrConnectWithoutBranchInput[]
    createMany?: EmployeeCreateManyBranchInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type FloorCreateNestedManyWithoutBranchInput = {
    create?: XOR<FloorCreateWithoutBranchInput, FloorUncheckedCreateWithoutBranchInput> | FloorCreateWithoutBranchInput[] | FloorUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FloorCreateOrConnectWithoutBranchInput | FloorCreateOrConnectWithoutBranchInput[]
    createMany?: FloorCreateManyBranchInputEnvelope
    connect?: FloorWhereUniqueInput | FloorWhereUniqueInput[]
  }

  export type SectionCreateNestedManyWithoutBranchInput = {
    create?: XOR<SectionCreateWithoutBranchInput, SectionUncheckedCreateWithoutBranchInput> | SectionCreateWithoutBranchInput[] | SectionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutBranchInput | SectionCreateOrConnectWithoutBranchInput[]
    createMany?: SectionCreateManyBranchInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type StallholderCreateNestedManyWithoutBranchInput = {
    create?: XOR<StallholderCreateWithoutBranchInput, StallholderUncheckedCreateWithoutBranchInput> | StallholderCreateWithoutBranchInput[] | StallholderUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StallholderCreateOrConnectWithoutBranchInput | StallholderCreateOrConnectWithoutBranchInput[]
    createMany?: StallholderCreateManyBranchInputEnvelope
    connect?: StallholderWhereUniqueInput | StallholderWhereUniqueInput[]
  }

  export type StallUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<StallCreateWithoutBranchInput, StallUncheckedCreateWithoutBranchInput> | StallCreateWithoutBranchInput[] | StallUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StallCreateOrConnectWithoutBranchInput | StallCreateOrConnectWithoutBranchInput[]
    createMany?: StallCreateManyBranchInputEnvelope
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<EmployeeCreateWithoutBranchInput, EmployeeUncheckedCreateWithoutBranchInput> | EmployeeCreateWithoutBranchInput[] | EmployeeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutBranchInput | EmployeeCreateOrConnectWithoutBranchInput[]
    createMany?: EmployeeCreateManyBranchInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type FloorUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<FloorCreateWithoutBranchInput, FloorUncheckedCreateWithoutBranchInput> | FloorCreateWithoutBranchInput[] | FloorUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FloorCreateOrConnectWithoutBranchInput | FloorCreateOrConnectWithoutBranchInput[]
    createMany?: FloorCreateManyBranchInputEnvelope
    connect?: FloorWhereUniqueInput | FloorWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<SectionCreateWithoutBranchInput, SectionUncheckedCreateWithoutBranchInput> | SectionCreateWithoutBranchInput[] | SectionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutBranchInput | SectionCreateOrConnectWithoutBranchInput[]
    createMany?: SectionCreateManyBranchInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type StallholderUncheckedCreateNestedManyWithoutBranchInput = {
    create?: XOR<StallholderCreateWithoutBranchInput, StallholderUncheckedCreateWithoutBranchInput> | StallholderCreateWithoutBranchInput[] | StallholderUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StallholderCreateOrConnectWithoutBranchInput | StallholderCreateOrConnectWithoutBranchInput[]
    createMany?: StallholderCreateManyBranchInputEnvelope
    connect?: StallholderWhereUniqueInput | StallholderWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type StallUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StallCreateWithoutBranchInput, StallUncheckedCreateWithoutBranchInput> | StallCreateWithoutBranchInput[] | StallUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StallCreateOrConnectWithoutBranchInput | StallCreateOrConnectWithoutBranchInput[]
    upsert?: StallUpsertWithWhereUniqueWithoutBranchInput | StallUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StallCreateManyBranchInputEnvelope
    set?: StallWhereUniqueInput | StallWhereUniqueInput[]
    disconnect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    delete?: StallWhereUniqueInput | StallWhereUniqueInput[]
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    update?: StallUpdateWithWhereUniqueWithoutBranchInput | StallUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StallUpdateManyWithWhereWithoutBranchInput | StallUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StallScalarWhereInput | StallScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EmployeeCreateWithoutBranchInput, EmployeeUncheckedCreateWithoutBranchInput> | EmployeeCreateWithoutBranchInput[] | EmployeeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutBranchInput | EmployeeCreateOrConnectWithoutBranchInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutBranchInput | EmployeeUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EmployeeCreateManyBranchInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutBranchInput | EmployeeUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutBranchInput | EmployeeUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type FloorUpdateManyWithoutBranchNestedInput = {
    create?: XOR<FloorCreateWithoutBranchInput, FloorUncheckedCreateWithoutBranchInput> | FloorCreateWithoutBranchInput[] | FloorUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FloorCreateOrConnectWithoutBranchInput | FloorCreateOrConnectWithoutBranchInput[]
    upsert?: FloorUpsertWithWhereUniqueWithoutBranchInput | FloorUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: FloorCreateManyBranchInputEnvelope
    set?: FloorWhereUniqueInput | FloorWhereUniqueInput[]
    disconnect?: FloorWhereUniqueInput | FloorWhereUniqueInput[]
    delete?: FloorWhereUniqueInput | FloorWhereUniqueInput[]
    connect?: FloorWhereUniqueInput | FloorWhereUniqueInput[]
    update?: FloorUpdateWithWhereUniqueWithoutBranchInput | FloorUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: FloorUpdateManyWithWhereWithoutBranchInput | FloorUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: FloorScalarWhereInput | FloorScalarWhereInput[]
  }

  export type SectionUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SectionCreateWithoutBranchInput, SectionUncheckedCreateWithoutBranchInput> | SectionCreateWithoutBranchInput[] | SectionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutBranchInput | SectionCreateOrConnectWithoutBranchInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutBranchInput | SectionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SectionCreateManyBranchInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutBranchInput | SectionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutBranchInput | SectionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type StallholderUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StallholderCreateWithoutBranchInput, StallholderUncheckedCreateWithoutBranchInput> | StallholderCreateWithoutBranchInput[] | StallholderUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StallholderCreateOrConnectWithoutBranchInput | StallholderCreateOrConnectWithoutBranchInput[]
    upsert?: StallholderUpsertWithWhereUniqueWithoutBranchInput | StallholderUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StallholderCreateManyBranchInputEnvelope
    set?: StallholderWhereUniqueInput | StallholderWhereUniqueInput[]
    disconnect?: StallholderWhereUniqueInput | StallholderWhereUniqueInput[]
    delete?: StallholderWhereUniqueInput | StallholderWhereUniqueInput[]
    connect?: StallholderWhereUniqueInput | StallholderWhereUniqueInput[]
    update?: StallholderUpdateWithWhereUniqueWithoutBranchInput | StallholderUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StallholderUpdateManyWithWhereWithoutBranchInput | StallholderUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StallholderScalarWhereInput | StallholderScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StallUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StallCreateWithoutBranchInput, StallUncheckedCreateWithoutBranchInput> | StallCreateWithoutBranchInput[] | StallUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StallCreateOrConnectWithoutBranchInput | StallCreateOrConnectWithoutBranchInput[]
    upsert?: StallUpsertWithWhereUniqueWithoutBranchInput | StallUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StallCreateManyBranchInputEnvelope
    set?: StallWhereUniqueInput | StallWhereUniqueInput[]
    disconnect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    delete?: StallWhereUniqueInput | StallWhereUniqueInput[]
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    update?: StallUpdateWithWhereUniqueWithoutBranchInput | StallUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StallUpdateManyWithWhereWithoutBranchInput | StallUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StallScalarWhereInput | StallScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<EmployeeCreateWithoutBranchInput, EmployeeUncheckedCreateWithoutBranchInput> | EmployeeCreateWithoutBranchInput[] | EmployeeUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutBranchInput | EmployeeCreateOrConnectWithoutBranchInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutBranchInput | EmployeeUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: EmployeeCreateManyBranchInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutBranchInput | EmployeeUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutBranchInput | EmployeeUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type FloorUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<FloorCreateWithoutBranchInput, FloorUncheckedCreateWithoutBranchInput> | FloorCreateWithoutBranchInput[] | FloorUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: FloorCreateOrConnectWithoutBranchInput | FloorCreateOrConnectWithoutBranchInput[]
    upsert?: FloorUpsertWithWhereUniqueWithoutBranchInput | FloorUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: FloorCreateManyBranchInputEnvelope
    set?: FloorWhereUniqueInput | FloorWhereUniqueInput[]
    disconnect?: FloorWhereUniqueInput | FloorWhereUniqueInput[]
    delete?: FloorWhereUniqueInput | FloorWhereUniqueInput[]
    connect?: FloorWhereUniqueInput | FloorWhereUniqueInput[]
    update?: FloorUpdateWithWhereUniqueWithoutBranchInput | FloorUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: FloorUpdateManyWithWhereWithoutBranchInput | FloorUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: FloorScalarWhereInput | FloorScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<SectionCreateWithoutBranchInput, SectionUncheckedCreateWithoutBranchInput> | SectionCreateWithoutBranchInput[] | SectionUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutBranchInput | SectionCreateOrConnectWithoutBranchInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutBranchInput | SectionUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: SectionCreateManyBranchInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutBranchInput | SectionUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutBranchInput | SectionUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type StallholderUncheckedUpdateManyWithoutBranchNestedInput = {
    create?: XOR<StallholderCreateWithoutBranchInput, StallholderUncheckedCreateWithoutBranchInput> | StallholderCreateWithoutBranchInput[] | StallholderUncheckedCreateWithoutBranchInput[]
    connectOrCreate?: StallholderCreateOrConnectWithoutBranchInput | StallholderCreateOrConnectWithoutBranchInput[]
    upsert?: StallholderUpsertWithWhereUniqueWithoutBranchInput | StallholderUpsertWithWhereUniqueWithoutBranchInput[]
    createMany?: StallholderCreateManyBranchInputEnvelope
    set?: StallholderWhereUniqueInput | StallholderWhereUniqueInput[]
    disconnect?: StallholderWhereUniqueInput | StallholderWhereUniqueInput[]
    delete?: StallholderWhereUniqueInput | StallholderWhereUniqueInput[]
    connect?: StallholderWhereUniqueInput | StallholderWhereUniqueInput[]
    update?: StallholderUpdateWithWhereUniqueWithoutBranchInput | StallholderUpdateWithWhereUniqueWithoutBranchInput[]
    updateMany?: StallholderUpdateManyWithWhereWithoutBranchInput | StallholderUpdateManyWithWhereWithoutBranchInput[]
    deleteMany?: StallholderScalarWhereInput | StallholderScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutFloorsInput = {
    create?: XOR<BranchCreateWithoutFloorsInput, BranchUncheckedCreateWithoutFloorsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFloorsInput
    connect?: BranchWhereUniqueInput
  }

  export type StallCreateNestedManyWithoutFloorInput = {
    create?: XOR<StallCreateWithoutFloorInput, StallUncheckedCreateWithoutFloorInput> | StallCreateWithoutFloorInput[] | StallUncheckedCreateWithoutFloorInput[]
    connectOrCreate?: StallCreateOrConnectWithoutFloorInput | StallCreateOrConnectWithoutFloorInput[]
    createMany?: StallCreateManyFloorInputEnvelope
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
  }

  export type SectionCreateNestedManyWithoutFloorInput = {
    create?: XOR<SectionCreateWithoutFloorInput, SectionUncheckedCreateWithoutFloorInput> | SectionCreateWithoutFloorInput[] | SectionUncheckedCreateWithoutFloorInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutFloorInput | SectionCreateOrConnectWithoutFloorInput[]
    createMany?: SectionCreateManyFloorInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type StallUncheckedCreateNestedManyWithoutFloorInput = {
    create?: XOR<StallCreateWithoutFloorInput, StallUncheckedCreateWithoutFloorInput> | StallCreateWithoutFloorInput[] | StallUncheckedCreateWithoutFloorInput[]
    connectOrCreate?: StallCreateOrConnectWithoutFloorInput | StallCreateOrConnectWithoutFloorInput[]
    createMany?: StallCreateManyFloorInputEnvelope
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
  }

  export type SectionUncheckedCreateNestedManyWithoutFloorInput = {
    create?: XOR<SectionCreateWithoutFloorInput, SectionUncheckedCreateWithoutFloorInput> | SectionCreateWithoutFloorInput[] | SectionUncheckedCreateWithoutFloorInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutFloorInput | SectionCreateOrConnectWithoutFloorInput[]
    createMany?: SectionCreateManyFloorInputEnvelope
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutFloorsNestedInput = {
    create?: XOR<BranchCreateWithoutFloorsInput, BranchUncheckedCreateWithoutFloorsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutFloorsInput
    upsert?: BranchUpsertWithoutFloorsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutFloorsInput, BranchUpdateWithoutFloorsInput>, BranchUncheckedUpdateWithoutFloorsInput>
  }

  export type StallUpdateManyWithoutFloorNestedInput = {
    create?: XOR<StallCreateWithoutFloorInput, StallUncheckedCreateWithoutFloorInput> | StallCreateWithoutFloorInput[] | StallUncheckedCreateWithoutFloorInput[]
    connectOrCreate?: StallCreateOrConnectWithoutFloorInput | StallCreateOrConnectWithoutFloorInput[]
    upsert?: StallUpsertWithWhereUniqueWithoutFloorInput | StallUpsertWithWhereUniqueWithoutFloorInput[]
    createMany?: StallCreateManyFloorInputEnvelope
    set?: StallWhereUniqueInput | StallWhereUniqueInput[]
    disconnect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    delete?: StallWhereUniqueInput | StallWhereUniqueInput[]
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    update?: StallUpdateWithWhereUniqueWithoutFloorInput | StallUpdateWithWhereUniqueWithoutFloorInput[]
    updateMany?: StallUpdateManyWithWhereWithoutFloorInput | StallUpdateManyWithWhereWithoutFloorInput[]
    deleteMany?: StallScalarWhereInput | StallScalarWhereInput[]
  }

  export type SectionUpdateManyWithoutFloorNestedInput = {
    create?: XOR<SectionCreateWithoutFloorInput, SectionUncheckedCreateWithoutFloorInput> | SectionCreateWithoutFloorInput[] | SectionUncheckedCreateWithoutFloorInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutFloorInput | SectionCreateOrConnectWithoutFloorInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutFloorInput | SectionUpsertWithWhereUniqueWithoutFloorInput[]
    createMany?: SectionCreateManyFloorInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutFloorInput | SectionUpdateWithWhereUniqueWithoutFloorInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutFloorInput | SectionUpdateManyWithWhereWithoutFloorInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type StallUncheckedUpdateManyWithoutFloorNestedInput = {
    create?: XOR<StallCreateWithoutFloorInput, StallUncheckedCreateWithoutFloorInput> | StallCreateWithoutFloorInput[] | StallUncheckedCreateWithoutFloorInput[]
    connectOrCreate?: StallCreateOrConnectWithoutFloorInput | StallCreateOrConnectWithoutFloorInput[]
    upsert?: StallUpsertWithWhereUniqueWithoutFloorInput | StallUpsertWithWhereUniqueWithoutFloorInput[]
    createMany?: StallCreateManyFloorInputEnvelope
    set?: StallWhereUniqueInput | StallWhereUniqueInput[]
    disconnect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    delete?: StallWhereUniqueInput | StallWhereUniqueInput[]
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    update?: StallUpdateWithWhereUniqueWithoutFloorInput | StallUpdateWithWhereUniqueWithoutFloorInput[]
    updateMany?: StallUpdateManyWithWhereWithoutFloorInput | StallUpdateManyWithWhereWithoutFloorInput[]
    deleteMany?: StallScalarWhereInput | StallScalarWhereInput[]
  }

  export type SectionUncheckedUpdateManyWithoutFloorNestedInput = {
    create?: XOR<SectionCreateWithoutFloorInput, SectionUncheckedCreateWithoutFloorInput> | SectionCreateWithoutFloorInput[] | SectionUncheckedCreateWithoutFloorInput[]
    connectOrCreate?: SectionCreateOrConnectWithoutFloorInput | SectionCreateOrConnectWithoutFloorInput[]
    upsert?: SectionUpsertWithWhereUniqueWithoutFloorInput | SectionUpsertWithWhereUniqueWithoutFloorInput[]
    createMany?: SectionCreateManyFloorInputEnvelope
    set?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    disconnect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    delete?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    connect?: SectionWhereUniqueInput | SectionWhereUniqueInput[]
    update?: SectionUpdateWithWhereUniqueWithoutFloorInput | SectionUpdateWithWhereUniqueWithoutFloorInput[]
    updateMany?: SectionUpdateManyWithWhereWithoutFloorInput | SectionUpdateManyWithWhereWithoutFloorInput[]
    deleteMany?: SectionScalarWhereInput | SectionScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutSectionsInput = {
    create?: XOR<BranchCreateWithoutSectionsInput, BranchUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSectionsInput
    connect?: BranchWhereUniqueInput
  }

  export type FloorCreateNestedOneWithoutSectionsInput = {
    create?: XOR<FloorCreateWithoutSectionsInput, FloorUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: FloorCreateOrConnectWithoutSectionsInput
    connect?: FloorWhereUniqueInput
  }

  export type StallCreateNestedManyWithoutSectionRefInput = {
    create?: XOR<StallCreateWithoutSectionRefInput, StallUncheckedCreateWithoutSectionRefInput> | StallCreateWithoutSectionRefInput[] | StallUncheckedCreateWithoutSectionRefInput[]
    connectOrCreate?: StallCreateOrConnectWithoutSectionRefInput | StallCreateOrConnectWithoutSectionRefInput[]
    createMany?: StallCreateManySectionRefInputEnvelope
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
  }

  export type StallUncheckedCreateNestedManyWithoutSectionRefInput = {
    create?: XOR<StallCreateWithoutSectionRefInput, StallUncheckedCreateWithoutSectionRefInput> | StallCreateWithoutSectionRefInput[] | StallUncheckedCreateWithoutSectionRefInput[]
    connectOrCreate?: StallCreateOrConnectWithoutSectionRefInput | StallCreateOrConnectWithoutSectionRefInput[]
    createMany?: StallCreateManySectionRefInputEnvelope
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
  }

  export type BranchUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<BranchCreateWithoutSectionsInput, BranchUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutSectionsInput
    upsert?: BranchUpsertWithoutSectionsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutSectionsInput, BranchUpdateWithoutSectionsInput>, BranchUncheckedUpdateWithoutSectionsInput>
  }

  export type FloorUpdateOneWithoutSectionsNestedInput = {
    create?: XOR<FloorCreateWithoutSectionsInput, FloorUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: FloorCreateOrConnectWithoutSectionsInput
    upsert?: FloorUpsertWithoutSectionsInput
    disconnect?: FloorWhereInput | boolean
    delete?: FloorWhereInput | boolean
    connect?: FloorWhereUniqueInput
    update?: XOR<XOR<FloorUpdateToOneWithWhereWithoutSectionsInput, FloorUpdateWithoutSectionsInput>, FloorUncheckedUpdateWithoutSectionsInput>
  }

  export type StallUpdateManyWithoutSectionRefNestedInput = {
    create?: XOR<StallCreateWithoutSectionRefInput, StallUncheckedCreateWithoutSectionRefInput> | StallCreateWithoutSectionRefInput[] | StallUncheckedCreateWithoutSectionRefInput[]
    connectOrCreate?: StallCreateOrConnectWithoutSectionRefInput | StallCreateOrConnectWithoutSectionRefInput[]
    upsert?: StallUpsertWithWhereUniqueWithoutSectionRefInput | StallUpsertWithWhereUniqueWithoutSectionRefInput[]
    createMany?: StallCreateManySectionRefInputEnvelope
    set?: StallWhereUniqueInput | StallWhereUniqueInput[]
    disconnect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    delete?: StallWhereUniqueInput | StallWhereUniqueInput[]
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    update?: StallUpdateWithWhereUniqueWithoutSectionRefInput | StallUpdateWithWhereUniqueWithoutSectionRefInput[]
    updateMany?: StallUpdateManyWithWhereWithoutSectionRefInput | StallUpdateManyWithWhereWithoutSectionRefInput[]
    deleteMany?: StallScalarWhereInput | StallScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StallUncheckedUpdateManyWithoutSectionRefNestedInput = {
    create?: XOR<StallCreateWithoutSectionRefInput, StallUncheckedCreateWithoutSectionRefInput> | StallCreateWithoutSectionRefInput[] | StallUncheckedCreateWithoutSectionRefInput[]
    connectOrCreate?: StallCreateOrConnectWithoutSectionRefInput | StallCreateOrConnectWithoutSectionRefInput[]
    upsert?: StallUpsertWithWhereUniqueWithoutSectionRefInput | StallUpsertWithWhereUniqueWithoutSectionRefInput[]
    createMany?: StallCreateManySectionRefInputEnvelope
    set?: StallWhereUniqueInput | StallWhereUniqueInput[]
    disconnect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    delete?: StallWhereUniqueInput | StallWhereUniqueInput[]
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    update?: StallUpdateWithWhereUniqueWithoutSectionRefInput | StallUpdateWithWhereUniqueWithoutSectionRefInput[]
    updateMany?: StallUpdateManyWithWhereWithoutSectionRefInput | StallUpdateManyWithWhereWithoutSectionRefInput[]
    deleteMany?: StallScalarWhereInput | StallScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutStallsInput = {
    create?: XOR<BranchCreateWithoutStallsInput, BranchUncheckedCreateWithoutStallsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStallsInput
    connect?: BranchWhereUniqueInput
  }

  export type FloorCreateNestedOneWithoutStallsInput = {
    create?: XOR<FloorCreateWithoutStallsInput, FloorUncheckedCreateWithoutStallsInput>
    connectOrCreate?: FloorCreateOrConnectWithoutStallsInput
    connect?: FloorWhereUniqueInput
  }

  export type SectionCreateNestedOneWithoutStallsInput = {
    create?: XOR<SectionCreateWithoutStallsInput, SectionUncheckedCreateWithoutStallsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutStallsInput
    connect?: SectionWhereUniqueInput
  }

  export type StallholderCreateNestedOneWithoutStallsInput = {
    create?: XOR<StallholderCreateWithoutStallsInput, StallholderUncheckedCreateWithoutStallsInput>
    connectOrCreate?: StallholderCreateOrConnectWithoutStallsInput
    connect?: StallholderWhereUniqueInput
  }

  export type StallImageCreateNestedManyWithoutStallInput = {
    create?: XOR<StallImageCreateWithoutStallInput, StallImageUncheckedCreateWithoutStallInput> | StallImageCreateWithoutStallInput[] | StallImageUncheckedCreateWithoutStallInput[]
    connectOrCreate?: StallImageCreateOrConnectWithoutStallInput | StallImageCreateOrConnectWithoutStallInput[]
    createMany?: StallImageCreateManyStallInputEnvelope
    connect?: StallImageWhereUniqueInput | StallImageWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutStallInput = {
    create?: XOR<PaymentCreateWithoutStallInput, PaymentUncheckedCreateWithoutStallInput> | PaymentCreateWithoutStallInput[] | PaymentUncheckedCreateWithoutStallInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStallInput | PaymentCreateOrConnectWithoutStallInput[]
    createMany?: PaymentCreateManyStallInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ComplianceCreateNestedManyWithoutStallInput = {
    create?: XOR<ComplianceCreateWithoutStallInput, ComplianceUncheckedCreateWithoutStallInput> | ComplianceCreateWithoutStallInput[] | ComplianceUncheckedCreateWithoutStallInput[]
    connectOrCreate?: ComplianceCreateOrConnectWithoutStallInput | ComplianceCreateOrConnectWithoutStallInput[]
    createMany?: ComplianceCreateManyStallInputEnvelope
    connect?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
  }

  export type ComplaintCreateNestedManyWithoutStallInput = {
    create?: XOR<ComplaintCreateWithoutStallInput, ComplaintUncheckedCreateWithoutStallInput> | ComplaintCreateWithoutStallInput[] | ComplaintUncheckedCreateWithoutStallInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutStallInput | ComplaintCreateOrConnectWithoutStallInput[]
    createMany?: ComplaintCreateManyStallInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type VendorCreateNestedManyWithoutStallInput = {
    create?: XOR<VendorCreateWithoutStallInput, VendorUncheckedCreateWithoutStallInput> | VendorCreateWithoutStallInput[] | VendorUncheckedCreateWithoutStallInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutStallInput | VendorCreateOrConnectWithoutStallInput[]
    createMany?: VendorCreateManyStallInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type StallImageUncheckedCreateNestedManyWithoutStallInput = {
    create?: XOR<StallImageCreateWithoutStallInput, StallImageUncheckedCreateWithoutStallInput> | StallImageCreateWithoutStallInput[] | StallImageUncheckedCreateWithoutStallInput[]
    connectOrCreate?: StallImageCreateOrConnectWithoutStallInput | StallImageCreateOrConnectWithoutStallInput[]
    createMany?: StallImageCreateManyStallInputEnvelope
    connect?: StallImageWhereUniqueInput | StallImageWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutStallInput = {
    create?: XOR<PaymentCreateWithoutStallInput, PaymentUncheckedCreateWithoutStallInput> | PaymentCreateWithoutStallInput[] | PaymentUncheckedCreateWithoutStallInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStallInput | PaymentCreateOrConnectWithoutStallInput[]
    createMany?: PaymentCreateManyStallInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ComplianceUncheckedCreateNestedManyWithoutStallInput = {
    create?: XOR<ComplianceCreateWithoutStallInput, ComplianceUncheckedCreateWithoutStallInput> | ComplianceCreateWithoutStallInput[] | ComplianceUncheckedCreateWithoutStallInput[]
    connectOrCreate?: ComplianceCreateOrConnectWithoutStallInput | ComplianceCreateOrConnectWithoutStallInput[]
    createMany?: ComplianceCreateManyStallInputEnvelope
    connect?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
  }

  export type ComplaintUncheckedCreateNestedManyWithoutStallInput = {
    create?: XOR<ComplaintCreateWithoutStallInput, ComplaintUncheckedCreateWithoutStallInput> | ComplaintCreateWithoutStallInput[] | ComplaintUncheckedCreateWithoutStallInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutStallInput | ComplaintCreateOrConnectWithoutStallInput[]
    createMany?: ComplaintCreateManyStallInputEnvelope
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
  }

  export type VendorUncheckedCreateNestedManyWithoutStallInput = {
    create?: XOR<VendorCreateWithoutStallInput, VendorUncheckedCreateWithoutStallInput> | VendorCreateWithoutStallInput[] | VendorUncheckedCreateWithoutStallInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutStallInput | VendorCreateOrConnectWithoutStallInput[]
    createMany?: VendorCreateManyStallInputEnvelope
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type BranchUpdateOneRequiredWithoutStallsNestedInput = {
    create?: XOR<BranchCreateWithoutStallsInput, BranchUncheckedCreateWithoutStallsInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStallsInput
    upsert?: BranchUpsertWithoutStallsInput
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutStallsInput, BranchUpdateWithoutStallsInput>, BranchUncheckedUpdateWithoutStallsInput>
  }

  export type FloorUpdateOneWithoutStallsNestedInput = {
    create?: XOR<FloorCreateWithoutStallsInput, FloorUncheckedCreateWithoutStallsInput>
    connectOrCreate?: FloorCreateOrConnectWithoutStallsInput
    upsert?: FloorUpsertWithoutStallsInput
    disconnect?: FloorWhereInput | boolean
    delete?: FloorWhereInput | boolean
    connect?: FloorWhereUniqueInput
    update?: XOR<XOR<FloorUpdateToOneWithWhereWithoutStallsInput, FloorUpdateWithoutStallsInput>, FloorUncheckedUpdateWithoutStallsInput>
  }

  export type SectionUpdateOneWithoutStallsNestedInput = {
    create?: XOR<SectionCreateWithoutStallsInput, SectionUncheckedCreateWithoutStallsInput>
    connectOrCreate?: SectionCreateOrConnectWithoutStallsInput
    upsert?: SectionUpsertWithoutStallsInput
    disconnect?: SectionWhereInput | boolean
    delete?: SectionWhereInput | boolean
    connect?: SectionWhereUniqueInput
    update?: XOR<XOR<SectionUpdateToOneWithWhereWithoutStallsInput, SectionUpdateWithoutStallsInput>, SectionUncheckedUpdateWithoutStallsInput>
  }

  export type StallholderUpdateOneWithoutStallsNestedInput = {
    create?: XOR<StallholderCreateWithoutStallsInput, StallholderUncheckedCreateWithoutStallsInput>
    connectOrCreate?: StallholderCreateOrConnectWithoutStallsInput
    upsert?: StallholderUpsertWithoutStallsInput
    disconnect?: StallholderWhereInput | boolean
    delete?: StallholderWhereInput | boolean
    connect?: StallholderWhereUniqueInput
    update?: XOR<XOR<StallholderUpdateToOneWithWhereWithoutStallsInput, StallholderUpdateWithoutStallsInput>, StallholderUncheckedUpdateWithoutStallsInput>
  }

  export type StallImageUpdateManyWithoutStallNestedInput = {
    create?: XOR<StallImageCreateWithoutStallInput, StallImageUncheckedCreateWithoutStallInput> | StallImageCreateWithoutStallInput[] | StallImageUncheckedCreateWithoutStallInput[]
    connectOrCreate?: StallImageCreateOrConnectWithoutStallInput | StallImageCreateOrConnectWithoutStallInput[]
    upsert?: StallImageUpsertWithWhereUniqueWithoutStallInput | StallImageUpsertWithWhereUniqueWithoutStallInput[]
    createMany?: StallImageCreateManyStallInputEnvelope
    set?: StallImageWhereUniqueInput | StallImageWhereUniqueInput[]
    disconnect?: StallImageWhereUniqueInput | StallImageWhereUniqueInput[]
    delete?: StallImageWhereUniqueInput | StallImageWhereUniqueInput[]
    connect?: StallImageWhereUniqueInput | StallImageWhereUniqueInput[]
    update?: StallImageUpdateWithWhereUniqueWithoutStallInput | StallImageUpdateWithWhereUniqueWithoutStallInput[]
    updateMany?: StallImageUpdateManyWithWhereWithoutStallInput | StallImageUpdateManyWithWhereWithoutStallInput[]
    deleteMany?: StallImageScalarWhereInput | StallImageScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutStallNestedInput = {
    create?: XOR<PaymentCreateWithoutStallInput, PaymentUncheckedCreateWithoutStallInput> | PaymentCreateWithoutStallInput[] | PaymentUncheckedCreateWithoutStallInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStallInput | PaymentCreateOrConnectWithoutStallInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutStallInput | PaymentUpsertWithWhereUniqueWithoutStallInput[]
    createMany?: PaymentCreateManyStallInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutStallInput | PaymentUpdateWithWhereUniqueWithoutStallInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutStallInput | PaymentUpdateManyWithWhereWithoutStallInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ComplianceUpdateManyWithoutStallNestedInput = {
    create?: XOR<ComplianceCreateWithoutStallInput, ComplianceUncheckedCreateWithoutStallInput> | ComplianceCreateWithoutStallInput[] | ComplianceUncheckedCreateWithoutStallInput[]
    connectOrCreate?: ComplianceCreateOrConnectWithoutStallInput | ComplianceCreateOrConnectWithoutStallInput[]
    upsert?: ComplianceUpsertWithWhereUniqueWithoutStallInput | ComplianceUpsertWithWhereUniqueWithoutStallInput[]
    createMany?: ComplianceCreateManyStallInputEnvelope
    set?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    disconnect?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    delete?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    connect?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    update?: ComplianceUpdateWithWhereUniqueWithoutStallInput | ComplianceUpdateWithWhereUniqueWithoutStallInput[]
    updateMany?: ComplianceUpdateManyWithWhereWithoutStallInput | ComplianceUpdateManyWithWhereWithoutStallInput[]
    deleteMany?: ComplianceScalarWhereInput | ComplianceScalarWhereInput[]
  }

  export type ComplaintUpdateManyWithoutStallNestedInput = {
    create?: XOR<ComplaintCreateWithoutStallInput, ComplaintUncheckedCreateWithoutStallInput> | ComplaintCreateWithoutStallInput[] | ComplaintUncheckedCreateWithoutStallInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutStallInput | ComplaintCreateOrConnectWithoutStallInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutStallInput | ComplaintUpsertWithWhereUniqueWithoutStallInput[]
    createMany?: ComplaintCreateManyStallInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutStallInput | ComplaintUpdateWithWhereUniqueWithoutStallInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutStallInput | ComplaintUpdateManyWithWhereWithoutStallInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type VendorUpdateManyWithoutStallNestedInput = {
    create?: XOR<VendorCreateWithoutStallInput, VendorUncheckedCreateWithoutStallInput> | VendorCreateWithoutStallInput[] | VendorUncheckedCreateWithoutStallInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutStallInput | VendorCreateOrConnectWithoutStallInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutStallInput | VendorUpsertWithWhereUniqueWithoutStallInput[]
    createMany?: VendorCreateManyStallInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutStallInput | VendorUpdateWithWhereUniqueWithoutStallInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutStallInput | VendorUpdateManyWithWhereWithoutStallInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type StallImageUncheckedUpdateManyWithoutStallNestedInput = {
    create?: XOR<StallImageCreateWithoutStallInput, StallImageUncheckedCreateWithoutStallInput> | StallImageCreateWithoutStallInput[] | StallImageUncheckedCreateWithoutStallInput[]
    connectOrCreate?: StallImageCreateOrConnectWithoutStallInput | StallImageCreateOrConnectWithoutStallInput[]
    upsert?: StallImageUpsertWithWhereUniqueWithoutStallInput | StallImageUpsertWithWhereUniqueWithoutStallInput[]
    createMany?: StallImageCreateManyStallInputEnvelope
    set?: StallImageWhereUniqueInput | StallImageWhereUniqueInput[]
    disconnect?: StallImageWhereUniqueInput | StallImageWhereUniqueInput[]
    delete?: StallImageWhereUniqueInput | StallImageWhereUniqueInput[]
    connect?: StallImageWhereUniqueInput | StallImageWhereUniqueInput[]
    update?: StallImageUpdateWithWhereUniqueWithoutStallInput | StallImageUpdateWithWhereUniqueWithoutStallInput[]
    updateMany?: StallImageUpdateManyWithWhereWithoutStallInput | StallImageUpdateManyWithWhereWithoutStallInput[]
    deleteMany?: StallImageScalarWhereInput | StallImageScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutStallNestedInput = {
    create?: XOR<PaymentCreateWithoutStallInput, PaymentUncheckedCreateWithoutStallInput> | PaymentCreateWithoutStallInput[] | PaymentUncheckedCreateWithoutStallInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStallInput | PaymentCreateOrConnectWithoutStallInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutStallInput | PaymentUpsertWithWhereUniqueWithoutStallInput[]
    createMany?: PaymentCreateManyStallInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutStallInput | PaymentUpdateWithWhereUniqueWithoutStallInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutStallInput | PaymentUpdateManyWithWhereWithoutStallInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ComplianceUncheckedUpdateManyWithoutStallNestedInput = {
    create?: XOR<ComplianceCreateWithoutStallInput, ComplianceUncheckedCreateWithoutStallInput> | ComplianceCreateWithoutStallInput[] | ComplianceUncheckedCreateWithoutStallInput[]
    connectOrCreate?: ComplianceCreateOrConnectWithoutStallInput | ComplianceCreateOrConnectWithoutStallInput[]
    upsert?: ComplianceUpsertWithWhereUniqueWithoutStallInput | ComplianceUpsertWithWhereUniqueWithoutStallInput[]
    createMany?: ComplianceCreateManyStallInputEnvelope
    set?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    disconnect?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    delete?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    connect?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    update?: ComplianceUpdateWithWhereUniqueWithoutStallInput | ComplianceUpdateWithWhereUniqueWithoutStallInput[]
    updateMany?: ComplianceUpdateManyWithWhereWithoutStallInput | ComplianceUpdateManyWithWhereWithoutStallInput[]
    deleteMany?: ComplianceScalarWhereInput | ComplianceScalarWhereInput[]
  }

  export type ComplaintUncheckedUpdateManyWithoutStallNestedInput = {
    create?: XOR<ComplaintCreateWithoutStallInput, ComplaintUncheckedCreateWithoutStallInput> | ComplaintCreateWithoutStallInput[] | ComplaintUncheckedCreateWithoutStallInput[]
    connectOrCreate?: ComplaintCreateOrConnectWithoutStallInput | ComplaintCreateOrConnectWithoutStallInput[]
    upsert?: ComplaintUpsertWithWhereUniqueWithoutStallInput | ComplaintUpsertWithWhereUniqueWithoutStallInput[]
    createMany?: ComplaintCreateManyStallInputEnvelope
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[]
    update?: ComplaintUpdateWithWhereUniqueWithoutStallInput | ComplaintUpdateWithWhereUniqueWithoutStallInput[]
    updateMany?: ComplaintUpdateManyWithWhereWithoutStallInput | ComplaintUpdateManyWithWhereWithoutStallInput[]
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
  }

  export type VendorUncheckedUpdateManyWithoutStallNestedInput = {
    create?: XOR<VendorCreateWithoutStallInput, VendorUncheckedCreateWithoutStallInput> | VendorCreateWithoutStallInput[] | VendorUncheckedCreateWithoutStallInput[]
    connectOrCreate?: VendorCreateOrConnectWithoutStallInput | VendorCreateOrConnectWithoutStallInput[]
    upsert?: VendorUpsertWithWhereUniqueWithoutStallInput | VendorUpsertWithWhereUniqueWithoutStallInput[]
    createMany?: VendorCreateManyStallInputEnvelope
    set?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    disconnect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    delete?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    connect?: VendorWhereUniqueInput | VendorWhereUniqueInput[]
    update?: VendorUpdateWithWhereUniqueWithoutStallInput | VendorUpdateWithWhereUniqueWithoutStallInput[]
    updateMany?: VendorUpdateManyWithWhereWithoutStallInput | VendorUpdateManyWithWhereWithoutStallInput[]
    deleteMany?: VendorScalarWhereInput | VendorScalarWhereInput[]
  }

  export type StallCreateNestedOneWithoutImagesInput = {
    create?: XOR<StallCreateWithoutImagesInput, StallUncheckedCreateWithoutImagesInput>
    connectOrCreate?: StallCreateOrConnectWithoutImagesInput
    connect?: StallWhereUniqueInput
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Bytes | null
  }

  export type StallUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<StallCreateWithoutImagesInput, StallUncheckedCreateWithoutImagesInput>
    connectOrCreate?: StallCreateOrConnectWithoutImagesInput
    upsert?: StallUpsertWithoutImagesInput
    connect?: StallWhereUniqueInput
    update?: XOR<XOR<StallUpdateToOneWithWhereWithoutImagesInput, StallUpdateWithoutImagesInput>, StallUncheckedUpdateWithoutImagesInput>
  }

  export type BranchCreateNestedOneWithoutStallholdersInput = {
    create?: XOR<BranchCreateWithoutStallholdersInput, BranchUncheckedCreateWithoutStallholdersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStallholdersInput
    connect?: BranchWhereUniqueInput
  }

  export type StallCreateNestedManyWithoutStallholderInput = {
    create?: XOR<StallCreateWithoutStallholderInput, StallUncheckedCreateWithoutStallholderInput> | StallCreateWithoutStallholderInput[] | StallUncheckedCreateWithoutStallholderInput[]
    connectOrCreate?: StallCreateOrConnectWithoutStallholderInput | StallCreateOrConnectWithoutStallholderInput[]
    createMany?: StallCreateManyStallholderInputEnvelope
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutStallholderInput = {
    create?: XOR<PaymentCreateWithoutStallholderInput, PaymentUncheckedCreateWithoutStallholderInput> | PaymentCreateWithoutStallholderInput[] | PaymentUncheckedCreateWithoutStallholderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStallholderInput | PaymentCreateOrConnectWithoutStallholderInput[]
    createMany?: PaymentCreateManyStallholderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ApplicationCreateNestedManyWithoutStallholderInput = {
    create?: XOR<ApplicationCreateWithoutStallholderInput, ApplicationUncheckedCreateWithoutStallholderInput> | ApplicationCreateWithoutStallholderInput[] | ApplicationUncheckedCreateWithoutStallholderInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutStallholderInput | ApplicationCreateOrConnectWithoutStallholderInput[]
    createMany?: ApplicationCreateManyStallholderInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type StallUncheckedCreateNestedManyWithoutStallholderInput = {
    create?: XOR<StallCreateWithoutStallholderInput, StallUncheckedCreateWithoutStallholderInput> | StallCreateWithoutStallholderInput[] | StallUncheckedCreateWithoutStallholderInput[]
    connectOrCreate?: StallCreateOrConnectWithoutStallholderInput | StallCreateOrConnectWithoutStallholderInput[]
    createMany?: StallCreateManyStallholderInputEnvelope
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutStallholderInput = {
    create?: XOR<PaymentCreateWithoutStallholderInput, PaymentUncheckedCreateWithoutStallholderInput> | PaymentCreateWithoutStallholderInput[] | PaymentUncheckedCreateWithoutStallholderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStallholderInput | PaymentCreateOrConnectWithoutStallholderInput[]
    createMany?: PaymentCreateManyStallholderInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ApplicationUncheckedCreateNestedManyWithoutStallholderInput = {
    create?: XOR<ApplicationCreateWithoutStallholderInput, ApplicationUncheckedCreateWithoutStallholderInput> | ApplicationCreateWithoutStallholderInput[] | ApplicationUncheckedCreateWithoutStallholderInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutStallholderInput | ApplicationCreateOrConnectWithoutStallholderInput[]
    createMany?: ApplicationCreateManyStallholderInputEnvelope
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
  }

  export type BranchUpdateOneWithoutStallholdersNestedInput = {
    create?: XOR<BranchCreateWithoutStallholdersInput, BranchUncheckedCreateWithoutStallholdersInput>
    connectOrCreate?: BranchCreateOrConnectWithoutStallholdersInput
    upsert?: BranchUpsertWithoutStallholdersInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutStallholdersInput, BranchUpdateWithoutStallholdersInput>, BranchUncheckedUpdateWithoutStallholdersInput>
  }

  export type StallUpdateManyWithoutStallholderNestedInput = {
    create?: XOR<StallCreateWithoutStallholderInput, StallUncheckedCreateWithoutStallholderInput> | StallCreateWithoutStallholderInput[] | StallUncheckedCreateWithoutStallholderInput[]
    connectOrCreate?: StallCreateOrConnectWithoutStallholderInput | StallCreateOrConnectWithoutStallholderInput[]
    upsert?: StallUpsertWithWhereUniqueWithoutStallholderInput | StallUpsertWithWhereUniqueWithoutStallholderInput[]
    createMany?: StallCreateManyStallholderInputEnvelope
    set?: StallWhereUniqueInput | StallWhereUniqueInput[]
    disconnect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    delete?: StallWhereUniqueInput | StallWhereUniqueInput[]
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    update?: StallUpdateWithWhereUniqueWithoutStallholderInput | StallUpdateWithWhereUniqueWithoutStallholderInput[]
    updateMany?: StallUpdateManyWithWhereWithoutStallholderInput | StallUpdateManyWithWhereWithoutStallholderInput[]
    deleteMany?: StallScalarWhereInput | StallScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutStallholderNestedInput = {
    create?: XOR<PaymentCreateWithoutStallholderInput, PaymentUncheckedCreateWithoutStallholderInput> | PaymentCreateWithoutStallholderInput[] | PaymentUncheckedCreateWithoutStallholderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStallholderInput | PaymentCreateOrConnectWithoutStallholderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutStallholderInput | PaymentUpsertWithWhereUniqueWithoutStallholderInput[]
    createMany?: PaymentCreateManyStallholderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutStallholderInput | PaymentUpdateWithWhereUniqueWithoutStallholderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutStallholderInput | PaymentUpdateManyWithWhereWithoutStallholderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ApplicationUpdateManyWithoutStallholderNestedInput = {
    create?: XOR<ApplicationCreateWithoutStallholderInput, ApplicationUncheckedCreateWithoutStallholderInput> | ApplicationCreateWithoutStallholderInput[] | ApplicationUncheckedCreateWithoutStallholderInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutStallholderInput | ApplicationCreateOrConnectWithoutStallholderInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutStallholderInput | ApplicationUpsertWithWhereUniqueWithoutStallholderInput[]
    createMany?: ApplicationCreateManyStallholderInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutStallholderInput | ApplicationUpdateWithWhereUniqueWithoutStallholderInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutStallholderInput | ApplicationUpdateManyWithWhereWithoutStallholderInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type StallUncheckedUpdateManyWithoutStallholderNestedInput = {
    create?: XOR<StallCreateWithoutStallholderInput, StallUncheckedCreateWithoutStallholderInput> | StallCreateWithoutStallholderInput[] | StallUncheckedCreateWithoutStallholderInput[]
    connectOrCreate?: StallCreateOrConnectWithoutStallholderInput | StallCreateOrConnectWithoutStallholderInput[]
    upsert?: StallUpsertWithWhereUniqueWithoutStallholderInput | StallUpsertWithWhereUniqueWithoutStallholderInput[]
    createMany?: StallCreateManyStallholderInputEnvelope
    set?: StallWhereUniqueInput | StallWhereUniqueInput[]
    disconnect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    delete?: StallWhereUniqueInput | StallWhereUniqueInput[]
    connect?: StallWhereUniqueInput | StallWhereUniqueInput[]
    update?: StallUpdateWithWhereUniqueWithoutStallholderInput | StallUpdateWithWhereUniqueWithoutStallholderInput[]
    updateMany?: StallUpdateManyWithWhereWithoutStallholderInput | StallUpdateManyWithWhereWithoutStallholderInput[]
    deleteMany?: StallScalarWhereInput | StallScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutStallholderNestedInput = {
    create?: XOR<PaymentCreateWithoutStallholderInput, PaymentUncheckedCreateWithoutStallholderInput> | PaymentCreateWithoutStallholderInput[] | PaymentUncheckedCreateWithoutStallholderInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStallholderInput | PaymentCreateOrConnectWithoutStallholderInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutStallholderInput | PaymentUpsertWithWhereUniqueWithoutStallholderInput[]
    createMany?: PaymentCreateManyStallholderInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutStallholderInput | PaymentUpdateWithWhereUniqueWithoutStallholderInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutStallholderInput | PaymentUpdateManyWithWhereWithoutStallholderInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ApplicationUncheckedUpdateManyWithoutStallholderNestedInput = {
    create?: XOR<ApplicationCreateWithoutStallholderInput, ApplicationUncheckedCreateWithoutStallholderInput> | ApplicationCreateWithoutStallholderInput[] | ApplicationUncheckedCreateWithoutStallholderInput[]
    connectOrCreate?: ApplicationCreateOrConnectWithoutStallholderInput | ApplicationCreateOrConnectWithoutStallholderInput[]
    upsert?: ApplicationUpsertWithWhereUniqueWithoutStallholderInput | ApplicationUpsertWithWhereUniqueWithoutStallholderInput[]
    createMany?: ApplicationCreateManyStallholderInputEnvelope
    set?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    disconnect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    delete?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    connect?: ApplicationWhereUniqueInput | ApplicationWhereUniqueInput[]
    update?: ApplicationUpdateWithWhereUniqueWithoutStallholderInput | ApplicationUpdateWithWhereUniqueWithoutStallholderInput[]
    updateMany?: ApplicationUpdateManyWithWhereWithoutStallholderInput | ApplicationUpdateManyWithWhereWithoutStallholderInput[]
    deleteMany?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
  }

  export type BranchCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<BranchCreateWithoutEmployeesInput, BranchUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEmployeesInput
    connect?: BranchWhereUniqueInput
  }

  export type ComplianceCreateNestedManyWithoutInspectorInput = {
    create?: XOR<ComplianceCreateWithoutInspectorInput, ComplianceUncheckedCreateWithoutInspectorInput> | ComplianceCreateWithoutInspectorInput[] | ComplianceUncheckedCreateWithoutInspectorInput[]
    connectOrCreate?: ComplianceCreateOrConnectWithoutInspectorInput | ComplianceCreateOrConnectWithoutInspectorInput[]
    createMany?: ComplianceCreateManyInspectorInputEnvelope
    connect?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutCollectorInput = {
    create?: XOR<PaymentCreateWithoutCollectorInput, PaymentUncheckedCreateWithoutCollectorInput> | PaymentCreateWithoutCollectorInput[] | PaymentUncheckedCreateWithoutCollectorInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCollectorInput | PaymentCreateOrConnectWithoutCollectorInput[]
    createMany?: PaymentCreateManyCollectorInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ActivityLogCreateWithoutEmployeeInput, ActivityLogUncheckedCreateWithoutEmployeeInput> | ActivityLogCreateWithoutEmployeeInput[] | ActivityLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutEmployeeInput | ActivityLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: ActivityLogCreateManyEmployeeInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type ComplianceUncheckedCreateNestedManyWithoutInspectorInput = {
    create?: XOR<ComplianceCreateWithoutInspectorInput, ComplianceUncheckedCreateWithoutInspectorInput> | ComplianceCreateWithoutInspectorInput[] | ComplianceUncheckedCreateWithoutInspectorInput[]
    connectOrCreate?: ComplianceCreateOrConnectWithoutInspectorInput | ComplianceCreateOrConnectWithoutInspectorInput[]
    createMany?: ComplianceCreateManyInspectorInputEnvelope
    connect?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutCollectorInput = {
    create?: XOR<PaymentCreateWithoutCollectorInput, PaymentUncheckedCreateWithoutCollectorInput> | PaymentCreateWithoutCollectorInput[] | PaymentUncheckedCreateWithoutCollectorInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCollectorInput | PaymentCreateOrConnectWithoutCollectorInput[]
    createMany?: PaymentCreateManyCollectorInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ActivityLogCreateWithoutEmployeeInput, ActivityLogUncheckedCreateWithoutEmployeeInput> | ActivityLogCreateWithoutEmployeeInput[] | ActivityLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutEmployeeInput | ActivityLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: ActivityLogCreateManyEmployeeInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type BranchUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<BranchCreateWithoutEmployeesInput, BranchUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: BranchCreateOrConnectWithoutEmployeesInput
    upsert?: BranchUpsertWithoutEmployeesInput
    disconnect?: BranchWhereInput | boolean
    delete?: BranchWhereInput | boolean
    connect?: BranchWhereUniqueInput
    update?: XOR<XOR<BranchUpdateToOneWithWhereWithoutEmployeesInput, BranchUpdateWithoutEmployeesInput>, BranchUncheckedUpdateWithoutEmployeesInput>
  }

  export type ComplianceUpdateManyWithoutInspectorNestedInput = {
    create?: XOR<ComplianceCreateWithoutInspectorInput, ComplianceUncheckedCreateWithoutInspectorInput> | ComplianceCreateWithoutInspectorInput[] | ComplianceUncheckedCreateWithoutInspectorInput[]
    connectOrCreate?: ComplianceCreateOrConnectWithoutInspectorInput | ComplianceCreateOrConnectWithoutInspectorInput[]
    upsert?: ComplianceUpsertWithWhereUniqueWithoutInspectorInput | ComplianceUpsertWithWhereUniqueWithoutInspectorInput[]
    createMany?: ComplianceCreateManyInspectorInputEnvelope
    set?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    disconnect?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    delete?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    connect?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    update?: ComplianceUpdateWithWhereUniqueWithoutInspectorInput | ComplianceUpdateWithWhereUniqueWithoutInspectorInput[]
    updateMany?: ComplianceUpdateManyWithWhereWithoutInspectorInput | ComplianceUpdateManyWithWhereWithoutInspectorInput[]
    deleteMany?: ComplianceScalarWhereInput | ComplianceScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutCollectorNestedInput = {
    create?: XOR<PaymentCreateWithoutCollectorInput, PaymentUncheckedCreateWithoutCollectorInput> | PaymentCreateWithoutCollectorInput[] | PaymentUncheckedCreateWithoutCollectorInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCollectorInput | PaymentCreateOrConnectWithoutCollectorInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCollectorInput | PaymentUpsertWithWhereUniqueWithoutCollectorInput[]
    createMany?: PaymentCreateManyCollectorInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCollectorInput | PaymentUpdateWithWhereUniqueWithoutCollectorInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCollectorInput | PaymentUpdateManyWithWhereWithoutCollectorInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ActivityLogCreateWithoutEmployeeInput, ActivityLogUncheckedCreateWithoutEmployeeInput> | ActivityLogCreateWithoutEmployeeInput[] | ActivityLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutEmployeeInput | ActivityLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutEmployeeInput | ActivityLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ActivityLogCreateManyEmployeeInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutEmployeeInput | ActivityLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutEmployeeInput | ActivityLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type ComplianceUncheckedUpdateManyWithoutInspectorNestedInput = {
    create?: XOR<ComplianceCreateWithoutInspectorInput, ComplianceUncheckedCreateWithoutInspectorInput> | ComplianceCreateWithoutInspectorInput[] | ComplianceUncheckedCreateWithoutInspectorInput[]
    connectOrCreate?: ComplianceCreateOrConnectWithoutInspectorInput | ComplianceCreateOrConnectWithoutInspectorInput[]
    upsert?: ComplianceUpsertWithWhereUniqueWithoutInspectorInput | ComplianceUpsertWithWhereUniqueWithoutInspectorInput[]
    createMany?: ComplianceCreateManyInspectorInputEnvelope
    set?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    disconnect?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    delete?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    connect?: ComplianceWhereUniqueInput | ComplianceWhereUniqueInput[]
    update?: ComplianceUpdateWithWhereUniqueWithoutInspectorInput | ComplianceUpdateWithWhereUniqueWithoutInspectorInput[]
    updateMany?: ComplianceUpdateManyWithWhereWithoutInspectorInput | ComplianceUpdateManyWithWhereWithoutInspectorInput[]
    deleteMany?: ComplianceScalarWhereInput | ComplianceScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutCollectorNestedInput = {
    create?: XOR<PaymentCreateWithoutCollectorInput, PaymentUncheckedCreateWithoutCollectorInput> | PaymentCreateWithoutCollectorInput[] | PaymentUncheckedCreateWithoutCollectorInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutCollectorInput | PaymentCreateOrConnectWithoutCollectorInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutCollectorInput | PaymentUpsertWithWhereUniqueWithoutCollectorInput[]
    createMany?: PaymentCreateManyCollectorInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutCollectorInput | PaymentUpdateWithWhereUniqueWithoutCollectorInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutCollectorInput | PaymentUpdateManyWithWhereWithoutCollectorInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ActivityLogCreateWithoutEmployeeInput, ActivityLogUncheckedCreateWithoutEmployeeInput> | ActivityLogCreateWithoutEmployeeInput[] | ActivityLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutEmployeeInput | ActivityLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutEmployeeInput | ActivityLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ActivityLogCreateManyEmployeeInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutEmployeeInput | ActivityLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutEmployeeInput | ActivityLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type StallholderCreateNestedOneWithoutApplicationsInput = {
    create?: XOR<StallholderCreateWithoutApplicationsInput, StallholderUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: StallholderCreateOrConnectWithoutApplicationsInput
    connect?: StallholderWhereUniqueInput
  }

  export type StallholderUpdateOneWithoutApplicationsNestedInput = {
    create?: XOR<StallholderCreateWithoutApplicationsInput, StallholderUncheckedCreateWithoutApplicationsInput>
    connectOrCreate?: StallholderCreateOrConnectWithoutApplicationsInput
    upsert?: StallholderUpsertWithoutApplicationsInput
    disconnect?: StallholderWhereInput | boolean
    delete?: StallholderWhereInput | boolean
    connect?: StallholderWhereUniqueInput
    update?: XOR<XOR<StallholderUpdateToOneWithWhereWithoutApplicationsInput, StallholderUpdateWithoutApplicationsInput>, StallholderUncheckedUpdateWithoutApplicationsInput>
  }

  export type StallCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<StallCreateWithoutPaymentsInput, StallUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StallCreateOrConnectWithoutPaymentsInput
    connect?: StallWhereUniqueInput
  }

  export type StallholderCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<StallholderCreateWithoutPaymentsInput, StallholderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StallholderCreateOrConnectWithoutPaymentsInput
    connect?: StallholderWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutCollectionsInput = {
    create?: XOR<EmployeeCreateWithoutCollectionsInput, EmployeeUncheckedCreateWithoutCollectionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutCollectionsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type StallUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<StallCreateWithoutPaymentsInput, StallUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StallCreateOrConnectWithoutPaymentsInput
    upsert?: StallUpsertWithoutPaymentsInput
    disconnect?: StallWhereInput | boolean
    delete?: StallWhereInput | boolean
    connect?: StallWhereUniqueInput
    update?: XOR<XOR<StallUpdateToOneWithWhereWithoutPaymentsInput, StallUpdateWithoutPaymentsInput>, StallUncheckedUpdateWithoutPaymentsInput>
  }

  export type StallholderUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<StallholderCreateWithoutPaymentsInput, StallholderUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StallholderCreateOrConnectWithoutPaymentsInput
    upsert?: StallholderUpsertWithoutPaymentsInput
    disconnect?: StallholderWhereInput | boolean
    delete?: StallholderWhereInput | boolean
    connect?: StallholderWhereUniqueInput
    update?: XOR<XOR<StallholderUpdateToOneWithWhereWithoutPaymentsInput, StallholderUpdateWithoutPaymentsInput>, StallholderUncheckedUpdateWithoutPaymentsInput>
  }

  export type EmployeeUpdateOneWithoutCollectionsNestedInput = {
    create?: XOR<EmployeeCreateWithoutCollectionsInput, EmployeeUncheckedCreateWithoutCollectionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutCollectionsInput
    upsert?: EmployeeUpsertWithoutCollectionsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutCollectionsInput, EmployeeUpdateWithoutCollectionsInput>, EmployeeUncheckedUpdateWithoutCollectionsInput>
  }

  export type StallCreateNestedOneWithoutCompliancesInput = {
    create?: XOR<StallCreateWithoutCompliancesInput, StallUncheckedCreateWithoutCompliancesInput>
    connectOrCreate?: StallCreateOrConnectWithoutCompliancesInput
    connect?: StallWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutInspectionsInput = {
    create?: XOR<EmployeeCreateWithoutInspectionsInput, EmployeeUncheckedCreateWithoutInspectionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutInspectionsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type StallUpdateOneRequiredWithoutCompliancesNestedInput = {
    create?: XOR<StallCreateWithoutCompliancesInput, StallUncheckedCreateWithoutCompliancesInput>
    connectOrCreate?: StallCreateOrConnectWithoutCompliancesInput
    upsert?: StallUpsertWithoutCompliancesInput
    connect?: StallWhereUniqueInput
    update?: XOR<XOR<StallUpdateToOneWithWhereWithoutCompliancesInput, StallUpdateWithoutCompliancesInput>, StallUncheckedUpdateWithoutCompliancesInput>
  }

  export type EmployeeUpdateOneWithoutInspectionsNestedInput = {
    create?: XOR<EmployeeCreateWithoutInspectionsInput, EmployeeUncheckedCreateWithoutInspectionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutInspectionsInput
    upsert?: EmployeeUpsertWithoutInspectionsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutInspectionsInput, EmployeeUpdateWithoutInspectionsInput>, EmployeeUncheckedUpdateWithoutInspectionsInput>
  }

  export type StallCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<StallCreateWithoutComplaintsInput, StallUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: StallCreateOrConnectWithoutComplaintsInput
    connect?: StallWhereUniqueInput
  }

  export type StallUpdateOneWithoutComplaintsNestedInput = {
    create?: XOR<StallCreateWithoutComplaintsInput, StallUncheckedCreateWithoutComplaintsInput>
    connectOrCreate?: StallCreateOrConnectWithoutComplaintsInput
    upsert?: StallUpsertWithoutComplaintsInput
    disconnect?: StallWhereInput | boolean
    delete?: StallWhereInput | boolean
    connect?: StallWhereUniqueInput
    update?: XOR<XOR<StallUpdateToOneWithWhereWithoutComplaintsInput, StallUpdateWithoutComplaintsInput>, StallUncheckedUpdateWithoutComplaintsInput>
  }

  export type StallCreateNestedOneWithoutVendorsInput = {
    create?: XOR<StallCreateWithoutVendorsInput, StallUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: StallCreateOrConnectWithoutVendorsInput
    connect?: StallWhereUniqueInput
  }

  export type StallUpdateOneWithoutVendorsNestedInput = {
    create?: XOR<StallCreateWithoutVendorsInput, StallUncheckedCreateWithoutVendorsInput>
    connectOrCreate?: StallCreateOrConnectWithoutVendorsInput
    upsert?: StallUpsertWithoutVendorsInput
    disconnect?: StallWhereInput | boolean
    delete?: StallWhereInput | boolean
    connect?: StallWhereUniqueInput
    update?: XOR<XOR<StallUpdateToOneWithWhereWithoutVendorsInput, StallUpdateWithoutVendorsInput>, StallUncheckedUpdateWithoutVendorsInput>
  }

  export type EmployeeCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<EmployeeCreateWithoutActivityLogsInput, EmployeeUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutActivityLogsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneWithoutActivityLogsNestedInput = {
    create?: XOR<EmployeeCreateWithoutActivityLogsInput, EmployeeUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutActivityLogsInput
    upsert?: EmployeeUpsertWithoutActivityLogsInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutActivityLogsInput, EmployeeUpdateWithoutActivityLogsInput>, EmployeeUncheckedUpdateWithoutActivityLogsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | null
    notIn?: Bytes[] | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Bytes | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel> | null
    in?: Bytes[] | null
    notIn?: Bytes[] | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Bytes | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StallCreateWithoutBranchInput = {
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    floor?: FloorCreateNestedOneWithoutStallsInput
    sectionRef?: SectionCreateNestedOneWithoutStallsInput
    stallholder?: StallholderCreateNestedOneWithoutStallsInput
    images?: StallImageCreateNestedManyWithoutStallInput
    payments?: PaymentCreateNestedManyWithoutStallInput
    compliances?: ComplianceCreateNestedManyWithoutStallInput
    complaints?: ComplaintCreateNestedManyWithoutStallInput
    vendors?: VendorCreateNestedManyWithoutStallInput
  }

  export type StallUncheckedCreateWithoutBranchInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    images?: StallImageUncheckedCreateNestedManyWithoutStallInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStallInput
    compliances?: ComplianceUncheckedCreateNestedManyWithoutStallInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutStallInput
    vendors?: VendorUncheckedCreateNestedManyWithoutStallInput
  }

  export type StallCreateOrConnectWithoutBranchInput = {
    where: StallWhereUniqueInput
    create: XOR<StallCreateWithoutBranchInput, StallUncheckedCreateWithoutBranchInput>
  }

  export type StallCreateManyBranchInputEnvelope = {
    data: StallCreateManyBranchInput | StallCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutBranchInput = {
    first_name: string
    last_name: string
    email: string
    phone_number?: string | null
    position?: string | null
    role?: string
    password: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    inspections?: ComplianceCreateNestedManyWithoutInspectorInput
    collections?: PaymentCreateNestedManyWithoutCollectorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutBranchInput = {
    employee_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number?: string | null
    position?: string | null
    role?: string
    password: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    inspections?: ComplianceUncheckedCreateNestedManyWithoutInspectorInput
    collections?: PaymentUncheckedCreateNestedManyWithoutCollectorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutBranchInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutBranchInput, EmployeeUncheckedCreateWithoutBranchInput>
  }

  export type EmployeeCreateManyBranchInputEnvelope = {
    data: EmployeeCreateManyBranchInput | EmployeeCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type FloorCreateWithoutBranchInput = {
    floor_name: string
    floor_number: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallCreateNestedManyWithoutFloorInput
    sections?: SectionCreateNestedManyWithoutFloorInput
  }

  export type FloorUncheckedCreateWithoutBranchInput = {
    floor_id?: number
    floor_name: string
    floor_number: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutFloorInput
    sections?: SectionUncheckedCreateNestedManyWithoutFloorInput
  }

  export type FloorCreateOrConnectWithoutBranchInput = {
    where: FloorWhereUniqueInput
    create: XOR<FloorCreateWithoutBranchInput, FloorUncheckedCreateWithoutBranchInput>
  }

  export type FloorCreateManyBranchInputEnvelope = {
    data: FloorCreateManyBranchInput | FloorCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type SectionCreateWithoutBranchInput = {
    section_name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    floor?: FloorCreateNestedOneWithoutSectionsInput
    stalls?: StallCreateNestedManyWithoutSectionRefInput
  }

  export type SectionUncheckedCreateWithoutBranchInput = {
    section_id?: number
    floor_id?: number | null
    section_name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutSectionRefInput
  }

  export type SectionCreateOrConnectWithoutBranchInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutBranchInput, SectionUncheckedCreateWithoutBranchInput>
  }

  export type SectionCreateManyBranchInputEnvelope = {
    data: SectionCreateManyBranchInput | SectionCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type StallholderCreateWithoutBranchInput = {
    first_name: string
    last_name: string
    email?: string | null
    phone_number?: string | null
    address?: string | null
    business_name?: string | null
    business_type?: string | null
    status?: string
    password?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallCreateNestedManyWithoutStallholderInput
    payments?: PaymentCreateNestedManyWithoutStallholderInput
    applications?: ApplicationCreateNestedManyWithoutStallholderInput
  }

  export type StallholderUncheckedCreateWithoutBranchInput = {
    stallholder_id?: number
    first_name: string
    last_name: string
    email?: string | null
    phone_number?: string | null
    address?: string | null
    business_name?: string | null
    business_type?: string | null
    status?: string
    password?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutStallholderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStallholderInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutStallholderInput
  }

  export type StallholderCreateOrConnectWithoutBranchInput = {
    where: StallholderWhereUniqueInput
    create: XOR<StallholderCreateWithoutBranchInput, StallholderUncheckedCreateWithoutBranchInput>
  }

  export type StallholderCreateManyBranchInputEnvelope = {
    data: StallholderCreateManyBranchInput | StallholderCreateManyBranchInput[]
    skipDuplicates?: boolean
  }

  export type StallUpsertWithWhereUniqueWithoutBranchInput = {
    where: StallWhereUniqueInput
    update: XOR<StallUpdateWithoutBranchInput, StallUncheckedUpdateWithoutBranchInput>
    create: XOR<StallCreateWithoutBranchInput, StallUncheckedCreateWithoutBranchInput>
  }

  export type StallUpdateWithWhereUniqueWithoutBranchInput = {
    where: StallWhereUniqueInput
    data: XOR<StallUpdateWithoutBranchInput, StallUncheckedUpdateWithoutBranchInput>
  }

  export type StallUpdateManyWithWhereWithoutBranchInput = {
    where: StallScalarWhereInput
    data: XOR<StallUpdateManyMutationInput, StallUncheckedUpdateManyWithoutBranchInput>
  }

  export type StallScalarWhereInput = {
    AND?: StallScalarWhereInput | StallScalarWhereInput[]
    OR?: StallScalarWhereInput[]
    NOT?: StallScalarWhereInput | StallScalarWhereInput[]
    stall_id?: IntFilter<"Stall"> | number
    stall_number?: StringNullableFilter<"Stall"> | string | null
    stall_name?: StringNullableFilter<"Stall"> | string | null
    stall_type?: StringNullableFilter<"Stall"> | string | null
    stall_size?: StringNullableFilter<"Stall"> | string | null
    stall_location?: StringNullableFilter<"Stall"> | string | null
    size?: StringNullableFilter<"Stall"> | string | null
    area_sqm?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    floor_id?: IntNullableFilter<"Stall"> | number | null
    section_id?: IntNullableFilter<"Stall"> | number | null
    monthly_rent?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    rental_price?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    status?: StringFilter<"Stall"> | string
    branch_id?: IntFilter<"Stall"> | number
    stallholder_id?: IntNullableFilter<"Stall"> | number | null
    floor_level?: StringNullableFilter<"Stall"> | string | null
    section?: StringNullableFilter<"Stall"> | string | null
    description?: StringNullableFilter<"Stall"> | string | null
    price_type?: StringNullableFilter<"Stall"> | string | null
    is_available?: BoolFilter<"Stall"> | boolean
    base_rate?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: DecimalNullableFilter<"Stall"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"Stall"> | Date | string
    updated_at?: DateTimeFilter<"Stall"> | Date | string
  }

  export type EmployeeUpsertWithWhereUniqueWithoutBranchInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutBranchInput, EmployeeUncheckedUpdateWithoutBranchInput>
    create: XOR<EmployeeCreateWithoutBranchInput, EmployeeUncheckedCreateWithoutBranchInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutBranchInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutBranchInput, EmployeeUncheckedUpdateWithoutBranchInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutBranchInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutBranchInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    employee_id?: IntFilter<"Employee"> | number
    first_name?: StringFilter<"Employee"> | string
    last_name?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    phone_number?: StringNullableFilter<"Employee"> | string | null
    position?: StringNullableFilter<"Employee"> | string | null
    role?: StringFilter<"Employee"> | string
    branch_id?: IntNullableFilter<"Employee"> | number | null
    password?: StringFilter<"Employee"> | string
    status?: StringFilter<"Employee"> | string
    created_at?: DateTimeFilter<"Employee"> | Date | string
    updated_at?: DateTimeFilter<"Employee"> | Date | string
  }

  export type FloorUpsertWithWhereUniqueWithoutBranchInput = {
    where: FloorWhereUniqueInput
    update: XOR<FloorUpdateWithoutBranchInput, FloorUncheckedUpdateWithoutBranchInput>
    create: XOR<FloorCreateWithoutBranchInput, FloorUncheckedCreateWithoutBranchInput>
  }

  export type FloorUpdateWithWhereUniqueWithoutBranchInput = {
    where: FloorWhereUniqueInput
    data: XOR<FloorUpdateWithoutBranchInput, FloorUncheckedUpdateWithoutBranchInput>
  }

  export type FloorUpdateManyWithWhereWithoutBranchInput = {
    where: FloorScalarWhereInput
    data: XOR<FloorUpdateManyMutationInput, FloorUncheckedUpdateManyWithoutBranchInput>
  }

  export type FloorScalarWhereInput = {
    AND?: FloorScalarWhereInput | FloorScalarWhereInput[]
    OR?: FloorScalarWhereInput[]
    NOT?: FloorScalarWhereInput | FloorScalarWhereInput[]
    floor_id?: IntFilter<"Floor"> | number
    branch_id?: IntFilter<"Floor"> | number
    floor_name?: StringFilter<"Floor"> | string
    floor_number?: IntFilter<"Floor"> | number
    description?: StringNullableFilter<"Floor"> | string | null
    created_at?: DateTimeFilter<"Floor"> | Date | string
    updated_at?: DateTimeFilter<"Floor"> | Date | string
  }

  export type SectionUpsertWithWhereUniqueWithoutBranchInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutBranchInput, SectionUncheckedUpdateWithoutBranchInput>
    create: XOR<SectionCreateWithoutBranchInput, SectionUncheckedCreateWithoutBranchInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutBranchInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutBranchInput, SectionUncheckedUpdateWithoutBranchInput>
  }

  export type SectionUpdateManyWithWhereWithoutBranchInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutBranchInput>
  }

  export type SectionScalarWhereInput = {
    AND?: SectionScalarWhereInput | SectionScalarWhereInput[]
    OR?: SectionScalarWhereInput[]
    NOT?: SectionScalarWhereInput | SectionScalarWhereInput[]
    section_id?: IntFilter<"Section"> | number
    branch_id?: IntFilter<"Section"> | number
    floor_id?: IntNullableFilter<"Section"> | number | null
    section_name?: StringFilter<"Section"> | string
    description?: StringNullableFilter<"Section"> | string | null
    created_at?: DateTimeFilter<"Section"> | Date | string
    updated_at?: DateTimeFilter<"Section"> | Date | string
  }

  export type StallholderUpsertWithWhereUniqueWithoutBranchInput = {
    where: StallholderWhereUniqueInput
    update: XOR<StallholderUpdateWithoutBranchInput, StallholderUncheckedUpdateWithoutBranchInput>
    create: XOR<StallholderCreateWithoutBranchInput, StallholderUncheckedCreateWithoutBranchInput>
  }

  export type StallholderUpdateWithWhereUniqueWithoutBranchInput = {
    where: StallholderWhereUniqueInput
    data: XOR<StallholderUpdateWithoutBranchInput, StallholderUncheckedUpdateWithoutBranchInput>
  }

  export type StallholderUpdateManyWithWhereWithoutBranchInput = {
    where: StallholderScalarWhereInput
    data: XOR<StallholderUpdateManyMutationInput, StallholderUncheckedUpdateManyWithoutBranchInput>
  }

  export type StallholderScalarWhereInput = {
    AND?: StallholderScalarWhereInput | StallholderScalarWhereInput[]
    OR?: StallholderScalarWhereInput[]
    NOT?: StallholderScalarWhereInput | StallholderScalarWhereInput[]
    stallholder_id?: IntFilter<"Stallholder"> | number
    first_name?: StringFilter<"Stallholder"> | string
    last_name?: StringFilter<"Stallholder"> | string
    email?: StringNullableFilter<"Stallholder"> | string | null
    phone_number?: StringNullableFilter<"Stallholder"> | string | null
    address?: StringNullableFilter<"Stallholder"> | string | null
    business_name?: StringNullableFilter<"Stallholder"> | string | null
    business_type?: StringNullableFilter<"Stallholder"> | string | null
    branch_id?: IntNullableFilter<"Stallholder"> | number | null
    status?: StringFilter<"Stallholder"> | string
    password?: StringNullableFilter<"Stallholder"> | string | null
    created_at?: DateTimeFilter<"Stallholder"> | Date | string
    updated_at?: DateTimeFilter<"Stallholder"> | Date | string
  }

  export type BranchCreateWithoutFloorsInput = {
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallCreateNestedManyWithoutBranchInput
    employees?: EmployeeCreateNestedManyWithoutBranchInput
    sections?: SectionCreateNestedManyWithoutBranchInput
    stallholders?: StallholderCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutFloorsInput = {
    branch_id?: number
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutBranchInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutBranchInput
    sections?: SectionUncheckedCreateNestedManyWithoutBranchInput
    stallholders?: StallholderUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutFloorsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutFloorsInput, BranchUncheckedCreateWithoutFloorsInput>
  }

  export type StallCreateWithoutFloorInput = {
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutStallsInput
    sectionRef?: SectionCreateNestedOneWithoutStallsInput
    stallholder?: StallholderCreateNestedOneWithoutStallsInput
    images?: StallImageCreateNestedManyWithoutStallInput
    payments?: PaymentCreateNestedManyWithoutStallInput
    compliances?: ComplianceCreateNestedManyWithoutStallInput
    complaints?: ComplaintCreateNestedManyWithoutStallInput
    vendors?: VendorCreateNestedManyWithoutStallInput
  }

  export type StallUncheckedCreateWithoutFloorInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    images?: StallImageUncheckedCreateNestedManyWithoutStallInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStallInput
    compliances?: ComplianceUncheckedCreateNestedManyWithoutStallInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutStallInput
    vendors?: VendorUncheckedCreateNestedManyWithoutStallInput
  }

  export type StallCreateOrConnectWithoutFloorInput = {
    where: StallWhereUniqueInput
    create: XOR<StallCreateWithoutFloorInput, StallUncheckedCreateWithoutFloorInput>
  }

  export type StallCreateManyFloorInputEnvelope = {
    data: StallCreateManyFloorInput | StallCreateManyFloorInput[]
    skipDuplicates?: boolean
  }

  export type SectionCreateWithoutFloorInput = {
    section_name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutSectionsInput
    stalls?: StallCreateNestedManyWithoutSectionRefInput
  }

  export type SectionUncheckedCreateWithoutFloorInput = {
    section_id?: number
    branch_id: number
    section_name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutSectionRefInput
  }

  export type SectionCreateOrConnectWithoutFloorInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutFloorInput, SectionUncheckedCreateWithoutFloorInput>
  }

  export type SectionCreateManyFloorInputEnvelope = {
    data: SectionCreateManyFloorInput | SectionCreateManyFloorInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutFloorsInput = {
    update: XOR<BranchUpdateWithoutFloorsInput, BranchUncheckedUpdateWithoutFloorsInput>
    create: XOR<BranchCreateWithoutFloorsInput, BranchUncheckedCreateWithoutFloorsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutFloorsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutFloorsInput, BranchUncheckedUpdateWithoutFloorsInput>
  }

  export type BranchUpdateWithoutFloorsInput = {
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUpdateManyWithoutBranchNestedInput
    employees?: EmployeeUpdateManyWithoutBranchNestedInput
    sections?: SectionUpdateManyWithoutBranchNestedInput
    stallholders?: StallholderUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutFloorsInput = {
    branch_id?: IntFieldUpdateOperationsInput | number
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutBranchNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutBranchNestedInput
    sections?: SectionUncheckedUpdateManyWithoutBranchNestedInput
    stallholders?: StallholderUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type StallUpsertWithWhereUniqueWithoutFloorInput = {
    where: StallWhereUniqueInput
    update: XOR<StallUpdateWithoutFloorInput, StallUncheckedUpdateWithoutFloorInput>
    create: XOR<StallCreateWithoutFloorInput, StallUncheckedCreateWithoutFloorInput>
  }

  export type StallUpdateWithWhereUniqueWithoutFloorInput = {
    where: StallWhereUniqueInput
    data: XOR<StallUpdateWithoutFloorInput, StallUncheckedUpdateWithoutFloorInput>
  }

  export type StallUpdateManyWithWhereWithoutFloorInput = {
    where: StallScalarWhereInput
    data: XOR<StallUpdateManyMutationInput, StallUncheckedUpdateManyWithoutFloorInput>
  }

  export type SectionUpsertWithWhereUniqueWithoutFloorInput = {
    where: SectionWhereUniqueInput
    update: XOR<SectionUpdateWithoutFloorInput, SectionUncheckedUpdateWithoutFloorInput>
    create: XOR<SectionCreateWithoutFloorInput, SectionUncheckedCreateWithoutFloorInput>
  }

  export type SectionUpdateWithWhereUniqueWithoutFloorInput = {
    where: SectionWhereUniqueInput
    data: XOR<SectionUpdateWithoutFloorInput, SectionUncheckedUpdateWithoutFloorInput>
  }

  export type SectionUpdateManyWithWhereWithoutFloorInput = {
    where: SectionScalarWhereInput
    data: XOR<SectionUpdateManyMutationInput, SectionUncheckedUpdateManyWithoutFloorInput>
  }

  export type BranchCreateWithoutSectionsInput = {
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallCreateNestedManyWithoutBranchInput
    employees?: EmployeeCreateNestedManyWithoutBranchInput
    floors?: FloorCreateNestedManyWithoutBranchInput
    stallholders?: StallholderCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutSectionsInput = {
    branch_id?: number
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutBranchInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutBranchInput
    floors?: FloorUncheckedCreateNestedManyWithoutBranchInput
    stallholders?: StallholderUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutSectionsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutSectionsInput, BranchUncheckedCreateWithoutSectionsInput>
  }

  export type FloorCreateWithoutSectionsInput = {
    floor_name: string
    floor_number: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutFloorsInput
    stalls?: StallCreateNestedManyWithoutFloorInput
  }

  export type FloorUncheckedCreateWithoutSectionsInput = {
    floor_id?: number
    branch_id: number
    floor_name: string
    floor_number: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutFloorInput
  }

  export type FloorCreateOrConnectWithoutSectionsInput = {
    where: FloorWhereUniqueInput
    create: XOR<FloorCreateWithoutSectionsInput, FloorUncheckedCreateWithoutSectionsInput>
  }

  export type StallCreateWithoutSectionRefInput = {
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutStallsInput
    floor?: FloorCreateNestedOneWithoutStallsInput
    stallholder?: StallholderCreateNestedOneWithoutStallsInput
    images?: StallImageCreateNestedManyWithoutStallInput
    payments?: PaymentCreateNestedManyWithoutStallInput
    compliances?: ComplianceCreateNestedManyWithoutStallInput
    complaints?: ComplaintCreateNestedManyWithoutStallInput
    vendors?: VendorCreateNestedManyWithoutStallInput
  }

  export type StallUncheckedCreateWithoutSectionRefInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    images?: StallImageUncheckedCreateNestedManyWithoutStallInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStallInput
    compliances?: ComplianceUncheckedCreateNestedManyWithoutStallInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutStallInput
    vendors?: VendorUncheckedCreateNestedManyWithoutStallInput
  }

  export type StallCreateOrConnectWithoutSectionRefInput = {
    where: StallWhereUniqueInput
    create: XOR<StallCreateWithoutSectionRefInput, StallUncheckedCreateWithoutSectionRefInput>
  }

  export type StallCreateManySectionRefInputEnvelope = {
    data: StallCreateManySectionRefInput | StallCreateManySectionRefInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutSectionsInput = {
    update: XOR<BranchUpdateWithoutSectionsInput, BranchUncheckedUpdateWithoutSectionsInput>
    create: XOR<BranchCreateWithoutSectionsInput, BranchUncheckedCreateWithoutSectionsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutSectionsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutSectionsInput, BranchUncheckedUpdateWithoutSectionsInput>
  }

  export type BranchUpdateWithoutSectionsInput = {
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUpdateManyWithoutBranchNestedInput
    employees?: EmployeeUpdateManyWithoutBranchNestedInput
    floors?: FloorUpdateManyWithoutBranchNestedInput
    stallholders?: StallholderUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutSectionsInput = {
    branch_id?: IntFieldUpdateOperationsInput | number
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutBranchNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutBranchNestedInput
    floors?: FloorUncheckedUpdateManyWithoutBranchNestedInput
    stallholders?: StallholderUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type FloorUpsertWithoutSectionsInput = {
    update: XOR<FloorUpdateWithoutSectionsInput, FloorUncheckedUpdateWithoutSectionsInput>
    create: XOR<FloorCreateWithoutSectionsInput, FloorUncheckedCreateWithoutSectionsInput>
    where?: FloorWhereInput
  }

  export type FloorUpdateToOneWithWhereWithoutSectionsInput = {
    where?: FloorWhereInput
    data: XOR<FloorUpdateWithoutSectionsInput, FloorUncheckedUpdateWithoutSectionsInput>
  }

  export type FloorUpdateWithoutSectionsInput = {
    floor_name?: StringFieldUpdateOperationsInput | string
    floor_number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutFloorsNestedInput
    stalls?: StallUpdateManyWithoutFloorNestedInput
  }

  export type FloorUncheckedUpdateWithoutSectionsInput = {
    floor_id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    floor_name?: StringFieldUpdateOperationsInput | string
    floor_number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutFloorNestedInput
  }

  export type StallUpsertWithWhereUniqueWithoutSectionRefInput = {
    where: StallWhereUniqueInput
    update: XOR<StallUpdateWithoutSectionRefInput, StallUncheckedUpdateWithoutSectionRefInput>
    create: XOR<StallCreateWithoutSectionRefInput, StallUncheckedCreateWithoutSectionRefInput>
  }

  export type StallUpdateWithWhereUniqueWithoutSectionRefInput = {
    where: StallWhereUniqueInput
    data: XOR<StallUpdateWithoutSectionRefInput, StallUncheckedUpdateWithoutSectionRefInput>
  }

  export type StallUpdateManyWithWhereWithoutSectionRefInput = {
    where: StallScalarWhereInput
    data: XOR<StallUpdateManyMutationInput, StallUncheckedUpdateManyWithoutSectionRefInput>
  }

  export type BranchCreateWithoutStallsInput = {
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    employees?: EmployeeCreateNestedManyWithoutBranchInput
    floors?: FloorCreateNestedManyWithoutBranchInput
    sections?: SectionCreateNestedManyWithoutBranchInput
    stallholders?: StallholderCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutStallsInput = {
    branch_id?: number
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutBranchInput
    floors?: FloorUncheckedCreateNestedManyWithoutBranchInput
    sections?: SectionUncheckedCreateNestedManyWithoutBranchInput
    stallholders?: StallholderUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutStallsInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutStallsInput, BranchUncheckedCreateWithoutStallsInput>
  }

  export type FloorCreateWithoutStallsInput = {
    floor_name: string
    floor_number: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutFloorsInput
    sections?: SectionCreateNestedManyWithoutFloorInput
  }

  export type FloorUncheckedCreateWithoutStallsInput = {
    floor_id?: number
    branch_id: number
    floor_name: string
    floor_number: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    sections?: SectionUncheckedCreateNestedManyWithoutFloorInput
  }

  export type FloorCreateOrConnectWithoutStallsInput = {
    where: FloorWhereUniqueInput
    create: XOR<FloorCreateWithoutStallsInput, FloorUncheckedCreateWithoutStallsInput>
  }

  export type SectionCreateWithoutStallsInput = {
    section_name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutSectionsInput
    floor?: FloorCreateNestedOneWithoutSectionsInput
  }

  export type SectionUncheckedCreateWithoutStallsInput = {
    section_id?: number
    branch_id: number
    floor_id?: number | null
    section_name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SectionCreateOrConnectWithoutStallsInput = {
    where: SectionWhereUniqueInput
    create: XOR<SectionCreateWithoutStallsInput, SectionUncheckedCreateWithoutStallsInput>
  }

  export type StallholderCreateWithoutStallsInput = {
    first_name: string
    last_name: string
    email?: string | null
    phone_number?: string | null
    address?: string | null
    business_name?: string | null
    business_type?: string | null
    status?: string
    password?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch?: BranchCreateNestedOneWithoutStallholdersInput
    payments?: PaymentCreateNestedManyWithoutStallholderInput
    applications?: ApplicationCreateNestedManyWithoutStallholderInput
  }

  export type StallholderUncheckedCreateWithoutStallsInput = {
    stallholder_id?: number
    first_name: string
    last_name: string
    email?: string | null
    phone_number?: string | null
    address?: string | null
    business_name?: string | null
    business_type?: string | null
    branch_id?: number | null
    status?: string
    password?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutStallholderInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutStallholderInput
  }

  export type StallholderCreateOrConnectWithoutStallsInput = {
    where: StallholderWhereUniqueInput
    create: XOR<StallholderCreateWithoutStallsInput, StallholderUncheckedCreateWithoutStallsInput>
  }

  export type StallImageCreateWithoutStallInput = {
    filename?: string | null
    image_data?: Bytes | null
    mime_type?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StallImageUncheckedCreateWithoutStallInput = {
    image_id?: number
    filename?: string | null
    image_data?: Bytes | null
    mime_type?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StallImageCreateOrConnectWithoutStallInput = {
    where: StallImageWhereUniqueInput
    create: XOR<StallImageCreateWithoutStallInput, StallImageUncheckedCreateWithoutStallInput>
  }

  export type StallImageCreateManyStallInputEnvelope = {
    data: StallImageCreateManyStallInput | StallImageCreateManyStallInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutStallInput = {
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_type?: string | null
    payment_method?: string | null
    status?: string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stallholder?: StallholderCreateNestedOneWithoutPaymentsInput
    collector?: EmployeeCreateNestedOneWithoutCollectionsInput
  }

  export type PaymentUncheckedCreateWithoutStallInput = {
    payment_id?: number
    stallholder_id?: number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_type?: string | null
    payment_method?: string | null
    status?: string
    reference_no?: string | null
    collector_id?: number | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCreateOrConnectWithoutStallInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutStallInput, PaymentUncheckedCreateWithoutStallInput>
  }

  export type PaymentCreateManyStallInputEnvelope = {
    data: PaymentCreateManyStallInput | PaymentCreateManyStallInput[]
    skipDuplicates?: boolean
  }

  export type ComplianceCreateWithoutStallInput = {
    compliance_type?: string | null
    status?: string
    inspection_date?: Date | string | null
    remarks?: string | null
    evidence?: Bytes | null
    evidence_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    inspector?: EmployeeCreateNestedOneWithoutInspectionsInput
  }

  export type ComplianceUncheckedCreateWithoutStallInput = {
    compliance_id?: number
    inspector_id?: number | null
    compliance_type?: string | null
    status?: string
    inspection_date?: Date | string | null
    remarks?: string | null
    evidence?: Bytes | null
    evidence_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplianceCreateOrConnectWithoutStallInput = {
    where: ComplianceWhereUniqueInput
    create: XOR<ComplianceCreateWithoutStallInput, ComplianceUncheckedCreateWithoutStallInput>
  }

  export type ComplianceCreateManyStallInputEnvelope = {
    data: ComplianceCreateManyStallInput | ComplianceCreateManyStallInput[]
    skipDuplicates?: boolean
  }

  export type ComplaintCreateWithoutStallInput = {
    complainant?: string | null
    complaint_type?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintUncheckedCreateWithoutStallInput = {
    complaint_id?: number
    complainant?: string | null
    complaint_type?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintCreateOrConnectWithoutStallInput = {
    where: ComplaintWhereUniqueInput
    create: XOR<ComplaintCreateWithoutStallInput, ComplaintUncheckedCreateWithoutStallInput>
  }

  export type ComplaintCreateManyStallInputEnvelope = {
    data: ComplaintCreateManyStallInput | ComplaintCreateManyStallInput[]
    skipDuplicates?: boolean
  }

  export type VendorCreateWithoutStallInput = {
    vendor_name: string
    contact_number?: string | null
    email?: string | null
    product_type?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorUncheckedCreateWithoutStallInput = {
    vendor_id?: number
    vendor_name: string
    contact_number?: string | null
    email?: string | null
    product_type?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorCreateOrConnectWithoutStallInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutStallInput, VendorUncheckedCreateWithoutStallInput>
  }

  export type VendorCreateManyStallInputEnvelope = {
    data: VendorCreateManyStallInput | VendorCreateManyStallInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutStallsInput = {
    update: XOR<BranchUpdateWithoutStallsInput, BranchUncheckedUpdateWithoutStallsInput>
    create: XOR<BranchCreateWithoutStallsInput, BranchUncheckedCreateWithoutStallsInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutStallsInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutStallsInput, BranchUncheckedUpdateWithoutStallsInput>
  }

  export type BranchUpdateWithoutStallsInput = {
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutBranchNestedInput
    floors?: FloorUpdateManyWithoutBranchNestedInput
    sections?: SectionUpdateManyWithoutBranchNestedInput
    stallholders?: StallholderUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutStallsInput = {
    branch_id?: IntFieldUpdateOperationsInput | number
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutBranchNestedInput
    floors?: FloorUncheckedUpdateManyWithoutBranchNestedInput
    sections?: SectionUncheckedUpdateManyWithoutBranchNestedInput
    stallholders?: StallholderUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type FloorUpsertWithoutStallsInput = {
    update: XOR<FloorUpdateWithoutStallsInput, FloorUncheckedUpdateWithoutStallsInput>
    create: XOR<FloorCreateWithoutStallsInput, FloorUncheckedCreateWithoutStallsInput>
    where?: FloorWhereInput
  }

  export type FloorUpdateToOneWithWhereWithoutStallsInput = {
    where?: FloorWhereInput
    data: XOR<FloorUpdateWithoutStallsInput, FloorUncheckedUpdateWithoutStallsInput>
  }

  export type FloorUpdateWithoutStallsInput = {
    floor_name?: StringFieldUpdateOperationsInput | string
    floor_number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutFloorsNestedInput
    sections?: SectionUpdateManyWithoutFloorNestedInput
  }

  export type FloorUncheckedUpdateWithoutStallsInput = {
    floor_id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    floor_name?: StringFieldUpdateOperationsInput | string
    floor_number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sections?: SectionUncheckedUpdateManyWithoutFloorNestedInput
  }

  export type SectionUpsertWithoutStallsInput = {
    update: XOR<SectionUpdateWithoutStallsInput, SectionUncheckedUpdateWithoutStallsInput>
    create: XOR<SectionCreateWithoutStallsInput, SectionUncheckedCreateWithoutStallsInput>
    where?: SectionWhereInput
  }

  export type SectionUpdateToOneWithWhereWithoutStallsInput = {
    where?: SectionWhereInput
    data: XOR<SectionUpdateWithoutStallsInput, SectionUncheckedUpdateWithoutStallsInput>
  }

  export type SectionUpdateWithoutStallsInput = {
    section_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSectionsNestedInput
    floor?: FloorUpdateOneWithoutSectionsNestedInput
  }

  export type SectionUncheckedUpdateWithoutStallsInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallholderUpsertWithoutStallsInput = {
    update: XOR<StallholderUpdateWithoutStallsInput, StallholderUncheckedUpdateWithoutStallsInput>
    create: XOR<StallholderCreateWithoutStallsInput, StallholderUncheckedCreateWithoutStallsInput>
    where?: StallholderWhereInput
  }

  export type StallholderUpdateToOneWithWhereWithoutStallsInput = {
    where?: StallholderWhereInput
    data: XOR<StallholderUpdateWithoutStallsInput, StallholderUncheckedUpdateWithoutStallsInput>
  }

  export type StallholderUpdateWithoutStallsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutStallholdersNestedInput
    payments?: PaymentUpdateManyWithoutStallholderNestedInput
    applications?: ApplicationUpdateManyWithoutStallholderNestedInput
  }

  export type StallholderUncheckedUpdateWithoutStallsInput = {
    stallholder_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutStallholderNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutStallholderNestedInput
  }

  export type StallImageUpsertWithWhereUniqueWithoutStallInput = {
    where: StallImageWhereUniqueInput
    update: XOR<StallImageUpdateWithoutStallInput, StallImageUncheckedUpdateWithoutStallInput>
    create: XOR<StallImageCreateWithoutStallInput, StallImageUncheckedCreateWithoutStallInput>
  }

  export type StallImageUpdateWithWhereUniqueWithoutStallInput = {
    where: StallImageWhereUniqueInput
    data: XOR<StallImageUpdateWithoutStallInput, StallImageUncheckedUpdateWithoutStallInput>
  }

  export type StallImageUpdateManyWithWhereWithoutStallInput = {
    where: StallImageScalarWhereInput
    data: XOR<StallImageUpdateManyMutationInput, StallImageUncheckedUpdateManyWithoutStallInput>
  }

  export type StallImageScalarWhereInput = {
    AND?: StallImageScalarWhereInput | StallImageScalarWhereInput[]
    OR?: StallImageScalarWhereInput[]
    NOT?: StallImageScalarWhereInput | StallImageScalarWhereInput[]
    image_id?: IntFilter<"StallImage"> | number
    stall_id?: IntFilter<"StallImage"> | number
    filename?: StringNullableFilter<"StallImage"> | string | null
    image_data?: BytesNullableFilter<"StallImage"> | Bytes | null
    mime_type?: StringNullableFilter<"StallImage"> | string | null
    is_primary?: BoolFilter<"StallImage"> | boolean
    created_at?: DateTimeFilter<"StallImage"> | Date | string
    updated_at?: DateTimeFilter<"StallImage"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutStallInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutStallInput, PaymentUncheckedUpdateWithoutStallInput>
    create: XOR<PaymentCreateWithoutStallInput, PaymentUncheckedCreateWithoutStallInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutStallInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutStallInput, PaymentUncheckedUpdateWithoutStallInput>
  }

  export type PaymentUpdateManyWithWhereWithoutStallInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutStallInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    payment_id?: IntFilter<"Payment"> | number
    stall_id?: IntNullableFilter<"Payment"> | number | null
    stallholder_id?: IntNullableFilter<"Payment"> | number | null
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeNullableFilter<"Payment"> | Date | string | null
    payment_type?: StringNullableFilter<"Payment"> | string | null
    payment_method?: StringNullableFilter<"Payment"> | string | null
    status?: StringFilter<"Payment"> | string
    reference_no?: StringNullableFilter<"Payment"> | string | null
    collector_id?: IntNullableFilter<"Payment"> | number | null
    notes?: StringNullableFilter<"Payment"> | string | null
    created_at?: DateTimeFilter<"Payment"> | Date | string
    updated_at?: DateTimeFilter<"Payment"> | Date | string
  }

  export type ComplianceUpsertWithWhereUniqueWithoutStallInput = {
    where: ComplianceWhereUniqueInput
    update: XOR<ComplianceUpdateWithoutStallInput, ComplianceUncheckedUpdateWithoutStallInput>
    create: XOR<ComplianceCreateWithoutStallInput, ComplianceUncheckedCreateWithoutStallInput>
  }

  export type ComplianceUpdateWithWhereUniqueWithoutStallInput = {
    where: ComplianceWhereUniqueInput
    data: XOR<ComplianceUpdateWithoutStallInput, ComplianceUncheckedUpdateWithoutStallInput>
  }

  export type ComplianceUpdateManyWithWhereWithoutStallInput = {
    where: ComplianceScalarWhereInput
    data: XOR<ComplianceUpdateManyMutationInput, ComplianceUncheckedUpdateManyWithoutStallInput>
  }

  export type ComplianceScalarWhereInput = {
    AND?: ComplianceScalarWhereInput | ComplianceScalarWhereInput[]
    OR?: ComplianceScalarWhereInput[]
    NOT?: ComplianceScalarWhereInput | ComplianceScalarWhereInput[]
    compliance_id?: IntFilter<"Compliance"> | number
    stall_id?: IntFilter<"Compliance"> | number
    inspector_id?: IntNullableFilter<"Compliance"> | number | null
    compliance_type?: StringNullableFilter<"Compliance"> | string | null
    status?: StringFilter<"Compliance"> | string
    inspection_date?: DateTimeNullableFilter<"Compliance"> | Date | string | null
    remarks?: StringNullableFilter<"Compliance"> | string | null
    evidence?: BytesNullableFilter<"Compliance"> | Bytes | null
    evidence_type?: StringNullableFilter<"Compliance"> | string | null
    created_at?: DateTimeFilter<"Compliance"> | Date | string
    updated_at?: DateTimeFilter<"Compliance"> | Date | string
  }

  export type ComplaintUpsertWithWhereUniqueWithoutStallInput = {
    where: ComplaintWhereUniqueInput
    update: XOR<ComplaintUpdateWithoutStallInput, ComplaintUncheckedUpdateWithoutStallInput>
    create: XOR<ComplaintCreateWithoutStallInput, ComplaintUncheckedCreateWithoutStallInput>
  }

  export type ComplaintUpdateWithWhereUniqueWithoutStallInput = {
    where: ComplaintWhereUniqueInput
    data: XOR<ComplaintUpdateWithoutStallInput, ComplaintUncheckedUpdateWithoutStallInput>
  }

  export type ComplaintUpdateManyWithWhereWithoutStallInput = {
    where: ComplaintScalarWhereInput
    data: XOR<ComplaintUpdateManyMutationInput, ComplaintUncheckedUpdateManyWithoutStallInput>
  }

  export type ComplaintScalarWhereInput = {
    AND?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    OR?: ComplaintScalarWhereInput[]
    NOT?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[]
    complaint_id?: IntFilter<"Complaint"> | number
    stall_id?: IntNullableFilter<"Complaint"> | number | null
    complainant?: StringNullableFilter<"Complaint"> | string | null
    complaint_type?: StringNullableFilter<"Complaint"> | string | null
    description?: StringNullableFilter<"Complaint"> | string | null
    status?: StringFilter<"Complaint"> | string
    resolution?: StringNullableFilter<"Complaint"> | string | null
    created_at?: DateTimeFilter<"Complaint"> | Date | string
    updated_at?: DateTimeFilter<"Complaint"> | Date | string
  }

  export type VendorUpsertWithWhereUniqueWithoutStallInput = {
    where: VendorWhereUniqueInput
    update: XOR<VendorUpdateWithoutStallInput, VendorUncheckedUpdateWithoutStallInput>
    create: XOR<VendorCreateWithoutStallInput, VendorUncheckedCreateWithoutStallInput>
  }

  export type VendorUpdateWithWhereUniqueWithoutStallInput = {
    where: VendorWhereUniqueInput
    data: XOR<VendorUpdateWithoutStallInput, VendorUncheckedUpdateWithoutStallInput>
  }

  export type VendorUpdateManyWithWhereWithoutStallInput = {
    where: VendorScalarWhereInput
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyWithoutStallInput>
  }

  export type VendorScalarWhereInput = {
    AND?: VendorScalarWhereInput | VendorScalarWhereInput[]
    OR?: VendorScalarWhereInput[]
    NOT?: VendorScalarWhereInput | VendorScalarWhereInput[]
    vendor_id?: IntFilter<"Vendor"> | number
    stall_id?: IntNullableFilter<"Vendor"> | number | null
    vendor_name?: StringFilter<"Vendor"> | string
    contact_number?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    product_type?: StringNullableFilter<"Vendor"> | string | null
    status?: StringFilter<"Vendor"> | string
    created_at?: DateTimeFilter<"Vendor"> | Date | string
    updated_at?: DateTimeFilter<"Vendor"> | Date | string
  }

  export type StallCreateWithoutImagesInput = {
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutStallsInput
    floor?: FloorCreateNestedOneWithoutStallsInput
    sectionRef?: SectionCreateNestedOneWithoutStallsInput
    stallholder?: StallholderCreateNestedOneWithoutStallsInput
    payments?: PaymentCreateNestedManyWithoutStallInput
    compliances?: ComplianceCreateNestedManyWithoutStallInput
    complaints?: ComplaintCreateNestedManyWithoutStallInput
    vendors?: VendorCreateNestedManyWithoutStallInput
  }

  export type StallUncheckedCreateWithoutImagesInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutStallInput
    compliances?: ComplianceUncheckedCreateNestedManyWithoutStallInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutStallInput
    vendors?: VendorUncheckedCreateNestedManyWithoutStallInput
  }

  export type StallCreateOrConnectWithoutImagesInput = {
    where: StallWhereUniqueInput
    create: XOR<StallCreateWithoutImagesInput, StallUncheckedCreateWithoutImagesInput>
  }

  export type StallUpsertWithoutImagesInput = {
    update: XOR<StallUpdateWithoutImagesInput, StallUncheckedUpdateWithoutImagesInput>
    create: XOR<StallCreateWithoutImagesInput, StallUncheckedCreateWithoutImagesInput>
    where?: StallWhereInput
  }

  export type StallUpdateToOneWithWhereWithoutImagesInput = {
    where?: StallWhereInput
    data: XOR<StallUpdateWithoutImagesInput, StallUncheckedUpdateWithoutImagesInput>
  }

  export type StallUpdateWithoutImagesInput = {
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStallsNestedInput
    floor?: FloorUpdateOneWithoutStallsNestedInput
    sectionRef?: SectionUpdateOneWithoutStallsNestedInput
    stallholder?: StallholderUpdateOneWithoutStallsNestedInput
    payments?: PaymentUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUpdateManyWithoutStallNestedInput
    vendors?: VendorUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateWithoutImagesInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUncheckedUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutStallNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutStallNestedInput
  }

  export type BranchCreateWithoutStallholdersInput = {
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallCreateNestedManyWithoutBranchInput
    employees?: EmployeeCreateNestedManyWithoutBranchInput
    floors?: FloorCreateNestedManyWithoutBranchInput
    sections?: SectionCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutStallholdersInput = {
    branch_id?: number
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutBranchInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutBranchInput
    floors?: FloorUncheckedCreateNestedManyWithoutBranchInput
    sections?: SectionUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutStallholdersInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutStallholdersInput, BranchUncheckedCreateWithoutStallholdersInput>
  }

  export type StallCreateWithoutStallholderInput = {
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutStallsInput
    floor?: FloorCreateNestedOneWithoutStallsInput
    sectionRef?: SectionCreateNestedOneWithoutStallsInput
    images?: StallImageCreateNestedManyWithoutStallInput
    payments?: PaymentCreateNestedManyWithoutStallInput
    compliances?: ComplianceCreateNestedManyWithoutStallInput
    complaints?: ComplaintCreateNestedManyWithoutStallInput
    vendors?: VendorCreateNestedManyWithoutStallInput
  }

  export type StallUncheckedCreateWithoutStallholderInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    images?: StallImageUncheckedCreateNestedManyWithoutStallInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStallInput
    compliances?: ComplianceUncheckedCreateNestedManyWithoutStallInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutStallInput
    vendors?: VendorUncheckedCreateNestedManyWithoutStallInput
  }

  export type StallCreateOrConnectWithoutStallholderInput = {
    where: StallWhereUniqueInput
    create: XOR<StallCreateWithoutStallholderInput, StallUncheckedCreateWithoutStallholderInput>
  }

  export type StallCreateManyStallholderInputEnvelope = {
    data: StallCreateManyStallholderInput | StallCreateManyStallholderInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutStallholderInput = {
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_type?: string | null
    payment_method?: string | null
    status?: string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stall?: StallCreateNestedOneWithoutPaymentsInput
    collector?: EmployeeCreateNestedOneWithoutCollectionsInput
  }

  export type PaymentUncheckedCreateWithoutStallholderInput = {
    payment_id?: number
    stall_id?: number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_type?: string | null
    payment_method?: string | null
    status?: string
    reference_no?: string | null
    collector_id?: number | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCreateOrConnectWithoutStallholderInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutStallholderInput, PaymentUncheckedCreateWithoutStallholderInput>
  }

  export type PaymentCreateManyStallholderInputEnvelope = {
    data: PaymentCreateManyStallholderInput | PaymentCreateManyStallholderInput[]
    skipDuplicates?: boolean
  }

  export type ApplicationCreateWithoutStallholderInput = {
    applicant_name?: string | null
    applicant_email?: string | null
    applicant_phone?: string | null
    business_name?: string | null
    business_type?: string | null
    stall_id?: number | null
    status?: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ApplicationUncheckedCreateWithoutStallholderInput = {
    application_id?: number
    applicant_name?: string | null
    applicant_email?: string | null
    applicant_phone?: string | null
    business_name?: string | null
    business_type?: string | null
    stall_id?: number | null
    status?: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ApplicationCreateOrConnectWithoutStallholderInput = {
    where: ApplicationWhereUniqueInput
    create: XOR<ApplicationCreateWithoutStallholderInput, ApplicationUncheckedCreateWithoutStallholderInput>
  }

  export type ApplicationCreateManyStallholderInputEnvelope = {
    data: ApplicationCreateManyStallholderInput | ApplicationCreateManyStallholderInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutStallholdersInput = {
    update: XOR<BranchUpdateWithoutStallholdersInput, BranchUncheckedUpdateWithoutStallholdersInput>
    create: XOR<BranchCreateWithoutStallholdersInput, BranchUncheckedCreateWithoutStallholdersInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutStallholdersInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutStallholdersInput, BranchUncheckedUpdateWithoutStallholdersInput>
  }

  export type BranchUpdateWithoutStallholdersInput = {
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUpdateManyWithoutBranchNestedInput
    employees?: EmployeeUpdateManyWithoutBranchNestedInput
    floors?: FloorUpdateManyWithoutBranchNestedInput
    sections?: SectionUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutStallholdersInput = {
    branch_id?: IntFieldUpdateOperationsInput | number
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutBranchNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutBranchNestedInput
    floors?: FloorUncheckedUpdateManyWithoutBranchNestedInput
    sections?: SectionUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type StallUpsertWithWhereUniqueWithoutStallholderInput = {
    where: StallWhereUniqueInput
    update: XOR<StallUpdateWithoutStallholderInput, StallUncheckedUpdateWithoutStallholderInput>
    create: XOR<StallCreateWithoutStallholderInput, StallUncheckedCreateWithoutStallholderInput>
  }

  export type StallUpdateWithWhereUniqueWithoutStallholderInput = {
    where: StallWhereUniqueInput
    data: XOR<StallUpdateWithoutStallholderInput, StallUncheckedUpdateWithoutStallholderInput>
  }

  export type StallUpdateManyWithWhereWithoutStallholderInput = {
    where: StallScalarWhereInput
    data: XOR<StallUpdateManyMutationInput, StallUncheckedUpdateManyWithoutStallholderInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutStallholderInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutStallholderInput, PaymentUncheckedUpdateWithoutStallholderInput>
    create: XOR<PaymentCreateWithoutStallholderInput, PaymentUncheckedCreateWithoutStallholderInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutStallholderInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutStallholderInput, PaymentUncheckedUpdateWithoutStallholderInput>
  }

  export type PaymentUpdateManyWithWhereWithoutStallholderInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutStallholderInput>
  }

  export type ApplicationUpsertWithWhereUniqueWithoutStallholderInput = {
    where: ApplicationWhereUniqueInput
    update: XOR<ApplicationUpdateWithoutStallholderInput, ApplicationUncheckedUpdateWithoutStallholderInput>
    create: XOR<ApplicationCreateWithoutStallholderInput, ApplicationUncheckedCreateWithoutStallholderInput>
  }

  export type ApplicationUpdateWithWhereUniqueWithoutStallholderInput = {
    where: ApplicationWhereUniqueInput
    data: XOR<ApplicationUpdateWithoutStallholderInput, ApplicationUncheckedUpdateWithoutStallholderInput>
  }

  export type ApplicationUpdateManyWithWhereWithoutStallholderInput = {
    where: ApplicationScalarWhereInput
    data: XOR<ApplicationUpdateManyMutationInput, ApplicationUncheckedUpdateManyWithoutStallholderInput>
  }

  export type ApplicationScalarWhereInput = {
    AND?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    OR?: ApplicationScalarWhereInput[]
    NOT?: ApplicationScalarWhereInput | ApplicationScalarWhereInput[]
    application_id?: IntFilter<"Application"> | number
    applicant_name?: StringNullableFilter<"Application"> | string | null
    applicant_email?: StringNullableFilter<"Application"> | string | null
    applicant_phone?: StringNullableFilter<"Application"> | string | null
    business_name?: StringNullableFilter<"Application"> | string | null
    business_type?: StringNullableFilter<"Application"> | string | null
    stall_id?: IntNullableFilter<"Application"> | number | null
    stallholder_id?: IntNullableFilter<"Application"> | number | null
    status?: StringFilter<"Application"> | string
    notes?: StringNullableFilter<"Application"> | string | null
    created_at?: DateTimeFilter<"Application"> | Date | string
    updated_at?: DateTimeFilter<"Application"> | Date | string
  }

  export type BranchCreateWithoutEmployeesInput = {
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallCreateNestedManyWithoutBranchInput
    floors?: FloorCreateNestedManyWithoutBranchInput
    sections?: SectionCreateNestedManyWithoutBranchInput
    stallholders?: StallholderCreateNestedManyWithoutBranchInput
  }

  export type BranchUncheckedCreateWithoutEmployeesInput = {
    branch_id?: number
    branch_name: string
    location?: string | null
    address?: string | null
    contact_number?: string | null
    email?: string | null
    description?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutBranchInput
    floors?: FloorUncheckedCreateNestedManyWithoutBranchInput
    sections?: SectionUncheckedCreateNestedManyWithoutBranchInput
    stallholders?: StallholderUncheckedCreateNestedManyWithoutBranchInput
  }

  export type BranchCreateOrConnectWithoutEmployeesInput = {
    where: BranchWhereUniqueInput
    create: XOR<BranchCreateWithoutEmployeesInput, BranchUncheckedCreateWithoutEmployeesInput>
  }

  export type ComplianceCreateWithoutInspectorInput = {
    compliance_type?: string | null
    status?: string
    inspection_date?: Date | string | null
    remarks?: string | null
    evidence?: Bytes | null
    evidence_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stall: StallCreateNestedOneWithoutCompliancesInput
  }

  export type ComplianceUncheckedCreateWithoutInspectorInput = {
    compliance_id?: number
    stall_id: number
    compliance_type?: string | null
    status?: string
    inspection_date?: Date | string | null
    remarks?: string | null
    evidence?: Bytes | null
    evidence_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplianceCreateOrConnectWithoutInspectorInput = {
    where: ComplianceWhereUniqueInput
    create: XOR<ComplianceCreateWithoutInspectorInput, ComplianceUncheckedCreateWithoutInspectorInput>
  }

  export type ComplianceCreateManyInspectorInputEnvelope = {
    data: ComplianceCreateManyInspectorInput | ComplianceCreateManyInspectorInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutCollectorInput = {
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_type?: string | null
    payment_method?: string | null
    status?: string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stall?: StallCreateNestedOneWithoutPaymentsInput
    stallholder?: StallholderCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutCollectorInput = {
    payment_id?: number
    stall_id?: number | null
    stallholder_id?: number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_type?: string | null
    payment_method?: string | null
    status?: string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCreateOrConnectWithoutCollectorInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutCollectorInput, PaymentUncheckedCreateWithoutCollectorInput>
  }

  export type PaymentCreateManyCollectorInputEnvelope = {
    data: PaymentCreateManyCollectorInput | PaymentCreateManyCollectorInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutEmployeeInput = {
    action: string
    description?: string | null
    entity_type?: string | null
    entity_id?: number | null
    ip_address?: string | null
    created_at?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutEmployeeInput = {
    log_id?: number
    action: string
    description?: string | null
    entity_type?: string | null
    entity_id?: number | null
    ip_address?: string | null
    created_at?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutEmployeeInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutEmployeeInput, ActivityLogUncheckedCreateWithoutEmployeeInput>
  }

  export type ActivityLogCreateManyEmployeeInputEnvelope = {
    data: ActivityLogCreateManyEmployeeInput | ActivityLogCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type BranchUpsertWithoutEmployeesInput = {
    update: XOR<BranchUpdateWithoutEmployeesInput, BranchUncheckedUpdateWithoutEmployeesInput>
    create: XOR<BranchCreateWithoutEmployeesInput, BranchUncheckedCreateWithoutEmployeesInput>
    where?: BranchWhereInput
  }

  export type BranchUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: BranchWhereInput
    data: XOR<BranchUpdateWithoutEmployeesInput, BranchUncheckedUpdateWithoutEmployeesInput>
  }

  export type BranchUpdateWithoutEmployeesInput = {
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUpdateManyWithoutBranchNestedInput
    floors?: FloorUpdateManyWithoutBranchNestedInput
    sections?: SectionUpdateManyWithoutBranchNestedInput
    stallholders?: StallholderUpdateManyWithoutBranchNestedInput
  }

  export type BranchUncheckedUpdateWithoutEmployeesInput = {
    branch_id?: IntFieldUpdateOperationsInput | number
    branch_name?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutBranchNestedInput
    floors?: FloorUncheckedUpdateManyWithoutBranchNestedInput
    sections?: SectionUncheckedUpdateManyWithoutBranchNestedInput
    stallholders?: StallholderUncheckedUpdateManyWithoutBranchNestedInput
  }

  export type ComplianceUpsertWithWhereUniqueWithoutInspectorInput = {
    where: ComplianceWhereUniqueInput
    update: XOR<ComplianceUpdateWithoutInspectorInput, ComplianceUncheckedUpdateWithoutInspectorInput>
    create: XOR<ComplianceCreateWithoutInspectorInput, ComplianceUncheckedCreateWithoutInspectorInput>
  }

  export type ComplianceUpdateWithWhereUniqueWithoutInspectorInput = {
    where: ComplianceWhereUniqueInput
    data: XOR<ComplianceUpdateWithoutInspectorInput, ComplianceUncheckedUpdateWithoutInspectorInput>
  }

  export type ComplianceUpdateManyWithWhereWithoutInspectorInput = {
    where: ComplianceScalarWhereInput
    data: XOR<ComplianceUpdateManyMutationInput, ComplianceUncheckedUpdateManyWithoutInspectorInput>
  }

  export type PaymentUpsertWithWhereUniqueWithoutCollectorInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutCollectorInput, PaymentUncheckedUpdateWithoutCollectorInput>
    create: XOR<PaymentCreateWithoutCollectorInput, PaymentUncheckedCreateWithoutCollectorInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutCollectorInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutCollectorInput, PaymentUncheckedUpdateWithoutCollectorInput>
  }

  export type PaymentUpdateManyWithWhereWithoutCollectorInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutCollectorInput>
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutEmployeeInput, ActivityLogUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ActivityLogCreateWithoutEmployeeInput, ActivityLogUncheckedCreateWithoutEmployeeInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutEmployeeInput, ActivityLogUncheckedUpdateWithoutEmployeeInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutEmployeeInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    log_id?: IntFilter<"ActivityLog"> | number
    employee_id?: IntNullableFilter<"ActivityLog"> | number | null
    action?: StringFilter<"ActivityLog"> | string
    description?: StringNullableFilter<"ActivityLog"> | string | null
    entity_type?: StringNullableFilter<"ActivityLog"> | string | null
    entity_id?: IntNullableFilter<"ActivityLog"> | number | null
    ip_address?: StringNullableFilter<"ActivityLog"> | string | null
    created_at?: DateTimeFilter<"ActivityLog"> | Date | string
  }

  export type StallholderCreateWithoutApplicationsInput = {
    first_name: string
    last_name: string
    email?: string | null
    phone_number?: string | null
    address?: string | null
    business_name?: string | null
    business_type?: string | null
    status?: string
    password?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch?: BranchCreateNestedOneWithoutStallholdersInput
    stalls?: StallCreateNestedManyWithoutStallholderInput
    payments?: PaymentCreateNestedManyWithoutStallholderInput
  }

  export type StallholderUncheckedCreateWithoutApplicationsInput = {
    stallholder_id?: number
    first_name: string
    last_name: string
    email?: string | null
    phone_number?: string | null
    address?: string | null
    business_name?: string | null
    business_type?: string | null
    branch_id?: number | null
    status?: string
    password?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutStallholderInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStallholderInput
  }

  export type StallholderCreateOrConnectWithoutApplicationsInput = {
    where: StallholderWhereUniqueInput
    create: XOR<StallholderCreateWithoutApplicationsInput, StallholderUncheckedCreateWithoutApplicationsInput>
  }

  export type StallholderUpsertWithoutApplicationsInput = {
    update: XOR<StallholderUpdateWithoutApplicationsInput, StallholderUncheckedUpdateWithoutApplicationsInput>
    create: XOR<StallholderCreateWithoutApplicationsInput, StallholderUncheckedCreateWithoutApplicationsInput>
    where?: StallholderWhereInput
  }

  export type StallholderUpdateToOneWithWhereWithoutApplicationsInput = {
    where?: StallholderWhereInput
    data: XOR<StallholderUpdateWithoutApplicationsInput, StallholderUncheckedUpdateWithoutApplicationsInput>
  }

  export type StallholderUpdateWithoutApplicationsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutStallholdersNestedInput
    stalls?: StallUpdateManyWithoutStallholderNestedInput
    payments?: PaymentUpdateManyWithoutStallholderNestedInput
  }

  export type StallholderUncheckedUpdateWithoutApplicationsInput = {
    stallholder_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutStallholderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStallholderNestedInput
  }

  export type StallCreateWithoutPaymentsInput = {
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutStallsInput
    floor?: FloorCreateNestedOneWithoutStallsInput
    sectionRef?: SectionCreateNestedOneWithoutStallsInput
    stallholder?: StallholderCreateNestedOneWithoutStallsInput
    images?: StallImageCreateNestedManyWithoutStallInput
    compliances?: ComplianceCreateNestedManyWithoutStallInput
    complaints?: ComplaintCreateNestedManyWithoutStallInput
    vendors?: VendorCreateNestedManyWithoutStallInput
  }

  export type StallUncheckedCreateWithoutPaymentsInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    images?: StallImageUncheckedCreateNestedManyWithoutStallInput
    compliances?: ComplianceUncheckedCreateNestedManyWithoutStallInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutStallInput
    vendors?: VendorUncheckedCreateNestedManyWithoutStallInput
  }

  export type StallCreateOrConnectWithoutPaymentsInput = {
    where: StallWhereUniqueInput
    create: XOR<StallCreateWithoutPaymentsInput, StallUncheckedCreateWithoutPaymentsInput>
  }

  export type StallholderCreateWithoutPaymentsInput = {
    first_name: string
    last_name: string
    email?: string | null
    phone_number?: string | null
    address?: string | null
    business_name?: string | null
    business_type?: string | null
    status?: string
    password?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch?: BranchCreateNestedOneWithoutStallholdersInput
    stalls?: StallCreateNestedManyWithoutStallholderInput
    applications?: ApplicationCreateNestedManyWithoutStallholderInput
  }

  export type StallholderUncheckedCreateWithoutPaymentsInput = {
    stallholder_id?: number
    first_name: string
    last_name: string
    email?: string | null
    phone_number?: string | null
    address?: string | null
    business_name?: string | null
    business_type?: string | null
    branch_id?: number | null
    status?: string
    password?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    stalls?: StallUncheckedCreateNestedManyWithoutStallholderInput
    applications?: ApplicationUncheckedCreateNestedManyWithoutStallholderInput
  }

  export type StallholderCreateOrConnectWithoutPaymentsInput = {
    where: StallholderWhereUniqueInput
    create: XOR<StallholderCreateWithoutPaymentsInput, StallholderUncheckedCreateWithoutPaymentsInput>
  }

  export type EmployeeCreateWithoutCollectionsInput = {
    first_name: string
    last_name: string
    email: string
    phone_number?: string | null
    position?: string | null
    role?: string
    password: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    inspections?: ComplianceCreateNestedManyWithoutInspectorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutCollectionsInput = {
    employee_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number?: string | null
    position?: string | null
    role?: string
    branch_id?: number | null
    password: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    inspections?: ComplianceUncheckedCreateNestedManyWithoutInspectorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutCollectionsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutCollectionsInput, EmployeeUncheckedCreateWithoutCollectionsInput>
  }

  export type StallUpsertWithoutPaymentsInput = {
    update: XOR<StallUpdateWithoutPaymentsInput, StallUncheckedUpdateWithoutPaymentsInput>
    create: XOR<StallCreateWithoutPaymentsInput, StallUncheckedCreateWithoutPaymentsInput>
    where?: StallWhereInput
  }

  export type StallUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: StallWhereInput
    data: XOR<StallUpdateWithoutPaymentsInput, StallUncheckedUpdateWithoutPaymentsInput>
  }

  export type StallUpdateWithoutPaymentsInput = {
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStallsNestedInput
    floor?: FloorUpdateOneWithoutStallsNestedInput
    sectionRef?: SectionUpdateOneWithoutStallsNestedInput
    stallholder?: StallholderUpdateOneWithoutStallsNestedInput
    images?: StallImageUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUpdateManyWithoutStallNestedInput
    vendors?: VendorUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateWithoutPaymentsInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StallImageUncheckedUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUncheckedUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutStallNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutStallNestedInput
  }

  export type StallholderUpsertWithoutPaymentsInput = {
    update: XOR<StallholderUpdateWithoutPaymentsInput, StallholderUncheckedUpdateWithoutPaymentsInput>
    create: XOR<StallholderCreateWithoutPaymentsInput, StallholderUncheckedCreateWithoutPaymentsInput>
    where?: StallholderWhereInput
  }

  export type StallholderUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: StallholderWhereInput
    data: XOR<StallholderUpdateWithoutPaymentsInput, StallholderUncheckedUpdateWithoutPaymentsInput>
  }

  export type StallholderUpdateWithoutPaymentsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutStallholdersNestedInput
    stalls?: StallUpdateManyWithoutStallholderNestedInput
    applications?: ApplicationUpdateManyWithoutStallholderNestedInput
  }

  export type StallholderUncheckedUpdateWithoutPaymentsInput = {
    stallholder_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutStallholderNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutStallholderNestedInput
  }

  export type EmployeeUpsertWithoutCollectionsInput = {
    update: XOR<EmployeeUpdateWithoutCollectionsInput, EmployeeUncheckedUpdateWithoutCollectionsInput>
    create: XOR<EmployeeCreateWithoutCollectionsInput, EmployeeUncheckedCreateWithoutCollectionsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutCollectionsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutCollectionsInput, EmployeeUncheckedUpdateWithoutCollectionsInput>
  }

  export type EmployeeUpdateWithoutCollectionsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    inspections?: ComplianceUpdateManyWithoutInspectorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutCollectionsInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inspections?: ComplianceUncheckedUpdateManyWithoutInspectorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type StallCreateWithoutCompliancesInput = {
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutStallsInput
    floor?: FloorCreateNestedOneWithoutStallsInput
    sectionRef?: SectionCreateNestedOneWithoutStallsInput
    stallholder?: StallholderCreateNestedOneWithoutStallsInput
    images?: StallImageCreateNestedManyWithoutStallInput
    payments?: PaymentCreateNestedManyWithoutStallInput
    complaints?: ComplaintCreateNestedManyWithoutStallInput
    vendors?: VendorCreateNestedManyWithoutStallInput
  }

  export type StallUncheckedCreateWithoutCompliancesInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    images?: StallImageUncheckedCreateNestedManyWithoutStallInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStallInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutStallInput
    vendors?: VendorUncheckedCreateNestedManyWithoutStallInput
  }

  export type StallCreateOrConnectWithoutCompliancesInput = {
    where: StallWhereUniqueInput
    create: XOR<StallCreateWithoutCompliancesInput, StallUncheckedCreateWithoutCompliancesInput>
  }

  export type EmployeeCreateWithoutInspectionsInput = {
    first_name: string
    last_name: string
    email: string
    phone_number?: string | null
    position?: string | null
    role?: string
    password: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    collections?: PaymentCreateNestedManyWithoutCollectorInput
    activityLogs?: ActivityLogCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutInspectionsInput = {
    employee_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number?: string | null
    position?: string | null
    role?: string
    branch_id?: number | null
    password: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    collections?: PaymentUncheckedCreateNestedManyWithoutCollectorInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutInspectionsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutInspectionsInput, EmployeeUncheckedCreateWithoutInspectionsInput>
  }

  export type StallUpsertWithoutCompliancesInput = {
    update: XOR<StallUpdateWithoutCompliancesInput, StallUncheckedUpdateWithoutCompliancesInput>
    create: XOR<StallCreateWithoutCompliancesInput, StallUncheckedCreateWithoutCompliancesInput>
    where?: StallWhereInput
  }

  export type StallUpdateToOneWithWhereWithoutCompliancesInput = {
    where?: StallWhereInput
    data: XOR<StallUpdateWithoutCompliancesInput, StallUncheckedUpdateWithoutCompliancesInput>
  }

  export type StallUpdateWithoutCompliancesInput = {
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStallsNestedInput
    floor?: FloorUpdateOneWithoutStallsNestedInput
    sectionRef?: SectionUpdateOneWithoutStallsNestedInput
    stallholder?: StallholderUpdateOneWithoutStallsNestedInput
    images?: StallImageUpdateManyWithoutStallNestedInput
    payments?: PaymentUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUpdateManyWithoutStallNestedInput
    vendors?: VendorUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateWithoutCompliancesInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StallImageUncheckedUpdateManyWithoutStallNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutStallNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutStallNestedInput
  }

  export type EmployeeUpsertWithoutInspectionsInput = {
    update: XOR<EmployeeUpdateWithoutInspectionsInput, EmployeeUncheckedUpdateWithoutInspectionsInput>
    create: XOR<EmployeeCreateWithoutInspectionsInput, EmployeeUncheckedCreateWithoutInspectionsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutInspectionsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutInspectionsInput, EmployeeUncheckedUpdateWithoutInspectionsInput>
  }

  export type EmployeeUpdateWithoutInspectionsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    collections?: PaymentUpdateManyWithoutCollectorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutInspectionsInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    collections?: PaymentUncheckedUpdateManyWithoutCollectorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type StallCreateWithoutComplaintsInput = {
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutStallsInput
    floor?: FloorCreateNestedOneWithoutStallsInput
    sectionRef?: SectionCreateNestedOneWithoutStallsInput
    stallholder?: StallholderCreateNestedOneWithoutStallsInput
    images?: StallImageCreateNestedManyWithoutStallInput
    payments?: PaymentCreateNestedManyWithoutStallInput
    compliances?: ComplianceCreateNestedManyWithoutStallInput
    vendors?: VendorCreateNestedManyWithoutStallInput
  }

  export type StallUncheckedCreateWithoutComplaintsInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    images?: StallImageUncheckedCreateNestedManyWithoutStallInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStallInput
    compliances?: ComplianceUncheckedCreateNestedManyWithoutStallInput
    vendors?: VendorUncheckedCreateNestedManyWithoutStallInput
  }

  export type StallCreateOrConnectWithoutComplaintsInput = {
    where: StallWhereUniqueInput
    create: XOR<StallCreateWithoutComplaintsInput, StallUncheckedCreateWithoutComplaintsInput>
  }

  export type StallUpsertWithoutComplaintsInput = {
    update: XOR<StallUpdateWithoutComplaintsInput, StallUncheckedUpdateWithoutComplaintsInput>
    create: XOR<StallCreateWithoutComplaintsInput, StallUncheckedCreateWithoutComplaintsInput>
    where?: StallWhereInput
  }

  export type StallUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: StallWhereInput
    data: XOR<StallUpdateWithoutComplaintsInput, StallUncheckedUpdateWithoutComplaintsInput>
  }

  export type StallUpdateWithoutComplaintsInput = {
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStallsNestedInput
    floor?: FloorUpdateOneWithoutStallsNestedInput
    sectionRef?: SectionUpdateOneWithoutStallsNestedInput
    stallholder?: StallholderUpdateOneWithoutStallsNestedInput
    images?: StallImageUpdateManyWithoutStallNestedInput
    payments?: PaymentUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUpdateManyWithoutStallNestedInput
    vendors?: VendorUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateWithoutComplaintsInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StallImageUncheckedUpdateManyWithoutStallNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUncheckedUpdateManyWithoutStallNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutStallNestedInput
  }

  export type StallCreateWithoutVendorsInput = {
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    branch: BranchCreateNestedOneWithoutStallsInput
    floor?: FloorCreateNestedOneWithoutStallsInput
    sectionRef?: SectionCreateNestedOneWithoutStallsInput
    stallholder?: StallholderCreateNestedOneWithoutStallsInput
    images?: StallImageCreateNestedManyWithoutStallInput
    payments?: PaymentCreateNestedManyWithoutStallInput
    compliances?: ComplianceCreateNestedManyWithoutStallInput
    complaints?: ComplaintCreateNestedManyWithoutStallInput
  }

  export type StallUncheckedCreateWithoutVendorsInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    images?: StallImageUncheckedCreateNestedManyWithoutStallInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStallInput
    compliances?: ComplianceUncheckedCreateNestedManyWithoutStallInput
    complaints?: ComplaintUncheckedCreateNestedManyWithoutStallInput
  }

  export type StallCreateOrConnectWithoutVendorsInput = {
    where: StallWhereUniqueInput
    create: XOR<StallCreateWithoutVendorsInput, StallUncheckedCreateWithoutVendorsInput>
  }

  export type StallUpsertWithoutVendorsInput = {
    update: XOR<StallUpdateWithoutVendorsInput, StallUncheckedUpdateWithoutVendorsInput>
    create: XOR<StallCreateWithoutVendorsInput, StallUncheckedCreateWithoutVendorsInput>
    where?: StallWhereInput
  }

  export type StallUpdateToOneWithWhereWithoutVendorsInput = {
    where?: StallWhereInput
    data: XOR<StallUpdateWithoutVendorsInput, StallUncheckedUpdateWithoutVendorsInput>
  }

  export type StallUpdateWithoutVendorsInput = {
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStallsNestedInput
    floor?: FloorUpdateOneWithoutStallsNestedInput
    sectionRef?: SectionUpdateOneWithoutStallsNestedInput
    stallholder?: StallholderUpdateOneWithoutStallsNestedInput
    images?: StallImageUpdateManyWithoutStallNestedInput
    payments?: PaymentUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateWithoutVendorsInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StallImageUncheckedUpdateManyWithoutStallNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUncheckedUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutStallNestedInput
  }

  export type EmployeeCreateWithoutActivityLogsInput = {
    first_name: string
    last_name: string
    email: string
    phone_number?: string | null
    position?: string | null
    role?: string
    password: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    branch?: BranchCreateNestedOneWithoutEmployeesInput
    inspections?: ComplianceCreateNestedManyWithoutInspectorInput
    collections?: PaymentCreateNestedManyWithoutCollectorInput
  }

  export type EmployeeUncheckedCreateWithoutActivityLogsInput = {
    employee_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number?: string | null
    position?: string | null
    role?: string
    branch_id?: number | null
    password: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
    inspections?: ComplianceUncheckedCreateNestedManyWithoutInspectorInput
    collections?: PaymentUncheckedCreateNestedManyWithoutCollectorInput
  }

  export type EmployeeCreateOrConnectWithoutActivityLogsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutActivityLogsInput, EmployeeUncheckedCreateWithoutActivityLogsInput>
  }

  export type EmployeeUpsertWithoutActivityLogsInput = {
    update: XOR<EmployeeUpdateWithoutActivityLogsInput, EmployeeUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<EmployeeCreateWithoutActivityLogsInput, EmployeeUncheckedCreateWithoutActivityLogsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutActivityLogsInput, EmployeeUncheckedUpdateWithoutActivityLogsInput>
  }

  export type EmployeeUpdateWithoutActivityLogsInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneWithoutEmployeesNestedInput
    inspections?: ComplianceUpdateManyWithoutInspectorNestedInput
    collections?: PaymentUpdateManyWithoutCollectorNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutActivityLogsInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    branch_id?: NullableIntFieldUpdateOperationsInput | number | null
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inspections?: ComplianceUncheckedUpdateManyWithoutInspectorNestedInput
    collections?: PaymentUncheckedUpdateManyWithoutCollectorNestedInput
  }

  export type StallCreateManyBranchInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmployeeCreateManyBranchInput = {
    employee_id?: number
    first_name: string
    last_name: string
    email: string
    phone_number?: string | null
    position?: string | null
    role?: string
    password: string
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type FloorCreateManyBranchInput = {
    floor_id?: number
    floor_name: string
    floor_number: number
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SectionCreateManyBranchInput = {
    section_id?: number
    floor_id?: number | null
    section_name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StallholderCreateManyBranchInput = {
    stallholder_id?: number
    first_name: string
    last_name: string
    email?: string | null
    phone_number?: string | null
    address?: string | null
    business_name?: string | null
    business_type?: string | null
    status?: string
    password?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StallUpdateWithoutBranchInput = {
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    floor?: FloorUpdateOneWithoutStallsNestedInput
    sectionRef?: SectionUpdateOneWithoutStallsNestedInput
    stallholder?: StallholderUpdateOneWithoutStallsNestedInput
    images?: StallImageUpdateManyWithoutStallNestedInput
    payments?: PaymentUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUpdateManyWithoutStallNestedInput
    vendors?: VendorUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateWithoutBranchInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StallImageUncheckedUpdateManyWithoutStallNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUncheckedUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutStallNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateManyWithoutBranchInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutBranchInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inspections?: ComplianceUpdateManyWithoutInspectorNestedInput
    collections?: PaymentUpdateManyWithoutCollectorNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutBranchInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inspections?: ComplianceUncheckedUpdateManyWithoutInspectorNestedInput
    collections?: PaymentUncheckedUpdateManyWithoutCollectorNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutBranchInput = {
    employee_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    position?: NullableStringFieldUpdateOperationsInput | string | null
    role?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FloorUpdateWithoutBranchInput = {
    floor_name?: StringFieldUpdateOperationsInput | string
    floor_number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUpdateManyWithoutFloorNestedInput
    sections?: SectionUpdateManyWithoutFloorNestedInput
  }

  export type FloorUncheckedUpdateWithoutBranchInput = {
    floor_id?: IntFieldUpdateOperationsInput | number
    floor_name?: StringFieldUpdateOperationsInput | string
    floor_number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutFloorNestedInput
    sections?: SectionUncheckedUpdateManyWithoutFloorNestedInput
  }

  export type FloorUncheckedUpdateManyWithoutBranchInput = {
    floor_id?: IntFieldUpdateOperationsInput | number
    floor_name?: StringFieldUpdateOperationsInput | string
    floor_number?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUpdateWithoutBranchInput = {
    section_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    floor?: FloorUpdateOneWithoutSectionsNestedInput
    stalls?: StallUpdateManyWithoutSectionRefNestedInput
  }

  export type SectionUncheckedUpdateWithoutBranchInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutSectionRefNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutBranchInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallholderUpdateWithoutBranchInput = {
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUpdateManyWithoutStallholderNestedInput
    payments?: PaymentUpdateManyWithoutStallholderNestedInput
    applications?: ApplicationUpdateManyWithoutStallholderNestedInput
  }

  export type StallholderUncheckedUpdateWithoutBranchInput = {
    stallholder_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutStallholderNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStallholderNestedInput
    applications?: ApplicationUncheckedUpdateManyWithoutStallholderNestedInput
  }

  export type StallholderUncheckedUpdateManyWithoutBranchInput = {
    stallholder_id?: IntFieldUpdateOperationsInput | number
    first_name?: StringFieldUpdateOperationsInput | string
    last_name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallCreateManyFloorInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SectionCreateManyFloorInput = {
    section_id?: number
    branch_id: number
    section_name: string
    description?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StallUpdateWithoutFloorInput = {
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStallsNestedInput
    sectionRef?: SectionUpdateOneWithoutStallsNestedInput
    stallholder?: StallholderUpdateOneWithoutStallsNestedInput
    images?: StallImageUpdateManyWithoutStallNestedInput
    payments?: PaymentUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUpdateManyWithoutStallNestedInput
    vendors?: VendorUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateWithoutFloorInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StallImageUncheckedUpdateManyWithoutStallNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUncheckedUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutStallNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateManyWithoutFloorInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SectionUpdateWithoutFloorInput = {
    section_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutSectionsNestedInput
    stalls?: StallUpdateManyWithoutSectionRefNestedInput
  }

  export type SectionUncheckedUpdateWithoutFloorInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    section_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stalls?: StallUncheckedUpdateManyWithoutSectionRefNestedInput
  }

  export type SectionUncheckedUpdateManyWithoutFloorInput = {
    section_id?: IntFieldUpdateOperationsInput | number
    branch_id?: IntFieldUpdateOperationsInput | number
    section_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallCreateManySectionRefInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    stallholder_id?: number | null
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StallUpdateWithoutSectionRefInput = {
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStallsNestedInput
    floor?: FloorUpdateOneWithoutStallsNestedInput
    stallholder?: StallholderUpdateOneWithoutStallsNestedInput
    images?: StallImageUpdateManyWithoutStallNestedInput
    payments?: PaymentUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUpdateManyWithoutStallNestedInput
    vendors?: VendorUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateWithoutSectionRefInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StallImageUncheckedUpdateManyWithoutStallNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUncheckedUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutStallNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateManyWithoutSectionRefInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallImageCreateManyStallInput = {
    image_id?: number
    filename?: string | null
    image_data?: Bytes | null
    mime_type?: string | null
    is_primary?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCreateManyStallInput = {
    payment_id?: number
    stallholder_id?: number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_type?: string | null
    payment_method?: string | null
    status?: string
    reference_no?: string | null
    collector_id?: number | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplianceCreateManyStallInput = {
    compliance_id?: number
    inspector_id?: number | null
    compliance_type?: string | null
    status?: string
    inspection_date?: Date | string | null
    remarks?: string | null
    evidence?: Bytes | null
    evidence_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ComplaintCreateManyStallInput = {
    complaint_id?: number
    complainant?: string | null
    complaint_type?: string | null
    description?: string | null
    status?: string
    resolution?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorCreateManyStallInput = {
    vendor_id?: number
    vendor_name: string
    contact_number?: string | null
    email?: string | null
    product_type?: string | null
    status?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StallImageUpdateWithoutStallInput = {
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    image_data?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallImageUncheckedUpdateWithoutStallInput = {
    image_id?: IntFieldUpdateOperationsInput | number
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    image_data?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallImageUncheckedUpdateManyWithoutStallInput = {
    image_id?: IntFieldUpdateOperationsInput | number
    filename?: NullableStringFieldUpdateOperationsInput | string | null
    image_data?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    mime_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_primary?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutStallInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stallholder?: StallholderUpdateOneWithoutPaymentsNestedInput
    collector?: EmployeeUpdateOneWithoutCollectionsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutStallInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    collector_id?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutStallInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    collector_id?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceUpdateWithoutStallInput = {
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inspection_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    evidence_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector?: EmployeeUpdateOneWithoutInspectionsNestedInput
  }

  export type ComplianceUncheckedUpdateWithoutStallInput = {
    compliance_id?: IntFieldUpdateOperationsInput | number
    inspector_id?: NullableIntFieldUpdateOperationsInput | number | null
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inspection_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    evidence_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceUncheckedUpdateManyWithoutStallInput = {
    compliance_id?: IntFieldUpdateOperationsInput | number
    inspector_id?: NullableIntFieldUpdateOperationsInput | number | null
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inspection_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    evidence_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUpdateWithoutStallInput = {
    complainant?: NullableStringFieldUpdateOperationsInput | string | null
    complaint_type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateWithoutStallInput = {
    complaint_id?: IntFieldUpdateOperationsInput | number
    complainant?: NullableStringFieldUpdateOperationsInput | string | null
    complaint_type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplaintUncheckedUpdateManyWithoutStallInput = {
    complaint_id?: IntFieldUpdateOperationsInput | number
    complainant?: NullableStringFieldUpdateOperationsInput | string | null
    complaint_type?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    resolution?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUpdateWithoutStallInput = {
    vendor_name?: StringFieldUpdateOperationsInput | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    product_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateWithoutStallInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    vendor_name?: StringFieldUpdateOperationsInput | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    product_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyWithoutStallInput = {
    vendor_id?: IntFieldUpdateOperationsInput | number
    vendor_name?: StringFieldUpdateOperationsInput | string
    contact_number?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    product_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StallCreateManyStallholderInput = {
    stall_id?: number
    stall_number?: string | null
    stall_name?: string | null
    stall_type?: string | null
    stall_size?: string | null
    stall_location?: string | null
    size?: string | null
    area_sqm?: Decimal | DecimalJsLike | number | string | null
    floor_id?: number | null
    section_id?: number | null
    monthly_rent?: Decimal | DecimalJsLike | number | string | null
    rental_price?: Decimal | DecimalJsLike | number | string | null
    status?: string
    branch_id: number
    floor_level?: string | null
    section?: string | null
    description?: string | null
    price_type?: string | null
    is_available?: boolean
    base_rate?: Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCreateManyStallholderInput = {
    payment_id?: number
    stall_id?: number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_type?: string | null
    payment_method?: string | null
    status?: string
    reference_no?: string | null
    collector_id?: number | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ApplicationCreateManyStallholderInput = {
    application_id?: number
    applicant_name?: string | null
    applicant_email?: string | null
    applicant_phone?: string | null
    business_name?: string | null
    business_type?: string | null
    stall_id?: number | null
    status?: string
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type StallUpdateWithoutStallholderInput = {
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    branch?: BranchUpdateOneRequiredWithoutStallsNestedInput
    floor?: FloorUpdateOneWithoutStallsNestedInput
    sectionRef?: SectionUpdateOneWithoutStallsNestedInput
    images?: StallImageUpdateManyWithoutStallNestedInput
    payments?: PaymentUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUpdateManyWithoutStallNestedInput
    vendors?: VendorUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateWithoutStallholderInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: StallImageUncheckedUpdateManyWithoutStallNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStallNestedInput
    compliances?: ComplianceUncheckedUpdateManyWithoutStallNestedInput
    complaints?: ComplaintUncheckedUpdateManyWithoutStallNestedInput
    vendors?: VendorUncheckedUpdateManyWithoutStallNestedInput
  }

  export type StallUncheckedUpdateManyWithoutStallholderInput = {
    stall_id?: IntFieldUpdateOperationsInput | number
    stall_number?: NullableStringFieldUpdateOperationsInput | string | null
    stall_name?: NullableStringFieldUpdateOperationsInput | string | null
    stall_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_size?: NullableStringFieldUpdateOperationsInput | string | null
    stall_location?: NullableStringFieldUpdateOperationsInput | string | null
    size?: NullableStringFieldUpdateOperationsInput | string | null
    area_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    floor_id?: NullableIntFieldUpdateOperationsInput | number | null
    section_id?: NullableIntFieldUpdateOperationsInput | number | null
    monthly_rent?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rental_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    status?: StringFieldUpdateOperationsInput | string
    branch_id?: IntFieldUpdateOperationsInput | number
    floor_level?: NullableStringFieldUpdateOperationsInput | string | null
    section?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price_type?: NullableStringFieldUpdateOperationsInput | string | null
    is_available?: BoolFieldUpdateOperationsInput | boolean
    base_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rate_per_sqm?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutStallholderInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stall?: StallUpdateOneWithoutPaymentsNestedInput
    collector?: EmployeeUpdateOneWithoutCollectionsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutStallholderInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    collector_id?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutStallholderInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    collector_id?: NullableIntFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUpdateWithoutStallholderInput = {
    applicant_name?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_email?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateWithoutStallholderInput = {
    application_id?: IntFieldUpdateOperationsInput | number
    applicant_name?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_email?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ApplicationUncheckedUpdateManyWithoutStallholderInput = {
    application_id?: IntFieldUpdateOperationsInput | number
    applicant_name?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_email?: NullableStringFieldUpdateOperationsInput | string | null
    applicant_phone?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_type?: NullableStringFieldUpdateOperationsInput | string | null
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceCreateManyInspectorInput = {
    compliance_id?: number
    stall_id: number
    compliance_type?: string | null
    status?: string
    inspection_date?: Date | string | null
    remarks?: string | null
    evidence?: Bytes | null
    evidence_type?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCreateManyCollectorInput = {
    payment_id?: number
    stall_id?: number | null
    stallholder_id?: number | null
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string | null
    payment_type?: string | null
    payment_method?: string | null
    status?: string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ActivityLogCreateManyEmployeeInput = {
    log_id?: number
    action: string
    description?: string | null
    entity_type?: string | null
    entity_id?: number | null
    ip_address?: string | null
    created_at?: Date | string
  }

  export type ComplianceUpdateWithoutInspectorInput = {
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inspection_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    evidence_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stall?: StallUpdateOneRequiredWithoutCompliancesNestedInput
  }

  export type ComplianceUncheckedUpdateWithoutInspectorInput = {
    compliance_id?: IntFieldUpdateOperationsInput | number
    stall_id?: IntFieldUpdateOperationsInput | number
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inspection_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    evidence_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceUncheckedUpdateManyWithoutInspectorInput = {
    compliance_id?: IntFieldUpdateOperationsInput | number
    stall_id?: IntFieldUpdateOperationsInput | number
    compliance_type?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    inspection_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    remarks?: NullableStringFieldUpdateOperationsInput | string | null
    evidence?: NullableBytesFieldUpdateOperationsInput | Bytes | null
    evidence_type?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutCollectorInput = {
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    stall?: StallUpdateOneWithoutPaymentsNestedInput
    stallholder?: StallholderUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutCollectorInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutCollectorInput = {
    payment_id?: IntFieldUpdateOperationsInput | number
    stall_id?: NullableIntFieldUpdateOperationsInput | number | null
    stallholder_id?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payment_type?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUpdateWithoutEmployeeInput = {
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutEmployeeInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutEmployeeInput = {
    log_id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    entity_type?: NullableStringFieldUpdateOperationsInput | string | null
    entity_id?: NullableIntFieldUpdateOperationsInput | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}